@Test public void testPositiveOctantByIntersection(){
  double tol=0.01;
  double sinTol=FastMath.sin(tol);
  RegionFactory<Sphere2D> factory=new RegionFactory<Sphere2D>();
  SphericalPolygonsSet plusX=new SphericalPolygonsSet(Vector3D.PLUS_I,tol);
  SphericalPolygonsSet plusY=new SphericalPolygonsSet(Vector3D.PLUS_J,tol);
  SphericalPolygonsSet plusZ=new SphericalPolygonsSet(Vector3D.PLUS_K,tol);
  SphericalPolygonsSet octant=(SphericalPolygonsSet)factory.intersection(factory.intersection(plusX,plusY),plusZ);
  UnitSphereRandomVectorGenerator random=new UnitSphereRandomVectorGenerator(3,new Well1024a(0x9c9802fde3cbcf25l));
  for (int i=0; i < 1000; ++i) {
    Vector3D v=new Vector3D(random.nextVector());
    if ((v.getX() > sinTol) && (v.getY() > sinTol) && (v.getZ() > sinTol)) {
      Assert.assertEquals(Location.INSIDE,octant.checkPoint(new S2Point(v)));
    }
 else     if ((v.getX() < -sinTol) || (v.getY() < -sinTol) || (v.getZ() < -sinTol)) {
      Assert.assertEquals(Location.OUTSIDE,octant.checkPoint(new S2Point(v)));
    }
 else {
      Assert.assertEquals(Location.BOUNDARY,octant.checkPoint(new S2Point(v)));
    }
  }
  List<Vertex> loops=octant.getBoundaryLoops();
  Assert.assertEquals(1,loops.size());
  boolean xPFound=false;
  boolean yPFound=false;
  boolean zPFound=false;
  boolean xVFound=false;
  boolean yVFound=false;
  boolean zVFound=false;
  Vertex first=loops.get(0);
  int count=0;
  for (Vertex v=first; count == 0 || v != first; v=v.getOutgoing().getEnd()) {
    ++count;
    Edge e=v.getIncoming();
    Assert.assertTrue(v == e.getStart().getOutgoing().getEnd());
    xPFound=xPFound || e.getCircle().getPole().distance(Vector3D.PLUS_I) < 1.0e-10;
    yPFound=yPFound || e.getCircle().getPole().distance(Vector3D.PLUS_J) < 1.0e-10;
    zPFound=zPFound || e.getCircle().getPole().distance(Vector3D.PLUS_K) < 1.0e-10;
    Assert.assertEquals(0.5 * FastMath.PI,e.getLength(),1.0e-10);
    xVFound=xVFound || v.getLocation().getVector().distance(Vector3D.PLUS_I) < 1.0e-10;
    yVFound=yVFound || v.getLocation().getVector().distance(Vector3D.PLUS_J) < 1.0e-10;
    zVFound=zVFound || v.getLocation().getVector().distance(Vector3D.PLUS_K) < 1.0e-10;
  }
  Assert.assertTrue(xPFound);
  Assert.assertTrue(yPFound);
  Assert.assertTrue(zPFound);
  Assert.assertTrue(xVFound);
  Assert.assertTrue(yVFound);
  Assert.assertTrue(zVFound);
  Assert.assertEquals(3,count);
  Assert.assertEquals(0.0,((S2Point)octant.getBarycenter()).distance(new S2Point(new Vector3D(1,1,1))),1.0e-10);
  Assert.assertEquals(0.5 * FastMath.PI,octant.getSize(),1.0e-10);
  EnclosingBall<Sphere2D,S2Point> cap=octant.getEnclosingCap();
  Assert.assertEquals(0.0,octant.getBarycenter().distance(cap.getCenter()),1.0e-10);
  Assert.assertEquals(FastMath.acos(1.0 / FastMath.sqrt(3)),cap.getRadius(),1.0e-10);
  EnclosingBall<Sphere2D,S2Point> reversedCap=((SphericalPolygonsSet)factory.getComplement(octant)).getEnclosingCap();
  Assert.assertEquals(0,reversedCap.getCenter().distance(new S2Point(new Vector3D(-1,-1,-1))),1.0e-10);
  Assert.assertEquals(FastMath.PI - FastMath.asin(1.0 / FastMath.sqrt(3)),reversedCap.getRadius(),1.0e-10);
}
