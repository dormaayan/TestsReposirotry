@Test public void testSeveralParts(){
  double tol=0.01;
  double sinTol=FastMath.sin(tol);
  List<SubHyperplane<Sphere2D>> boundary=new ArrayList<SubHyperplane<Sphere2D>>();
  boundary.add(create(Vector3D.PLUS_J,Vector3D.PLUS_K,Vector3D.PLUS_I,tol,0.0,0.5 * FastMath.PI));
  boundary.add(create(Vector3D.PLUS_K,Vector3D.PLUS_I,Vector3D.PLUS_J,tol,0.0,0.5 * FastMath.PI));
  boundary.add(create(Vector3D.PLUS_I,Vector3D.PLUS_J,Vector3D.PLUS_K,tol,0.0,0.5 * FastMath.PI));
  boundary.add(create(Vector3D.MINUS_J,Vector3D.MINUS_I,Vector3D.MINUS_K,tol,0.0,0.5 * FastMath.PI));
  boundary.add(create(Vector3D.MINUS_I,Vector3D.MINUS_K,Vector3D.MINUS_J,tol,0.0,0.5 * FastMath.PI));
  boundary.add(create(Vector3D.MINUS_K,Vector3D.MINUS_J,Vector3D.MINUS_I,tol,0.0,0.5 * FastMath.PI));
  SphericalPolygonsSet polygon=new SphericalPolygonsSet(boundary,tol);
  UnitSphereRandomVectorGenerator random=new UnitSphereRandomVectorGenerator(3,new Well1024a(0xcc5ce49949e0d3ecl));
  for (int i=0; i < 1000; ++i) {
    Vector3D v=new Vector3D(random.nextVector());
    if ((v.getX() < -sinTol) && (v.getY() < -sinTol) && (v.getZ() < -sinTol)) {
      Assert.assertEquals(Location.INSIDE,polygon.checkPoint(new S2Point(v)));
    }
 else     if ((v.getX() < sinTol) && (v.getY() < sinTol) && (v.getZ() < sinTol)) {
      Assert.assertEquals(Location.BOUNDARY,polygon.checkPoint(new S2Point(v)));
    }
 else     if ((v.getX() > sinTol) && (v.getY() > sinTol) && (v.getZ() > sinTol)) {
      Assert.assertEquals(Location.INSIDE,polygon.checkPoint(new S2Point(v)));
    }
 else     if ((v.getX() > -sinTol) && (v.getY() > -sinTol) && (v.getZ() > -sinTol)) {
      Assert.assertEquals(Location.BOUNDARY,polygon.checkPoint(new S2Point(v)));
    }
 else {
      Assert.assertEquals(Location.OUTSIDE,polygon.checkPoint(new S2Point(v)));
    }
  }
  Assert.assertEquals(FastMath.PI,polygon.getSize(),1.0e-10);
  Assert.assertEquals(3 * FastMath.PI,polygon.getBoundarySize(),1.0e-10);
  Assert.assertEquals(2,polygon.getBoundaryLoops().size());
}
