/** 
 * Visiting a valid subvector. 
 */
@Test public void testWalkInOptimizedOrderPreservingVisitor3(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final int expectedStart=2;
  final int expectedEnd=7;
  final FieldVectorPreservingVisitor<Fraction> visitor;
  visitor=new FieldVectorPreservingVisitor<Fraction>(){
    private final boolean[] visited=new boolean[data.length];
    public void visit(    final int actualIndex,    final Fraction actualValue){
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      visited[actualIndex]=true;
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(expectedStart,actualStart);
      Assert.assertEquals(expectedEnd,actualEnd);
      Arrays.fill(visited,true);
    }
    public Fraction end(){
      for (int i=expectedStart; i <= expectedEnd; i++) {
        Assert.assertTrue("entry " + i + "has not been visited",visited[i]);
      }
      return Fraction.ZERO;
    }
  }
;
  v.walkInOptimizedOrder(visitor,expectedStart,expectedEnd);
}
