@Test(timeout=20000L) public void testPowAllSpecialCases(){
  final double EXACT=-1.0;
  final double DOUBLES[]=new double[]{Double.NEGATIVE_INFINITY,-0.0,Double.NaN,0.0,Double.POSITIVE_INFINITY,Long.MIN_VALUE,Integer.MIN_VALUE,Short.MIN_VALUE,Byte.MIN_VALUE,-(double)Long.MIN_VALUE,-(double)Integer.MIN_VALUE,-(double)Short.MIN_VALUE,-(double)Byte.MIN_VALUE,Byte.MAX_VALUE,Short.MAX_VALUE,Integer.MAX_VALUE,Long.MAX_VALUE,-Byte.MAX_VALUE,-Short.MAX_VALUE,-Integer.MAX_VALUE,-Long.MAX_VALUE,Float.MAX_VALUE,Double.MAX_VALUE,Double.MIN_VALUE,Float.MIN_VALUE,-Float.MAX_VALUE,-Double.MAX_VALUE,-Double.MIN_VALUE,-Float.MIN_VALUE,0.5,0.1,0.2,0.8,1.1,1.2,1.5,1.8,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,1.3,2.2,2.5,2.8,33.0,33.1,33.5,33.8,10.0,300.0,400.0,500.0,-0.5,-0.1,-0.2,-0.8,-1.1,-1.2,-1.5,-1.8,-1.0,-2.0,-3.0,-4.0,-5.0,-6.0,-7.0,-8.0,-9.0,-1.3,-2.2,-2.5,-2.8,-33.0,-33.1,-33.5,-33.8,-10.0,-300.0,-400.0,-500.0};
  for (  double d : DOUBLES) {
    Assert.assertEquals(1.0,FastMath.pow(d,0.0),EXACT);
  }
  for (  double d : DOUBLES) {
    Assert.assertEquals(1.0,FastMath.pow(d,-0.0),EXACT);
  }
  for (  double d : DOUBLES) {
    Assert.assertEquals(d,FastMath.pow(d,1.0),EXACT);
  }
  for (  double d : DOUBLES) {
    Assert.assertEquals(Double.NaN,FastMath.pow(d,Double.NaN),EXACT);
  }
  for (  double i : DOUBLES) {
    if (i != 0.0) {
      Assert.assertEquals(Double.NaN,FastMath.pow(Double.NaN,i),EXACT);
    }
  }
  for (  double d : DOUBLES) {
    if (Math.abs(d) > 1.0) {
      Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.pow(d,Double.POSITIVE_INFINITY),EXACT);
    }
  }
  for (  double d : DOUBLES) {
    if (Math.abs(d) < 1.0) {
      Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.pow(d,Double.NEGATIVE_INFINITY),EXACT);
    }
  }
  for (  double d : DOUBLES) {
    if (Math.abs(d) > 1.0) {
      Assert.assertEquals(0.0,FastMath.pow(d,Double.NEGATIVE_INFINITY),EXACT);
    }
  }
  for (  double d : DOUBLES) {
    if (Math.abs(d) < 1.0) {
      Assert.assertEquals(0.0,FastMath.pow(d,Double.POSITIVE_INFINITY),EXACT);
    }
  }
  Assert.assertEquals(Double.NaN,FastMath.pow(1.0,Double.POSITIVE_INFINITY),EXACT);
  Assert.assertEquals(Double.NaN,FastMath.pow(1.0,Double.NEGATIVE_INFINITY),EXACT);
  Assert.assertEquals(Double.NaN,FastMath.pow(-1.0,Double.POSITIVE_INFINITY),EXACT);
  Assert.assertEquals(Double.NaN,FastMath.pow(-1.0,Double.NEGATIVE_INFINITY),EXACT);
  for (  double i : DOUBLES) {
    if (i > 0.0) {
      Assert.assertEquals(0.0,FastMath.pow(0.0,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i < 0.0) {
      Assert.assertEquals(0.0,FastMath.pow(Double.POSITIVE_INFINITY,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i < 0.0) {
      Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.pow(0.0,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i > 0.0) {
      Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.pow(Double.POSITIVE_INFINITY,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i > 0.0 && (Double.isInfinite(i) || i % 2.0 == 0.0)) {
      Assert.assertEquals(0.0,FastMath.pow(-0.0,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i < 0.0 && (Double.isInfinite(i) || i % 2.0 == 0.0)) {
      Assert.assertEquals(0.0,FastMath.pow(Double.NEGATIVE_INFINITY,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i > 0.0 && i % 2.0 == 1.0) {
      Assert.assertEquals(-0.0,FastMath.pow(-0.0,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i < 0.0 && i % 2.0 == -1.0) {
      Assert.assertEquals(-0.0,FastMath.pow(Double.NEGATIVE_INFINITY,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i > 0.0 && (Double.isInfinite(i) || i % 2.0 == 0.0)) {
      Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.pow(Double.NEGATIVE_INFINITY,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i < 0.0 && (Double.isInfinite(i) || i % 2.0 == 0.0)) {
      Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.pow(-0.0,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i > 0.0 && i % 2.0 == 1.0) {
      Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.pow(Double.NEGATIVE_INFINITY,i),EXACT);
    }
  }
  for (  double i : DOUBLES) {
    if (i < 0.0 && i % 2.0 == -1.0) {
      Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.pow(-0.0,i),EXACT);
    }
  }
  for (  double d : DOUBLES) {
    if (d < 0.0 && Math.abs(d) <= Double.MAX_VALUE) {
      for (      double i : DOUBLES) {
        if (Math.abs(i) <= Double.MAX_VALUE) {
          if (i % 2.0 == 0.0)           Assert.assertEquals(FastMath.pow(-d,i),FastMath.pow(d,i),EXACT);
 else           if (Math.abs(i) % 2.0 == 1.0)           Assert.assertEquals(-FastMath.pow(-d,i),FastMath.pow(d,i),EXACT);
 else           Assert.assertEquals(Double.NaN,FastMath.pow(d,i),EXACT);
        }
      }
    }
  }
  final int TOO_BIG_TO_CALCULATE=18;
  for (  double d : DOUBLES) {
    if (d % 1.0 == 0.0) {
      boolean dNegative=Double.doubleToRawLongBits(d) < 0L;
      for (      double i : DOUBLES) {
        if (i % 1.0 == 0.0) {
          BigInteger bd=BigDecimal.valueOf(d).toBigInteger().abs();
          BigInteger bi=BigDecimal.valueOf(i).toBigInteger().abs();
          double expected;
          if (bd.bitLength() > 1 && bi.bitLength() > 1 && 32 - Integer.numberOfLeadingZeros(bd.bitLength()) + bi.bitLength() > TOO_BIG_TO_CALCULATE) {
            expected=i < 0.0 ? 0.0 : Double.POSITIVE_INFINITY;
          }
 else {
            BigInteger res=ArithmeticUtils.pow(bd,bi);
            if (i >= 0.0) {
              expected=res.doubleValue();
            }
 else             if (res.signum() == 0) {
              expected=Double.POSITIVE_INFINITY;
            }
 else {
              expected=BigDecimal.ONE.divide(new BigDecimal(res),1024,RoundingMode.HALF_UP).doubleValue();
            }
          }
          if (dNegative && bi.testBit(0)) {
            expected=-expected;
          }
          Assert.assertEquals(d + "^" + i+ "="+ expected+ ", Math.pow="+ Math.pow(d,i),expected,FastMath.pow(d,i),expected == 0.0 || Double.isInfinite(expected) || Double.isNaN(expected) ? EXACT : 2.0 * Math.ulp(expected));
        }
      }
    }
  }
}
