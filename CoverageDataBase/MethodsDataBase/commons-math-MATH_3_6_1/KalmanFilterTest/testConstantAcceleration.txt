@Test public void testConstantAcceleration(){
  double dt=0.1d;
  double measurementNoise=10d;
  double accelNoise=0.2d;
  RealMatrix A=new Array2DRowRealMatrix(new double[][]{{1,dt},{0,1}});
  RealMatrix B=new Array2DRowRealMatrix(new double[][]{{FastMath.pow(dt,2d) / 2d},{dt}});
  RealMatrix H=new Array2DRowRealMatrix(new double[][]{{1d,0d}});
  RealVector x=new ArrayRealVector(new double[]{0,0});
  RealMatrix tmp=new Array2DRowRealMatrix(new double[][]{{FastMath.pow(dt,4d) / 4d,FastMath.pow(dt,3d) / 2d},{FastMath.pow(dt,3d) / 2d,FastMath.pow(dt,2d)}});
  RealMatrix Q=tmp.scalarMultiply(FastMath.pow(accelNoise,2));
  RealMatrix P0=new Array2DRowRealMatrix(new double[][]{{1,1},{1,1}});
  RealMatrix R=new Array2DRowRealMatrix(new double[]{FastMath.pow(measurementNoise,2)});
  RealVector u=new ArrayRealVector(new double[]{0.1d});
  ProcessModel pm=new DefaultProcessModel(A,B,Q,x,P0);
  MeasurementModel mm=new DefaultMeasurementModel(H,R);
  KalmanFilter filter=new KalmanFilter(pm,mm);
  Assert.assertEquals(1,filter.getMeasurementDimension());
  Assert.assertEquals(2,filter.getStateDimension());
  assertMatrixEquals(P0.getData(),filter.getErrorCovariance());
  double[] expectedInitialState=new double[]{0.0,0.0};
  assertVectorEquals(expectedInitialState,filter.getStateEstimation());
  RandomGenerator rand=new JDKRandomGenerator();
  RealVector tmpPNoise=new ArrayRealVector(new double[]{FastMath.pow(dt,2d) / 2d,dt});
  for (int i=0; i < 60; i++) {
    filter.predict(u);
    RealVector pNoise=tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian());
    x=A.operate(x).add(B.operate(u)).add(pNoise);
    double mNoise=measurementNoise * rand.nextGaussian();
    RealVector z=H.operate(x).mapAdd(mNoise);
    filter.correct(z);
    double diff=FastMath.abs(x.getEntry(0) - filter.getStateEstimation()[0]);
    Assert.assertTrue(Precision.compareTo(diff,measurementNoise,1e-6) < 0);
  }
  Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[1][1],0.1d,1e-6) < 0);
}
