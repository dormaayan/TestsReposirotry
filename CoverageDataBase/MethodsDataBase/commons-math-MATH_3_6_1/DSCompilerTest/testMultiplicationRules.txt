@Test public void testMultiplicationRules() throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
  Map<String,String> referenceRules=new HashMap<String,String>();
  referenceRules.put("(f*g)","f * g");
  referenceRules.put("d(f*g)/dx","f * dg/dx + df/dx * g");
  referenceRules.put("d(f*g)/dy",referenceRules.get("d(f*g)/dx").replaceAll("x","y"));
  referenceRules.put("d(f*g)/dz",referenceRules.get("d(f*g)/dx").replaceAll("x","z"));
  referenceRules.put("d(f*g)/dt",referenceRules.get("d(f*g)/dx").replaceAll("x","t"));
  referenceRules.put("d2(f*g)/dx2","f * d2g/dx2 + 2 * df/dx * dg/dx + d2f/dx2 * g");
  referenceRules.put("d2(f*g)/dy2",referenceRules.get("d2(f*g)/dx2").replaceAll("x","y"));
  referenceRules.put("d2(f*g)/dz2",referenceRules.get("d2(f*g)/dx2").replaceAll("x","z"));
  referenceRules.put("d2(f*g)/dt2",referenceRules.get("d2(f*g)/dx2").replaceAll("x","t"));
  referenceRules.put("d2(f*g)/dxdy","f * d2g/dxdy + df/dy * dg/dx + df/dx * dg/dy + d2f/dxdy * g");
  referenceRules.put("d2(f*g)/dxdz",referenceRules.get("d2(f*g)/dxdy").replaceAll("y","z"));
  referenceRules.put("d2(f*g)/dxdt",referenceRules.get("d2(f*g)/dxdy").replaceAll("y","t"));
  referenceRules.put("d2(f*g)/dydz",referenceRules.get("d2(f*g)/dxdz").replaceAll("x","y"));
  referenceRules.put("d2(f*g)/dydt",referenceRules.get("d2(f*g)/dxdt").replaceAll("x","y"));
  referenceRules.put("d2(f*g)/dzdt",referenceRules.get("d2(f*g)/dxdt").replaceAll("x","z"));
  referenceRules.put("d3(f*g)/dx3","f * d3g/dx3 +" + " 3 * df/dx * d2g/dx2 +" + " 3 * d2f/dx2 * dg/dx +"+ " d3f/dx3 * g");
  referenceRules.put("d3(f*g)/dy3",referenceRules.get("d3(f*g)/dx3").replaceAll("x","y"));
  referenceRules.put("d3(f*g)/dz3",referenceRules.get("d3(f*g)/dx3").replaceAll("x","z"));
  referenceRules.put("d3(f*g)/dt3",referenceRules.get("d3(f*g)/dx3").replaceAll("x","t"));
  referenceRules.put("d3(f*g)/dx2dy","f * d3g/dx2dy +" + " df/dy * d2g/dx2 +" + " 2 * df/dx * d2g/dxdy +"+ " 2 * d2f/dxdy * dg/dx +"+ " d2f/dx2 * dg/dy +"+ " d3f/dx2dy * g");
  referenceRules.put("d3(f*g)/dxdy2","f * d3g/dxdy2 +" + " 2 * df/dy * d2g/dxdy +" + " d2f/dy2 * dg/dx +"+ " df/dx * d2g/dy2 +"+ " 2 * d2f/dxdy * dg/dy +"+ " d3f/dxdy2 * g");
  referenceRules.put("d3(f*g)/dx2dz",referenceRules.get("d3(f*g)/dx2dy").replaceAll("y","z"));
  referenceRules.put("d3(f*g)/dy2dz",referenceRules.get("d3(f*g)/dx2dz").replaceAll("x","y"));
  referenceRules.put("d3(f*g)/dxdz2",referenceRules.get("d3(f*g)/dxdy2").replaceAll("y","z"));
  referenceRules.put("d3(f*g)/dydz2",referenceRules.get("d3(f*g)/dxdz2").replaceAll("x","y"));
  referenceRules.put("d3(f*g)/dx2dt",referenceRules.get("d3(f*g)/dx2dz").replaceAll("z","t"));
  referenceRules.put("d3(f*g)/dy2dt",referenceRules.get("d3(f*g)/dx2dt").replaceAll("x","y"));
  referenceRules.put("d3(f*g)/dz2dt",referenceRules.get("d3(f*g)/dx2dt").replaceAll("x","z"));
  referenceRules.put("d3(f*g)/dxdt2",referenceRules.get("d3(f*g)/dxdy2").replaceAll("y","t"));
  referenceRules.put("d3(f*g)/dydt2",referenceRules.get("d3(f*g)/dxdt2").replaceAll("x","y"));
  referenceRules.put("d3(f*g)/dzdt2",referenceRules.get("d3(f*g)/dxdt2").replaceAll("x","z"));
  referenceRules.put("d3(f*g)/dxdydz","f * d3g/dxdydz +" + " df/dz * d2g/dxdy +" + " df/dy * d2g/dxdz +"+ " d2f/dydz * dg/dx +"+ " df/dx * d2g/dydz +"+ " d2f/dxdz * dg/dy +"+ " d2f/dxdy * dg/dz +"+ " d3f/dxdydz * g");
  referenceRules.put("d3(f*g)/dxdydt",referenceRules.get("d3(f*g)/dxdydz").replaceAll("z","t"));
  referenceRules.put("d3(f*g)/dxdzdt",referenceRules.get("d3(f*g)/dxdydt").replaceAll("y","z"));
  referenceRules.put("d3(f*g)/dydzdt",referenceRules.get("d3(f*g)/dxdzdt").replaceAll("x","y"));
  Field multFieldArrayField=DSCompiler.class.getDeclaredField("multIndirection");
  multFieldArrayField.setAccessible(true);
  for (int i=0; i < 5; ++i) {
    for (int j=0; j < 4; ++j) {
      DSCompiler compiler=DSCompiler.getCompiler(i,j);
      int[][][] multIndirection=(int[][][])multFieldArrayField.get(compiler);
      for (int k=0; k < multIndirection.length; ++k) {
        String product=ordersToString(compiler.getPartialDerivativeOrders(k),"(f*g)","x","y","z","t");
        StringBuilder rule=new StringBuilder();
        for (        int[] term : multIndirection[k]) {
          if (rule.length() > 0) {
            rule.append(" + ");
          }
          if (term[0] > 1) {
            rule.append(term[0]).append(" * ");
          }
          rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[1]),"f","x","y","z","t"));
          rule.append(" * ");
          rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[2]),"g","x","y","z","t"));
        }
        Assert.assertEquals(product,referenceRules.get(product),rule.toString());
      }
    }
  }
}
