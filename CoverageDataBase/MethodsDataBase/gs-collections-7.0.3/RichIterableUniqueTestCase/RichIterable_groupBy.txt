@Override @Test default void RichIterable_groupBy(){
  RichIterable<Integer> iterable=this.newWith(4,3,2,1);
  Function<Integer,Boolean> groupByFunction=object -> IntegerPredicates.isOdd().accept(object);
  MutableMap<Boolean,RichIterable<Integer>> groupByExpected=UnifiedMap.newWithKeysValues(Boolean.TRUE,this.newMutableForFilter(3,1),Boolean.FALSE,this.newMutableForFilter(4,2));
  assertEquals(groupByExpected,iterable.groupBy(groupByFunction).toMap());
  Function<Integer,Boolean> function=(  Integer object) -> true;
  MutableMultimap<Boolean,Integer> multimap2=iterable.groupBy(groupByFunction,this.<Integer>newWith().groupBy(function).toMutable());
  assertEquals(groupByExpected,multimap2.toMap());
  Function<Integer,Iterable<Integer>> groupByEachFunction=integer -> Interval.fromTo(-1,-integer);
  MutableMap<Integer,RichIterable<Integer>> expectedGroupByEach=UnifiedMap.newWithKeysValues(-4,this.newMutableForFilter(4),-3,this.newMutableForFilter(4,3),-2,this.newMutableForFilter(4,3,2),-1,this.newMutableForFilter(4,3,2,1));
  assertEquals(expectedGroupByEach,iterable.groupByEach(groupByEachFunction).toMap());
  Multimap<Integer,Integer> actualWithTarget=iterable.groupByEach(groupByEachFunction,this.<Integer>newWith().groupByEach(groupByEachFunction).toMutable());
  assertEquals(expectedGroupByEach,actualWithTarget.toMap());
}
