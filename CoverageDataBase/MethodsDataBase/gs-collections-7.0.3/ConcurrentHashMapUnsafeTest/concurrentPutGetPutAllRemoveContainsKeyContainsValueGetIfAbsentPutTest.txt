@Test public void concurrentPutGetPutAllRemoveContainsKeyContainsValueGetIfAbsentPutTest(){
  ConcurrentHashMapUnsafe<Integer,Integer> map1=ConcurrentHashMapUnsafe.newMap();
  ConcurrentHashMapUnsafe<Integer,Integer> map2=ConcurrentHashMapUnsafe.newMap();
  ParallelIterate.forEach(Interval.oneTo(100),each -> {
    map1.put(each,each);
    Assert.assertEquals(each,map1.get(each));
    map2.putAll(Maps.mutable.of(each,each));
    map1.remove(each);
    map1.putAll(Maps.mutable.of(each,each));
    Assert.assertEquals(each,map2.get(each));
    map2.remove(each);
    Assert.assertNull(map2.get(each));
    Assert.assertFalse(map2.containsValue(each));
    Assert.assertFalse(map2.containsKey(each));
    Assert.assertEquals(each,map2.getIfAbsentPut(each,Functions.getIntegerPassThru()));
    Assert.assertTrue(map2.containsValue(each));
    Assert.assertTrue(map2.containsKey(each));
    Assert.assertEquals(each,map2.getIfAbsentPut(each,Functions.getIntegerPassThru()));
    map2.remove(each);
    Assert.assertEquals(each,map2.getIfAbsentPutWith(each,Functions.getIntegerPassThru(),each));
    Assert.assertEquals(each,map2.getIfAbsentPutWith(each,Functions.getIntegerPassThru(),each));
    Assert.assertEquals(each,map2.getIfAbsentPut(each,Functions.getIntegerPassThru()));
  }
,1,this.executor);
  Verify.assertEqualsAndHashCode(map1,map2);
}
