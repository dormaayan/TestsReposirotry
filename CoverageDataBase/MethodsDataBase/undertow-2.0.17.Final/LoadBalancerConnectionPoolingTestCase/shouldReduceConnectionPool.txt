@Test public void shouldReduceConnectionPool() throws Exception {
  ExecutorService executorService=Executors.newFixedThreadPool(10);
  PoolingClientConnectionManager conman=new PoolingClientConnectionManager();
  conman.setDefaultMaxPerRoute(20);
  final TestHttpClient client=new TestHttpClient(conman);
  int requests=20;
  final CountDownLatch latch=new CountDownLatch(requests);
  long ttlStartExpire=TTL + System.currentTimeMillis();
  try {
    for (int i=0; i < requests; ++i) {
      executorService.submit(new Runnable(){
        @Override public void run(){
          HttpGet get=new HttpGet("http://" + host + ":"+ (port + 1));
          try {
            HttpResponse response=client.execute(get);
            Assert.assertEquals(StatusCodes.OK,response.getStatusLine().getStatusCode());
            HttpClientUtils.readResponse(response);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
 finally {
            latch.countDown();
          }
        }
      }
);
    }
    if (!latch.await(2000,TimeUnit.MILLISECONDS)) {
      Assert.fail();
    }
  }
  finally {
    client.getConnectionManager().shutdown();
    executorService.shutdown();
  }
  if (activeConnections.size() != 1) {
    if (System.currentTimeMillis() < ttlStartExpire) {
      Assert.fail("there should still be a connection");
    }
  }
  long end=System.currentTimeMillis() + (TTL * 3);
  while (!activeConnections.isEmpty() && System.currentTimeMillis() < end) {
    Thread.sleep(100);
  }
  Assert.assertEquals(0,activeConnections.size());
}
