@Test public void testReadTimeout() throws IOException, InterruptedException {
  DefaultServer.setRootHandler(new HttpHandler(){
    @Override public void handleRequest(    final HttpServerExchange exchange) throws Exception {
      final StreamSinkChannel response=exchange.getResponseChannel();
      final StreamSourceChannel request=exchange.getRequestChannel();
      try {
        request.setOption(Options.READ_TIMEOUT,100);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
      request.getReadSetter().set(ChannelListeners.drainListener(Long.MAX_VALUE,new ChannelListener<Channel>(){
        @Override public void handleEvent(        final Channel channel){
          new StringWriteChannelListener("COMPLETED"){
            @Override protected void writeDone(            final StreamSinkChannel channel){
              exchange.endExchange();
            }
          }
.setup(response);
        }
      }
,new ChannelExceptionHandler<StreamSourceChannel>(){
        @Override public void handleException(        final StreamSourceChannel channel,        final IOException e){
          exchange.endExchange();
          exception=e;
          errorLatch.countDown();
        }
      }
));
      request.wakeupReads();
    }
  }
);
  final TestHttpClient client=new TestHttpClient();
  try {
    HttpPost post=new HttpPost(DefaultServer.getDefaultServerURL());
    post.setEntity(new AbstractHttpEntity(){
      @Override public InputStream getContent() throws IOException, IllegalStateException {
        return null;
      }
      @Override public void writeTo(      final OutputStream outstream) throws IOException {
        for (int i=0; i < 5; ++i) {
          outstream.write('*');
          outstream.flush();
          try {
            Thread.sleep(200);
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
      @Override public boolean isStreaming(){
        return true;
      }
      @Override public boolean isRepeatable(){
        return false;
      }
      @Override public long getContentLength(){
        return 5;
      }
    }
);
    post.addHeader(Headers.CONNECTION_STRING,"close");
    try {
      client.execute(post);
    }
 catch (    IOException e) {
    }
    if (errorLatch.await(5,TimeUnit.SECONDS)) {
      Assert.assertEquals(ReadTimeoutException.class,exception.getClass());
    }
 else {
      Assert.fail("Read did not time out");
    }
  }
  finally {
    client.getConnectionManager().shutdown();
  }
}
