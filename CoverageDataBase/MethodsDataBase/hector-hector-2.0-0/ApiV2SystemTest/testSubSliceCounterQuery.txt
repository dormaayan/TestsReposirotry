/** 
 * Tests the SubSliceQuery, a query on columns within a supercolumn
 */
@Test public void testSubSliceCounterQuery(){
  String cf="SuperCounter1";
  TestCleanupDescriptor cleanup=insertSuperCountColumns(cf,1,"testSliceCounterQueryOnSubcolumns",1,"testSliceCounterQueryOnSubcolumns_column");
  SubSliceCounterQuery<String,String,String> q=createSubSliceCounterQuery(ko,se,se,se);
  q.setColumnFamily(cf);
  q.setSuperColumn("testSliceCounterQueryOnSubcolumns_column0");
  q.setKey("testSliceCounterQueryOnSubcolumns0");
  q.setColumnNames("c000","c110","c_doesn't_exist");
  QueryResult<CounterSlice<String>> r=q.execute();
  assertNotNull(r);
  CounterSlice<String> slice=r.get();
  assertNotNull(slice);
  assertEquals(2,slice.getColumns().size());
  assertEquals(Long.valueOf(0),slice.getColumnByName("c000").getValue());
  q=createSubSliceCounterQuery(ko,se,se,se);
  q.setColumnFamily(cf);
  q.setKey("testSliceCounterQueryOnSubcolumns0");
  q.setSuperColumn("testSliceCounterQueryOnSubcolumns_column0");
  q.setRange("c000","c110",false,2);
  r=q.execute();
  assertNotNull(r);
  slice=r.get();
  assertNotNull(slice);
  for (  HCounterColumn<String> column : slice.getColumns()) {
    if (!column.getName().equals("c000") && !column.getName().equals("c110")) {
      fail("A columns with unexpected column name returned: " + column.getName());
    }
  }
  deleteColumns(cleanup);
  r=q.execute();
  assertNotNull(r);
  slice=r.get();
  assertNotNull(slice);
  assertTrue(slice.getColumns().isEmpty());
}
