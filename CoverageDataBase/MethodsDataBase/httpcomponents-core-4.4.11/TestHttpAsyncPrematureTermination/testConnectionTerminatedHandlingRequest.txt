@Test public void testConnectionTerminatedHandlingRequest() throws Exception {
  final CountDownLatch responseStreamClosed=new CountDownLatch(1);
  final InputStream testInputStream=new ByteArrayInputStream("all is well".getBytes(Consts.ASCII)){
    @Override public void close() throws IOException {
      responseStreamClosed.countDown();
      super.close();
    }
  }
;
  this.server.registerHandler("*",new HttpAsyncRequestHandler<HttpRequest>(){
    @Override public HttpAsyncRequestConsumer<HttpRequest> processRequest(    final HttpRequest request,    final HttpContext context) throws HttpException, IOException {
      return new BasicAsyncRequestConsumer();
    }
    @Override public void handle(    final HttpRequest request,    final HttpAsyncExchange httpExchange,    final HttpContext context) throws HttpException, IOException {
      final HttpConnection conn=(HttpConnection)context.getAttribute(HttpCoreContext.HTTP_CONNECTION);
      conn.shutdown();
      final HttpResponse response=httpExchange.getResponse();
      response.setEntity(new InputStreamEntity(testInputStream,-1));
      httpExchange.submitResponse();
    }
  }
);
  final InetSocketAddress address=start();
  final HttpHost target=new HttpHost("localhost",address.getPort());
  final CountDownLatch latch=new CountDownLatch(1);
  final FutureCallback<HttpResponse> callback=new FutureCallback<HttpResponse>(){
    @Override public void cancelled(){
      latch.countDown();
    }
    @Override public void failed(    final Exception ex){
      latch.countDown();
    }
    @Override public void completed(    final HttpResponse response){
      Assert.fail();
    }
  }
;
  final HttpRequest request=new BasicHttpRequest("GET","/");
  final HttpContext context=new BasicHttpContext();
  this.client.execute(target,request,context,callback);
  Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
  Assert.assertTrue(responseStreamClosed.await(5,TimeUnit.SECONDS));
}
