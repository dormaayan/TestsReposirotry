@Test public void testConnectionTerminatedSendingResponse() throws Exception {
  this.server.registerHandler("*",new HttpAsyncRequestHandler<HttpRequest>(){
    @Override public HttpAsyncRequestConsumer<HttpRequest> processRequest(    final HttpRequest request,    final HttpContext context) throws HttpException, IOException {
      return new BasicAsyncRequestConsumer();
    }
    @Override public void handle(    final HttpRequest request,    final HttpAsyncExchange httpExchange,    final HttpContext context) throws HttpException, IOException {
      final HttpResponse response=httpExchange.getResponse();
      response.setEntity(new NStringEntity("all is well",ContentType.TEXT_PLAIN));
      httpExchange.submitResponse(new BasicAsyncResponseProducer(response){
        @Override public synchronized void produceContent(        final ContentEncoder encoder,        final IOControl ioControl) throws IOException {
          ioControl.shutdown();
        }
      }
);
    }
  }
);
  final InetSocketAddress address=start();
  final HttpHost target=new HttpHost("localhost",address.getPort());
  final CountDownLatch latch=new CountDownLatch(1);
  final FutureCallback<HttpResponse> callback=new FutureCallback<HttpResponse>(){
    @Override public void cancelled(){
      latch.countDown();
    }
    @Override public void failed(    final Exception ex){
      latch.countDown();
    }
    @Override public void completed(    final HttpResponse response){
      Assert.fail();
    }
  }
;
  final HttpRequest request=new BasicHttpRequest("GET","/");
  final HttpContext context=new BasicHttpContext();
  this.client.execute(target,request,context,callback);
  Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
}
