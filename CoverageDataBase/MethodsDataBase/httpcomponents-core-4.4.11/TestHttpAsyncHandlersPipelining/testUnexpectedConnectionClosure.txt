@Test public void testUnexpectedConnectionClosure() throws Exception {
  this.server.registerHandler("*",new BasicAsyncRequestHandler(new HttpRequestHandler(){
    @Override public void handle(    final HttpRequest request,    final HttpResponse response,    final HttpContext context) throws HttpException, IOException {
      response.setStatusCode(HttpStatus.SC_OK);
      response.setEntity(new StringEntity("all is well",ContentType.TEXT_PLAIN));
    }
  }
));
  this.server.registerHandler("/boom",new BasicAsyncRequestHandler(new HttpRequestHandler(){
    @Override public void handle(    final HttpRequest request,    final HttpResponse response,    final HttpContext context) throws HttpException, IOException {
      response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);
      response.setHeader(HttpHeaders.CONNECTION,"Close");
      response.setEntity(new StringEntity("boooooom!!!!!",ContentType.TEXT_PLAIN));
    }
  }
));
  final HttpHost target=start();
  this.client.setMaxPerRoute(3);
  this.client.setMaxTotal(3);
  for (int i=0; i < 3; i++) {
    final HttpAsyncRequestProducer p1=new BasicAsyncRequestProducer(target,new BasicHttpRequest("GET","/"));
    final HttpAsyncRequestProducer p2=new BasicAsyncRequestProducer(target,new BasicHttpRequest("GET","/boom"));
    final HttpAsyncRequestProducer p3=new BasicAsyncRequestProducer(target,new BasicHttpRequest("GET","/"));
    final List<HttpAsyncRequestProducer> requestProducers=new ArrayList<HttpAsyncRequestProducer>();
    requestProducers.add(p1);
    requestProducers.add(p2);
    requestProducers.add(p3);
    final HttpAsyncResponseConsumer<HttpResponse> c1=new BasicAsyncResponseConsumer();
    final HttpAsyncResponseConsumer<HttpResponse> c2=new BasicAsyncResponseConsumer();
    final HttpAsyncResponseConsumer<HttpResponse> c3=new BasicAsyncResponseConsumer();
    final List<HttpAsyncResponseConsumer<HttpResponse>> responseConsumers=new ArrayList<HttpAsyncResponseConsumer<HttpResponse>>();
    responseConsumers.add(c1);
    responseConsumers.add(c2);
    responseConsumers.add(c3);
    final Future<List<HttpResponse>> future=this.client.executePipelined(target,requestProducers,responseConsumers,null,null);
    try {
      future.get(RESULT_TIMEOUT_SEC,TimeUnit.SECONDS);
    }
 catch (    final ExecutionException ex) {
      final Throwable cause=ex.getCause();
      Assert.assertTrue(cause instanceof ConnectionClosedException);
    }
    Assert.assertTrue(c1.isDone());
    Assert.assertNotNull(c1.getResult());
    Assert.assertTrue(c2.isDone());
    Assert.assertNotNull(c2.getResult());
    Assert.assertTrue(c3.isDone());
    Assert.assertNull(c3.getResult());
  }
}
