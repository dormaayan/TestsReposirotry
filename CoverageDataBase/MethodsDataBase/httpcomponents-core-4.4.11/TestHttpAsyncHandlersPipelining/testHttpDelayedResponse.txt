@Test public void testHttpDelayedResponse() throws Exception {
class DelayedRequestHandler implements HttpAsyncRequestHandler<HttpRequest> {
    private final SimpleRequestHandler requestHandler;
    public DelayedRequestHandler(){
      super();
      this.requestHandler=new SimpleRequestHandler();
    }
    @Override public HttpAsyncRequestConsumer<HttpRequest> processRequest(    final HttpRequest request,    final HttpContext context){
      return new BasicAsyncRequestConsumer();
    }
    @Override public void handle(    final HttpRequest request,    final HttpAsyncExchange httpexchange,    final HttpContext context) throws HttpException, IOException {
      final BasicHttpResponse response=new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_OK,"OK");
      new Thread(){
        @Override public void run(){
          try {
            Thread.sleep(100);
          }
 catch (          final InterruptedException ie) {
          }
          try {
            requestHandler.handle(request,response,context);
          }
 catch (          final Exception ex) {
            response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);
          }
          httpexchange.submitResponse(new BasicAsyncResponseProducer(response));
        }
      }
.start();
    }
  }
  this.server.registerHandler("*",new DelayedRequestHandler());
  final HttpHost target=start();
  this.client.setMaxPerRoute(3);
  this.client.setMaxTotal(3);
  final String pattern1=RndTestPatternGenerator.generateText();
  final String pattern2=RndTestPatternGenerator.generateText();
  final String pattern3=RndTestPatternGenerator.generateText();
  final int count=RndTestPatternGenerator.generateCount(1000);
  final String expectedPattern1=createExpectedString(pattern1,count);
  final String expectedPattern2=createExpectedString(pattern2,count);
  final String expectedPattern3=createExpectedString(pattern3,count);
  final Queue<Future<List<HttpResponse>>> queue=new ConcurrentLinkedQueue<Future<List<HttpResponse>>>();
  for (int i=0; i < 1; i++) {
    final HttpRequest request1=new BasicHttpRequest("GET",createRequestUri(pattern1,count));
    final HttpEntityEnclosingRequest request2=new BasicHttpEntityEnclosingRequest("POST",createRequestUri(pattern2,count));
    final NStringEntity entity2=new NStringEntity(expectedPattern2,ContentType.DEFAULT_TEXT);
    entity2.setChunked(RndTestPatternGenerator.generateBoolean());
    request2.setEntity(entity2);
    final HttpEntityEnclosingRequest request3=new BasicHttpEntityEnclosingRequest("POST",createRequestUri(pattern3,count));
    final NStringEntity entity3=new NStringEntity(expectedPattern3,ContentType.DEFAULT_TEXT);
    entity3.setChunked(RndTestPatternGenerator.generateBoolean());
    request3.setEntity(entity3);
    final Future<List<HttpResponse>> future=this.client.executePipelined(target,request1,request2,request3);
    queue.add(future);
  }
  while (!queue.isEmpty()) {
    final Future<List<HttpResponse>> future=queue.remove();
    final List<HttpResponse> responses=future.get(RESULT_TIMEOUT_SEC,TimeUnit.SECONDS);
    Assert.assertNotNull(responses);
    Assert.assertEquals(3,responses.size());
    for (    final HttpResponse response : responses) {
      Assert.assertEquals(HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
    }
    Assert.assertEquals(expectedPattern1,EntityUtils.toString(responses.get(0).getEntity()));
    Assert.assertEquals(expectedPattern2,EntityUtils.toString(responses.get(1).getEntity()));
    Assert.assertEquals(expectedPattern3,EntityUtils.toString(responses.get(2).getEntity()));
  }
}
