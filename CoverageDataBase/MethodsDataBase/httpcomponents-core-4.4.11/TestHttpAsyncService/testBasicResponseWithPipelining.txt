@Test public void testBasicResponseWithPipelining() throws Exception {
  final State state=new State();
  final HttpContext exchangeContext=new BasicHttpContext();
  final HttpRequest request=new BasicHttpRequest("GET","/",HttpVersion.HTTP_1_1);
  final Incoming incoming=new Incoming(request,this.requestHandler,this.requestConsumer,exchangeContext);
  state.setIncoming(incoming);
  state.setRequestState(MessageState.COMPLETED);
  final HttpResponse response=new BasicHttpResponse(HttpVersion.HTTP_1_1,200,"OK");
  final Outgoing outgoing=new Outgoing(request,response,this.responseProducer,exchangeContext);
  response.setEntity(new NStringEntity("stuff"));
  state.setOutgoing(outgoing);
  final Queue<PipelineEntry> pipeline=state.getPipeline();
  final HttpContext exchangeContext2=new BasicHttpContext();
  final HttpRequest pipelinedRequest=new BasicHttpRequest("GET","/",HttpVersion.HTTP_1_1);
  final PipelineEntry entry=new PipelineEntry(pipelinedRequest,pipelinedRequest,null,requestHandler,exchangeContext2);
  pipeline.add(entry);
  this.connContext.setAttribute(HttpAsyncService.HTTP_EXCHANGE_STATE,state);
  Mockito.when(this.responseProducer.generateResponse()).thenReturn(response);
  Mockito.when(this.reuseStrategy.keepAlive(response,exchangeContext)).thenReturn(Boolean.TRUE);
  this.protocolHandler.responseReady(this.conn);
  Assert.assertEquals(MessageState.BODY_STREAM,state.getResponseState());
  Mockito.verify(this.httpProcessor).process(response,exchangeContext);
  Mockito.verify(this.conn).suspendOutput();
  Mockito.verify(this.conn).submitResponse(response);
  Mockito.verify(this.conn,Mockito.never()).close();
}
