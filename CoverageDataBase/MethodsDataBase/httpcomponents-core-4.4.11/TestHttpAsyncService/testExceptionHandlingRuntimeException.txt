@Test public void testExceptionHandlingRuntimeException() throws Exception {
  final State state=new State();
  state.setRequestState(MessageState.READY);
  state.setResponseState(MessageState.READY);
  final HttpContext exchangeContext=new BasicHttpContext();
  final HttpRequest request=new BasicHttpRequest("GET","/",HttpVersion.HTTP_1_1);
  final Incoming incoming=new Incoming(request,this.requestHandler,this.requestConsumer,exchangeContext);
  state.setIncoming(incoming);
  final HttpResponse response=new BasicHttpResponse(HttpVersion.HTTP_1_1,200,"OK");
  final Outgoing outgoing=new Outgoing(request,response,this.responseProducer,exchangeContext);
  state.setOutgoing(outgoing);
  state.setCancellable(this.cancellable);
  this.connContext.setAttribute(HttpAsyncService.HTTP_EXCHANGE_STATE,state);
  Mockito.doThrow(new RuntimeException()).when(this.httpProcessor).process(Matchers.any(HttpResponse.class),Matchers.any(HttpContext.class));
  final HttpException httpex=new HttpException();
  try {
    this.protocolHandler.exception(this.conn,httpex);
    Assert.fail("RuntimeException expected");
  }
 catch (  final RuntimeException ex) {
    Mockito.verify(this.conn).shutdown();
    Mockito.verify(this.requestConsumer).failed(httpex);
    Mockito.verify(this.requestConsumer,Mockito.atLeastOnce()).close();
    Mockito.verify(this.responseProducer).failed(httpex);
    Mockito.verify(this.responseProducer,Mockito.atLeastOnce()).close();
    Mockito.verify(this.cancellable).cancel();
  }
}
