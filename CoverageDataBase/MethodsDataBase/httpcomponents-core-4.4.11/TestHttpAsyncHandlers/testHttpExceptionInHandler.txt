@Test public void testHttpExceptionInHandler() throws Exception {
class FailingRequestHandler implements HttpAsyncRequestHandler<HttpRequest> {
    public FailingRequestHandler(){
      super();
    }
    @Override public HttpAsyncRequestConsumer<HttpRequest> processRequest(    final HttpRequest request,    final HttpContext context){
      return new BasicAsyncRequestConsumer();
    }
    @Override public void handle(    final HttpRequest request,    final HttpAsyncExchange httpexchange,    final HttpContext context) throws HttpException, IOException {
      throw new HttpException("Boom");
    }
  }
  this.server.registerHandler("*",new FailingRequestHandler());
  final HttpHost target=start();
  this.client.setMaxPerRoute(3);
  this.client.setMaxTotal(3);
  final String pattern=RndTestPatternGenerator.generateText();
  final int count=RndTestPatternGenerator.generateCount(1000);
  final Queue<Future<HttpResponse>> queue=new ConcurrentLinkedQueue<Future<HttpResponse>>();
  for (int i=0; i < 1; i++) {
    final BasicHttpRequest request=new BasicHttpRequest("GET",createRequestUri(pattern,count));
    final Future<HttpResponse> future=this.client.execute(target,request);
    queue.add(future);
  }
  while (!queue.isEmpty()) {
    final Future<HttpResponse> future=queue.remove();
    final HttpResponse response=future.get(RESULT_TIMEOUT_SEC,TimeUnit.SECONDS);
    Assert.assertNotNull(response);
    Assert.assertEquals(HttpStatus.SC_INTERNAL_SERVER_ERROR,response.getStatusLine().getStatusCode());
  }
}
