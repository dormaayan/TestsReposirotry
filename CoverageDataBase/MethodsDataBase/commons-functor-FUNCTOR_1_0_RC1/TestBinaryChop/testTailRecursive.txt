/** 
 * We can use the Algorithms.recuse method to implement that as tail recursion. Here the anonymous Function implemenation holds this itermediate state, rather than the VM's call stack. Arguably this is more like a continuation than tail recursion, since there is a bit of state to be tracked.
 */
@Test public void testTailRecursive(){
  chopTest(new BaseBinaryChop(){
    public int find(    final Object seeking,    final List list){
      return ((Number)new RecursiveEvaluation(new Function(){
        public Object evaluate(){
          if (high - low > 1) {
            int mid=(high + low) / 2;
            if (greaterThan(list,mid,seeking)) {
              high=mid;
            }
 else {
              low=mid;
            }
            return this;
          }
 else {
            return list.isEmpty() ? BaseBinaryChop.NEGATIVE_ONE : (BaseBinaryChop.equals(list,low,seeking) ? new Integer(low) : BaseBinaryChop.NEGATIVE_ONE);
          }
        }
        int high=list.size();
        int low=0;
      }
).evaluate()).intValue();
    }
  }
);
}
