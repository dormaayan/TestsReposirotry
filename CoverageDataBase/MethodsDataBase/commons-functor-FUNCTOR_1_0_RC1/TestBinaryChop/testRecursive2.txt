/** 
 * One fun functional approach is to "slice" up the list as we search,  looking at smaller and smaller slices until we've found the element we're looking for. Note that while any given call to this recursive function may only be looking at a sublist, we need to return the index in the overall list. Hence we'll split out a method so that we can pass the offset in the original list as a parameter. With all of the subList creation, this approach is probably less efficient than either the iterative or the recursive implemenations above.
 */
@Test public void testRecursive2(){
  chopTest(new BaseBinaryChop(){
    public int find(    Object seeking,    List list){
      return find(seeking,list,0);
    }
    private int find(    Object seeking,    List list,    int offset){
      if (list.isEmpty()) {
        return -1;
      }
      if (list.size() == 1) {
        return (equals(list,0,seeking) ? offset : -1);
      }
 else {
        int mid=list.size() / 2;
        if (greaterThan(list,mid,seeking)) {
          return find(seeking,list.subList(0,mid),offset);
        }
 else {
          return find(seeking,list.subList(mid,list.size()),offset + mid);
        }
      }
    }
  }
);
}
