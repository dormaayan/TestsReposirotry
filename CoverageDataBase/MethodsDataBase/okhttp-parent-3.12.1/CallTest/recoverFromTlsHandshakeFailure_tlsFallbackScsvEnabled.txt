@Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
  final String tlsFallbackScsv="TLS_FALLBACK_SCSV";
  List<String> supportedCiphers=Arrays.asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
  if (!supportedCiphers.contains(tlsFallbackScsv)) {
    return;
  }
  server.useHttps(handshakeCertificates.sslSocketFactory(),false);
  server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
  RecordingSSLSocketFactory clientSocketFactory=new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
  client=client.newBuilder().sslSocketFactory(clientSocketFactory,handshakeCertificates.trustManager()).connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS,ConnectionSpec.MODERN_TLS)).hostnameVerifier(new RecordingHostnameVerifier()).build();
  Request request=new Request.Builder().url(server.url("/")).build();
  try {
    client.newCall(request).execute();
    fail();
  }
 catch (  SSLHandshakeException expected) {
  }
  List<SSLSocket> clientSockets=clientSocketFactory.getSocketsCreated();
  SSLSocket firstSocket=clientSockets.get(0);
  assertFalse(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
  SSLSocket secondSocket=clientSockets.get(1);
  assertTrue(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
}
