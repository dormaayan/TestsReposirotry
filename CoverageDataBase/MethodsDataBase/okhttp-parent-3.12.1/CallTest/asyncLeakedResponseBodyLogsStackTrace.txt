@Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {
  server.enqueue(new MockResponse().setBody("This gets leaked."));
  client=defaultClient().newBuilder().connectionPool(new ConnectionPool(0,10,TimeUnit.MILLISECONDS)).build();
  Request request=new Request.Builder().url(server.url("/")).build();
  Level original=logger.getLevel();
  logger.setLevel(Level.FINE);
  logHandler.setFormatter(new SimpleFormatter());
  try {
    final CountDownLatch latch=new CountDownLatch(1);
    client.newCall(request).enqueue(new Callback(){
      @Override public void onFailure(      Call call,      IOException e){
        fail();
      }
      @Override public void onResponse(      Call call,      Response response) throws IOException {
        latch.countDown();
      }
    }
);
    latch.await();
    Thread.sleep(200);
    awaitGarbageCollection();
    String message=logHandler.take();
    assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."+ " Did you forget to close a response body?"));
    assertTrue(message.contains("okhttp3.RealCall.enqueue("));
    assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
  }
  finally {
    logger.setLevel(original);
  }
}
