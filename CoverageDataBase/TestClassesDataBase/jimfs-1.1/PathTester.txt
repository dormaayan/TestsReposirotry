/** 
 * @author Colin Decker
 */
public final class PathTester {
  private final PathService pathService;
  private final String string;
  private String root;
  private ImmutableList<String> names=ImmutableList.of();
  public PathTester(  PathService pathService,  String string){
    this.pathService=pathService;
    this.string=string;
  }
  public PathTester root(  String root){
    this.root=root;
    return this;
  }
  public PathTester names(  Iterable<String> names){
    this.names=ImmutableList.copyOf(names);
    return this;
  }
  public PathTester names(  String... names){
    return names(Arrays.asList(names));
  }
  public void test(  String first,  String... more){
    Path path=pathService.parsePath(first,more);
    test(path);
  }
  public void test(  Path path){
    assertEquals(string,path.toString());
    testRoot(path);
    testNames(path);
    testParents(path);
    testStartsWith(path);
    testEndsWith(path);
    testSubpaths(path);
  }
  private void testRoot(  Path path){
    if (root != null) {
      assertTrue(path + ".isAbsolute() should be true",path.isAbsolute());
      assertNotNull(path + ".getRoot() should not be null",path.getRoot());
      assertEquals(root,path.getRoot().toString());
    }
 else {
      assertFalse(path + ".isAbsolute() should be false",path.isAbsolute());
      assertNull(path + ".getRoot() should be null",path.getRoot());
    }
  }
  private void testNames(  Path path){
    assertEquals(names.size(),path.getNameCount());
    assertEquals(names,names(path));
    for (int i=0; i < names.size(); i++) {
      assertEquals(names.get(i),path.getName(i).toString());
      if (names.size() > 1) {
        new PathTester(pathService,names.get(i)).names(names.get(i)).test(path.getName(i));
      }
    }
    if (names.size() > 0) {
      String fileName=names.get(names.size() - 1);
      assertEquals(fileName,path.getFileName().toString());
      if (names.size() > 1) {
        new PathTester(pathService,fileName).names(fileName).test(path.getFileName());
      }
    }
  }
  private void testParents(  Path path){
    Path parent=path.getParent();
    if (root != null && names.size() >= 1 || names.size() > 1) {
      assertNotNull(parent);
    }
    if (parent != null) {
      String parentName=names.size() == 1 ? root : string.substring(0,string.lastIndexOf('/'));
      new PathTester(pathService,parentName).root(root).names(names.subList(0,names.size() - 1)).test(parent);
    }
  }
  private void testSubpaths(  Path path){
    if (path.getRoot() == null) {
      assertEquals(path,path.subpath(0,path.getNameCount()));
    }
    if (path.getNameCount() > 1) {
      String stringWithoutRoot=root == null ? string : string.substring(root.length());
      Path startSubpath=path.subpath(1,path.getNameCount());
      List<String> startNames=ImmutableList.copyOf(Splitter.on('/').split(stringWithoutRoot)).subList(1,path.getNameCount());
      new PathTester(pathService,Joiner.on('/').join(startNames)).names(startNames).test(startSubpath);
      Path endSubpath=path.subpath(0,path.getNameCount() - 1);
      List<String> endNames=ImmutableList.copyOf(Splitter.on('/').split(stringWithoutRoot)).subList(0,path.getNameCount() - 1);
      new PathTester(pathService,Joiner.on('/').join(endNames)).names(endNames).test(endSubpath);
    }
  }
  private void testStartsWith(  Path path){
    if (root != null || !names.isEmpty()) {
      Path other=path;
      while (other != null) {
        assertTrue(path + ".startsWith(" + other+ ") should be true",path.startsWith(other));
        assertTrue(path + ".startsWith(" + other+ ") should be true",path.startsWith(other.toString()));
        other=other.getParent();
      }
    }
  }
  private void testEndsWith(  Path path){
    if (root != null || !names.isEmpty()) {
      Path other=path;
      while (other != null) {
        assertTrue(path + ".endsWith(" + other+ ") should be true",path.endsWith(other));
        assertTrue(path + ".endsWith(" + other+ ") should be true",path.endsWith(other.toString()));
        if (other.getRoot() != null && other.getNameCount() > 0) {
          other=other.subpath(0,other.getNameCount());
        }
 else         if (other.getNameCount() > 1) {
          other=other.subpath(1,other.getNameCount());
        }
 else {
          other=null;
        }
      }
    }
  }
  private static List<String> names(  Path path){
    return FluentIterable.from(path).transform(toStringFunction()).toList();
  }
}
