@RunWith(Parameterized.class) public class TypeToXmlSchemaTest extends TestDataProvider {
  public TypeToXmlSchemaTest(  File input,  File expectedOutput,  String name){
    super(input,expectedOutput,name);
  }
  @Parameterized.Parameters(name="{2}") public static Collection<Object[]> getData() throws URISyntaxException {
    return getData(TypeToXmlSchemaTest.class.getResource("").toURI(),"input.raml","output.xsd");
  }
  @Test public void test() throws IOException, SAXException {
    final RamlBuilder builder=new RamlBuilder();
    final Node build=builder.build(input);
    final List<TypeDeclarationField> fields=build.findDescendantsWith(TypeDeclarationField.class);
    for (    TypeDeclarationField field : fields) {
      if (field.getName().equals("root")) {
        final ResolvedType resolvedType=((TypeDeclarationNode)field.getValue()).getResolvedType();
        expected=IOUtils.toString(new FileInputStream(expectedOutput));
        validateEquals(resolvedType,expected,"root");
        return;
      }
    }
    fail("No type called root was found");
  }
  protected void validateEquals(  ResolvedType objectTypeFacets,  String expected,  String name) throws SAXException, IOException {
    final TypeToXmlSchemaVisitor typeToXmlSchemaVisitor=new TypeToXmlSchemaVisitor();
    typeToXmlSchemaVisitor.transform(name,objectTypeFacets);
    final XmlSchema user=typeToXmlSchemaVisitor.getSchema();
    final StringWriter writer=new StringWriter();
    user.write(writer);
    dump=writer.toString();
    final Diff diff=new Diff(dump,expected);
    Assert.assertTrue("Expected : \n" + expected + "\nActual :\n"+ dump+ "\n"+ diff.toString(),diff.identical());
  }
}
