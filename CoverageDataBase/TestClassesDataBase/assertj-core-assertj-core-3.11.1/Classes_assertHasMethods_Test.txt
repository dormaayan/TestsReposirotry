public class Classes_assertHasMethods_Test extends ClassesBaseTest {
  @BeforeEach public void setupActual(){
    AnotherMethodsClass m=new AnotherMethodsClass();
    Strings.isNullOrEmpty(m.string);
    actual=AnotherMethodsClass.class;
  }
private static class AnotherMethodsClass extends MethodsClass {
    private String string;
  }
  @Test public void should_pass_if_actual_has_expected_accessible_public_methods(){
    classes.assertHasMethods(someInfo(),actual,"publicMethod","protectedMethod","privateMethod");
  }
  @Test public void should_fail_if_no_methods_are_expected_and_methods_are_available(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> classes.assertHasMethods(someInfo(),actual)).withMessage(format(shouldNotHaveMethods(actual,false,newTreeSet("publicMethod","protectedMethod","privateMethod","finalize","wait","equals","toString","hashCode","getClass","clone","registerNatives","notify","notifyAll")).create()));
  }
  @Test public void should_fail_if_actual_is_null(){
    actual=null;
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> classes.assertHasMethods(someInfo(),actual)).withMessage(actualIsNull());
  }
  @Test public void should_pass_if_methods_are_inherited(){
    String[] expected=array("notify","notifyAll");
    classes.assertHasMethods(someInfo(),actual,expected);
  }
  @Test() public void should_fail_if_expected_methods_are_missing(){
    String[] expected=array("missingMethod","publicMethod");
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> classes.assertHasMethods(someInfo(),actual,expected)).withMessage(format(shouldHaveMethods(actual,false,newTreeSet(expected),newTreeSet("missingMethod")).create()));
  }
}
