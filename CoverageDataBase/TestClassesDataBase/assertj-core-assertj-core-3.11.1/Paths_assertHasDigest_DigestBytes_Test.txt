/** 
 * Tests for <code> {@link Paths#assertHasDigest(AssertionInfo,Path,MessageDigest,byte[])}</code>
 * @author Valeriy Vyrva
 */
public class Paths_assertHasDigest_DigestBytes_Test extends MockPathsBaseTest {
  private final MessageDigest digest=mock(MessageDigest.class);
  private final byte[] expected=new byte[0];
  @Test public void should_fail_if_actual_is_null(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> paths.assertHasDigest(info,null,digest,expected)).withMessage(actualIsNull());
  }
  @Test public void should_fail_with_should_exist_error_if_actual_does_not_exist(){
    given(nioFilesWrapper.exists(actual)).willReturn(false);
    catchThrowable(() -> paths.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldExist(actual));
  }
  @Test public void should_fail_if_actual_exists_but_is_not_file(){
    given(nioFilesWrapper.exists(actual)).willReturn(true);
    given(nioFilesWrapper.isRegularFile(actual)).willReturn(false);
    catchThrowable(() -> paths.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldBeRegularFile(actual));
  }
  @Test public void should_fail_if_actual_exists_but_is_not_readable(){
    given(nioFilesWrapper.exists(actual)).willReturn(true);
    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
    given(nioFilesWrapper.isReadable(actual)).willReturn(false);
    catchThrowable(() -> paths.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldBeReadable(actual));
  }
  @Test public void should_throw_error_if_digest_is_null(){
    assertThatNullPointerException().isThrownBy(() -> paths.assertHasDigest(INFO,null,(MessageDigest)null,expected)).withMessage("The message digest algorithm should not be null");
  }
  @Test public void should_throw_error_if_expected_is_null(){
    assertThatNullPointerException().isThrownBy(() -> paths.assertHasDigest(INFO,null,digest,(byte[])null)).withMessage("The binary representation of digest to compare to should not be null");
  }
  @Test public void should_throw_error_wrapping_catched_IOException() throws IOException {
    IOException cause=new IOException();
    given(nioFilesWrapper.exists(actual)).willReturn(true);
    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
    given(nioFilesWrapper.newInputStream(actual)).willThrow(cause);
    Throwable error=catchThrowable(() -> paths.assertHasDigest(INFO,actual,digest,expected));
    assertThat(error).isInstanceOf(UncheckedIOException.class).hasCause(cause);
  }
  @Test public void should_throw_error_wrapping_catched_NoSuchAlgorithmException(){
    String unknownDigestAlgorithm="UnknownDigestAlgorithm";
    Throwable error=catchThrowable(() -> paths.assertHasDigest(INFO,actual,unknownDigestAlgorithm,expected));
    assertThat(error).isInstanceOf(IllegalStateException.class).hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
  }
  @Test public void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
    InputStream stream=getClass().getResourceAsStream("/red.png");
    given(nioFilesWrapper.exists(actual)).willReturn(true);
    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
    given(digest.digest()).willReturn(new byte[]{0,1});
    catchThrowable(() -> paths.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldHaveDigest(actual,new DigestDiff("0001","",digest)));
    failIfStreamIsOpen(stream);
  }
  @Test public void should_pass_if_actual_has_expected_digest() throws IOException {
    InputStream stream=getClass().getResourceAsStream("/red.png");
    given(nioFilesWrapper.exists(actual)).willReturn(true);
    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
    given(digest.digest()).willReturn(expected);
    paths.assertHasDigest(INFO,actual,digest,expected);
    failIfStreamIsOpen(stream);
  }
}
