public class AtomicReferenceArrayAssert_usingComparatorForType_Test extends AtomicReferenceArrayAssertBaseTest {
  private ObjectArrays arraysBefore;
  private Jedi actual=new Jedi("Yoda","green");
  private Jedi other=new Jedi("Luke","blue");
  @BeforeEach public void before(){
    arraysBefore=getArrays(assertions);
  }
  @Override protected AtomicReferenceArrayAssert<Object> invoke_api_method(){
    return assertions.usingComparatorForType(ALWAY_EQUALS_STRING,String.class);
  }
  @Override protected void verify_internal_effects(){
    ObjectArrays arrays=getArrays(assertions);
    assertThat(arrays).isNotSameAs(arraysBefore);
    assertThat(arrays.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
    ComparatorBasedComparisonStrategy strategy=(ComparatorBasedComparisonStrategy)arrays.getComparisonStrategy();
    assertThat(strategy.getComparator()).isInstanceOf(ExtendedByTypesComparator.class);
  }
  @Test public void should_be_able_to_use_a_comparator_for_specified_types(){
    Object[] array=array("some","other",new BigDecimal(42));
    AtomicReferenceArray<Object> atomicArray=new AtomicReferenceArray<>(array);
    assertThat(atomicArray).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingComparatorForType(BIG_DECIMAL_COMPARATOR,BigDecimal.class).contains("other","any",new BigDecimal("42.0"));
  }
  @Test public void should_use_comparator_for_type_when_using_element_comparator_ignoring_fields(){
    Object[] array=array(actual,"some");
    AtomicReferenceArray<Object> atomicArray=new AtomicReferenceArray<>(array);
    assertThat(atomicArray).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingElementComparatorIgnoringFields("name").contains(other,"any");
  }
  @Test public void should_use_comparator_for_type_when_using_element_comparator_on_fields(){
    Object[] array=array(actual,"some");
    AtomicReferenceArray<Object> atomicArray=new AtomicReferenceArray<>(array);
    assertThat(atomicArray).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingElementComparatorOnFields("name","lightSaberColor").contains(other,"any");
  }
  @Test public void should_use_comparator_for_type_when_using_field_by_field_element_comparator(){
    Object[] array=array(actual,"some");
    AtomicReferenceArray<Object> atomicArray=new AtomicReferenceArray<>(array);
    assertThat(atomicArray).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingFieldByFieldElementComparator().contains(other,"any");
  }
  @Test public void should_use_comparator_for_type_when_using_recursive_field_by_field_element_comparator(){
    Object[] array=array(actual,"some");
    AtomicReferenceArray<Object> atomicArray=new AtomicReferenceArray<>(array);
    assertThat(atomicArray).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingRecursiveFieldByFieldElementComparator().contains(other,"any");
  }
  @Test public void should_not_use_comparator_on_fields_level_for_elements(){
    Object[] array=array(actual,"some");
    AtomicReferenceArray<Object> atomicArray=new AtomicReferenceArray<>(array);
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(atomicArray).usingComparatorForElementFieldsWithType(ALWAY_EQUALS_STRING,String.class).usingFieldByFieldElementComparator().contains(other,"any")).withMessage(format("%nExpecting:%n" + " <[Yoda the Jedi, \"some\"]>%n" + "to contain:%n"+ " <[Luke the Jedi, \"any\"]>%n"+ "but could not find:%n"+ " <[\"any\"]>%n"+ "when comparing values using field/property by field/property comparator on all fields/properties%n"+ "Comparators used:%n"+ "- for elements fields (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6], String -> AlwaysEqualComparator}%n"+ "- for elements (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6]}"));
  }
  @Test public void should_use_comparator_set_last_on_elements(){
    AtomicReferenceArray<Jedi> atomicArray=atomicArrayOf(actual,actual);
    assertThat(atomicArray).usingComparatorForElementFieldsWithType(NEVER_EQUALS_STRING,String.class).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingFieldByFieldElementComparator().contains(other,other);
  }
  @Test public void should_be_able_to_replace_a_registered_comparator_by_type(){
    assertThat(asList(actual,actual)).usingComparatorForType(NEVER_EQUALS_STRING,String.class).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingFieldByFieldElementComparator().contains(other,other);
  }
  @Test public void should_be_able_to_replace_a_registered_comparator_by_field(){
    assertThat(asList(actual,actual)).usingComparatorForElementFieldsWithNames(NEVER_EQUALS_STRING,"name","lightSaberColor").usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,"name","lightSaberColor").usingFieldByFieldElementComparator().contains(other,other);
  }
  @Test public void should_fail_because_of_comparator_set_last(){
    AtomicReferenceArray<Jedi> atomicArray=atomicArrayOf(actual,actual);
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(atomicArray).usingComparatorForType(ALWAY_EQUALS_STRING,String.class).usingComparatorForElementFieldsWithType(NEVER_EQUALS_STRING,String.class).usingFieldByFieldElementComparator().contains(other,other)).withMessage(format("%nExpecting:%n" + " <[Yoda the Jedi, Yoda the Jedi]>%n" + "to contain:%n"+ " <[Luke the Jedi, Luke the Jedi]>%n"+ "but could not find:%n"+ " <[Luke the Jedi]>%n"+ "when comparing values using field/property by field/property comparator on all fields/properties%n"+ "Comparators used:%n"+ "- for elements fields (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6], String -> org.assertj.core.test.NeverEqualComparator}%n"+ "- for elements (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6], String -> AlwaysEqualComparator}"));
  }
}
