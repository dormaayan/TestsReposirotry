/** 
 * Tests for <code> {@link org.assertj.core.internal.Maps#assertContainsOnly(org.assertj.core.api.AssertionInfo,java.util.Map,org.assertj.core.data.MapEntry)}</code> .
 * @author Jean-Christophe Gay
 */
public class Maps_assertContainsOnly_Test extends MapsBaseTest {
  @SuppressWarnings("unchecked") @Test public void should_fail_if_actual_is_null(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> maps.assertContainsOnly(someInfo(),null,entry("name","Yoda"))).withMessage(actualIsNull());
  }
  @SuppressWarnings("unchecked") @Test public void should_fail_if_given_entries_array_is_null(){
    assertThatNullPointerException().isThrownBy(() -> maps.assertContainsOnly(someInfo(),actual,(MapEntry[])null)).withMessage(entriesToLookForIsNull());
  }
  @SuppressWarnings("unchecked") @Test public void should_fail_if_given_entries_array_is_empty(){
    assertThatIllegalArgumentException().isThrownBy(() -> maps.assertContainsOnly(someInfo(),actual,emptyEntries())).withMessage(entriesToLookForIsEmpty());
  }
  @SuppressWarnings("unchecked") @Test public void should_pass_if_actual_and_entries_are_empty(){
    maps.assertContainsOnly(someInfo(),emptyMap(),emptyEntries());
  }
  @SuppressWarnings("unchecked") @Test public void should_pass_if_actual_contains_only_expected_entries(){
    maps.assertContainsOnly(someInfo(),actual,entry("name","Yoda"),entry("color","green"));
  }
  @Test public void should_fail_if_actual_contains_unexpected_entry(){
    AssertionInfo info=someInfo();
    MapEntry<String,String>[] expected=array(entry("name","Yoda"));
    try {
      maps.assertContainsOnly(info,actual,expected);
    }
 catch (    AssertionError e) {
      verify(failures).failure(info,shouldContainOnly(actual,expected,emptySet(),newHashSet(entry("color","green"))));
      return;
    }
    shouldHaveThrown(AssertionError.class);
  }
  @Test public void should_fail_if_actual_does_not_contains_every_expected_entries(){
    AssertionInfo info=someInfo();
    MapEntry<String,String>[] expected=array(entry("name","Yoda"),entry("color","green"));
    Map<String,String> underTest=Maps.mapOf(entry("name","Yoda"));
    try {
      maps.assertContainsOnly(info,underTest,expected);
    }
 catch (    AssertionError e) {
      verify(failures).failure(info,shouldContainOnly(underTest,expected,newHashSet(entry("color","green")),emptySet()));
      return;
    }
    shouldHaveThrown(AssertionError.class);
  }
  @Test public void should_fail_if_actual_does_not_contains_every_expected_entries_and_contains_unexpected_one(){
    AssertionInfo info=someInfo();
    MapEntry<String,String>[] expected=array(entry("name","Yoda"),entry("color","green"));
    Map<String,String> underTest=Maps.mapOf(entry("name","Yoda"),entry("job","Jedi"));
    try {
      maps.assertContainsOnly(info,underTest,expected);
    }
 catch (    AssertionError e) {
      verify(failures).failure(info,shouldContainOnly(underTest,expected,newHashSet(entry("color","green")),newHashSet(entry("job","Jedi"))));
      return;
    }
    shouldHaveThrown(AssertionError.class);
  }
  @Test public void should_fail_if_actual_contains_entry_key_with_different_value(){
    AssertionInfo info=someInfo();
    MapEntry<String,String>[] expectedEntries=array(entry("name","Yoda"),entry("color","yellow"));
    try {
      maps.assertContainsOnly(info,actual,expectedEntries);
    }
 catch (    AssertionError e) {
      verify(failures).failure(info,shouldContainOnly(actual,expectedEntries,newHashSet(entry("color","yellow")),newHashSet(entry("color","green"))));
      return;
    }
    shouldHaveThrown(AssertionError.class);
  }
  private static <K,V>HashSet<MapEntry<K,V>> newHashSet(  MapEntry<K,V> entry){
    HashSet<MapEntry<K,V>> notExpected=new HashSet<>();
    notExpected.add(entry);
    return notExpected;
  }
}
