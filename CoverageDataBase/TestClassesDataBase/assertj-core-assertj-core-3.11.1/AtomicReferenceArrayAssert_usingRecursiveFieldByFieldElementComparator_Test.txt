public class AtomicReferenceArrayAssert_usingRecursiveFieldByFieldElementComparator_Test extends AtomicReferenceArrayAssertBaseTest {
  private ObjectArrays arraysBefore;
  @BeforeEach public void before(){
    arraysBefore=getArrays(assertions);
  }
  @Override protected AtomicReferenceArrayAssert<Object> invoke_api_method(){
    return assertions.usingRecursiveFieldByFieldElementComparator();
  }
  @Override protected void verify_internal_effects(){
    assertThat(arraysBefore).isNotSameAs(getArrays(assertions));
    assertThat(getArrays(assertions).getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
    assertThat(getObjects(assertions).getComparisonStrategy()).isInstanceOf(AtomicReferenceArrayElementComparisonStrategy.class);
  }
  @Test public void successful_isEqualTo_assertion_using_recursive_field_by_field_element_comparator(){
    AtomicReferenceArray<Foo> array1=atomicArrayOf(new Foo("id",new Bar(1)));
    Foo[] array2={new Foo("id",new Bar(1))};
    assertThat(array1).usingRecursiveFieldByFieldElementComparator().isEqualTo(array2);
  }
  @Test public void successful_isIn_assertion_using_recursive_field_by_field_element_comparator(){
    AtomicReferenceArray<Foo> array1=atomicArrayOf(new Foo("id",new Bar(1)));
    Foo[] array2={new Foo("id",new Bar(1))};
    assertThat(array1).usingRecursiveFieldByFieldElementComparator().isIn(new Object[]{(array2)});
  }
  @Test public void failed_isEqualTo_assertion_using_recursive_field_by_field_element_comparator(){
    AtomicReferenceArray<Foo> array1=atomicArrayOf(new Foo("id",new Bar(1)));
    Foo[] array2={new Foo("id",new Bar(2))};
    try {
      assertThat(array1).usingRecursiveFieldByFieldElementComparator().isEqualTo(array2);
    }
 catch (    AssertionError e) {
      assertThat(e).hasMessage(format("%nExpecting:%n" + " <[Foo(id=id, bar=Bar(id=1))]>%n" + "to be equal to:%n"+ " <[Foo(id=id, bar=Bar(id=2))]>%n"+ "when comparing elements using recursive field/property by field/property comparator on all fields/properties%n"+ "Comparators used:%n"+ "- for elements fields (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6]}%n"+ "- for elements (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6]}%n"+ "but was not."));
      return;
    }
    failBecauseExpectedAssertionErrorWasNotThrown();
  }
  @Test public void failed_isIn_assertion_using_recursive_field_by_field_element_comparator(){
    AtomicReferenceArray<Foo> array1=atomicArrayOf(new Foo("id",new Bar(1)));
    Foo[] array2={new Foo("id",new Bar(2))};
    try {
      assertThat(array1).usingRecursiveFieldByFieldElementComparator().isIn(new Object[]{array2});
    }
 catch (    AssertionError e) {
      assertThat(e).hasMessage(format("%nExpecting:%n" + " <[Foo(id=id, bar=Bar(id=1))]>%n" + "to be in:%n"+ " <[[Foo(id=id, bar=Bar(id=2))]]>%n"+ "when comparing elements using recursive field/property by field/property comparator on all fields/properties%n"+ "Comparators used:%n"+ "- for elements fields (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6]}%n"+ "- for elements (by type): {Double -> DoubleComparator[precision=1.0E-15], Float -> FloatComparator[precision=1.0E-6]}"));
      return;
    }
    failBecauseExpectedAssertionErrorWasNotThrown();
  }
  @Test public void should_be_able_to_use_a_comparator_for_specified_fields_of_elements_when_using_recursive_field_by_field_element_comparator(){
    Foo actual=new Foo("1",new Bar(1));
    Foo other=new Foo("1",new Bar(2));
final class AlwaysEqualIntegerComparator implements Comparator<Integer> {
      @Override public int compare(      Integer o1,      Integer o2){
        return 0;
      }
    }
    assertThat(atomicArrayOf(actual)).usingComparatorForElementFieldsWithNames(new AlwaysEqualIntegerComparator(),"bar.id").usingRecursiveFieldByFieldElementComparator().contains(other);
  }
  @Test public void comparators_for_element_field_names_should_have_precedence_over_comparators_for_element_field_types_when_using_recursive_field_by_field_element_comparator(){
    Comparator<String> comparator=(o1,o2) -> o1.compareTo(o2);
    Foo actual=new Foo("1",new Bar(1));
    Foo other=new Foo("2",new Bar(1));
    assertThat(atomicArrayOf(actual)).usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,"id").usingComparatorForElementFieldsWithType(comparator,String.class).usingRecursiveFieldByFieldElementComparator().contains(other);
  }
  @Test public void should_be_able_to_use_a_comparator_for_element_fields_with_specified_type_when_using_recursive_field_by_field_element_comparator(){
    Foo actual=new Foo("1",new Bar(1));
    Foo other=new Foo("2",new Bar(1));
    assertThat(atomicArrayOf(actual)).usingComparatorForElementFieldsWithType(ALWAY_EQUALS_STRING,String.class).usingRecursiveFieldByFieldElementComparator().contains(other);
  }
public static class Foo {
    public String id;
    public Bar bar;
    public Foo(    String id,    Bar bar){
      this.id=id;
      this.bar=bar;
    }
    @Override public String toString(){
      return "Foo(id=" + id + ", bar="+ bar+ ")";
    }
  }
public static class Bar {
    public int id;
    public Bar(    int id){
      this.id=id;
    }
    @Override public String toString(){
      return "Bar(id=" + id + ")";
    }
  }
}
