/** 
 * Tests for <code> {@link Files#assertHasDigest(AssertionInfo,File,MessageDigest,String)}</code>
 * @author Valeriy Vyrva
 */
public class Files_assertHasDigest_DigestString_Test extends FilesBaseTest {
  private final MessageDigest digest=mock(MessageDigest.class);
  private final String expected="";
  @Test public void should_fail_if_actual_is_null(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasDigest(INFO,null,digest,expected)).withMessage(actualIsNull());
  }
  @Test public void should_fail_with_should_exist_error_if_actual_does_not_exist(){
    given(actual.exists()).willReturn(false);
    catchThrowable(() -> files.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldExist(actual));
  }
  @Test public void should_fail_if_actual_exists_but_is_not_file(){
    given(actual.exists()).willReturn(true);
    given(actual.isFile()).willReturn(false);
    catchThrowable(() -> files.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldBeFile(actual));
  }
  @Test public void should_fail_if_actual_exists_but_is_not_readable(){
    given(actual.exists()).willReturn(true);
    given(actual.isFile()).willReturn(true);
    given(actual.canRead()).willReturn(false);
    catchThrowable(() -> files.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldBeReadable(actual));
  }
  @Test public void should_throw_error_if_digest_is_null(){
    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO,null,(MessageDigest)null,expected)).withMessage("The message digest algorithm should not be null");
  }
  @Test public void should_throw_error_if_expected_is_null(){
    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO,null,digest,(byte[])null)).withMessage("The binary representation of digest to compare to should not be null");
  }
  @Test public void should_throw_error_wrapping_catched_IOException() throws IOException {
    IOException cause=new IOException();
    given(actual.exists()).willReturn(true);
    given(actual.isFile()).willReturn(true);
    given(actual.canRead()).willReturn(true);
    given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
    Throwable error=catchThrowable(() -> files.assertHasDigest(INFO,actual,digest,expected));
    assertThat(error).isInstanceOf(UncheckedIOException.class).hasCause(cause);
  }
  @Test public void should_throw_error_wrapping_catched_NoSuchAlgorithmException(){
    String unknownDigestAlgorithm="UnknownDigestAlgorithm";
    Throwable error=catchThrowable(() -> files.assertHasDigest(INFO,actual,unknownDigestAlgorithm,expected));
    assertThat(error).isInstanceOf(IllegalStateException.class).hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
  }
  @Test public void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
    InputStream stream=getClass().getResourceAsStream("/red.png");
    given(actual.exists()).willReturn(true);
    given(actual.isFile()).willReturn(true);
    given(actual.canRead()).willReturn(true);
    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
    given(digest.digest()).willReturn(new byte[]{0,1});
    catchThrowable(() -> files.assertHasDigest(INFO,actual,digest,expected));
    verify(failures).failure(INFO,shouldHaveDigest(actual,new DigestDiff("0001","",digest)));
    failIfStreamIsOpen(stream);
  }
  @Test public void should_pass_if_actual_has_expected_digest() throws IOException {
    InputStream stream=getClass().getResourceAsStream("/red.png");
    given(actual.exists()).willReturn(true);
    given(actual.isFile()).willReturn(true);
    given(actual.canRead()).willReturn(true);
    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
    given(digest.digest()).willReturn(expected.getBytes());
    files.assertHasDigest(INFO,actual,digest,expected);
    failIfStreamIsOpen(stream);
  }
}
