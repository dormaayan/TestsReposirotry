public class OffsetDateTimeAssert_isEqualToIgnoringNanoseconds_Test extends BaseTest {
  private final OffsetDateTime refOffsetDateTime=of(2000,1,1,0,0,1,0,UTC);
  @Test public void should_pass_if_actual_is_equal_to_other_ignoring_nanosecond_fields(){
    assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.withNano(55));
    assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.plusNanos(1));
  }
  @Test public void should_fail_if_actual_is_not_equal_to_given_offsetdatetime_with_nanoseconds_ignored(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.plusSeconds(1))).withMessage(format("%nExpecting:%n" + "  <2000-01-01T00:00:01Z>%n" + "to have same year, month, day, hour, minute and second as:%n"+ "  <2000-01-01T00:00:02Z>%nb"+ "ut had not."));
  }
  @Test public void should_fail_as_seconds_fields_are_different(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.minusNanos(1))).withMessage(format("%n" + "Expecting:%n" + "  <2000-01-01T00:00:01Z>%n"+ "to have same year, month, day, hour, minute and second as:%n"+ "  <2000-01-01T00:00:00.999999999Z>%n"+ "but had not."));
  }
  @Test public void should_fail_if_actual_is_null(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
      OffsetDateTime actual=null;
      assertThat(actual).isEqualToIgnoringNanos(OffsetDateTime.now());
    }
).withMessage(actualIsNull());
  }
  @Test public void should_throw_error_if_given_offsetdatetime_is_null(){
    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringNanos(null)).withMessage(NULL_OFFSET_DATE_TIME_PARAMETER_MESSAGE);
  }
}
