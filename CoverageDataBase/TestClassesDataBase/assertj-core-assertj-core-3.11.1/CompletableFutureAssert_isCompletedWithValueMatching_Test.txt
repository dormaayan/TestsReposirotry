public class CompletableFutureAssert_isCompletedWithValueMatching_Test extends BaseTest {
  @Test public void should_pass_if_completable_future_is_completed(){
    CompletableFuture<String> future=completedFuture("done");
    assertThat(future).isCompletedWithValueMatching(result -> result.equals("done"));
  }
  @Test public void should_fail_when_completable_future_is_null(){
    CompletableFuture<String> future=null;
    Throwable throwable=catchThrowable(() -> assertThat(future).isCompletedWithValueMatching(result -> result.equals("done")));
    assertThat(throwable).isInstanceOf(AssertionError.class).hasMessage(format(actualIsNull()));
  }
  @Test public void should_fail_if_result_does_not_match(){
    CompletableFuture<String> future=CompletableFuture.completedFuture("done");
    Throwable throwable=catchThrowable(() -> assertThat(future).isCompletedWithValueMatching(result -> result.equals("foo"),"is foo"));
    assertThat(throwable).isInstanceOf(AssertionError.class).hasMessageContaining("<\"done\">").hasMessageContaining("to match 'is foo' predicate");
  }
  @Test public void should_print_advice_without_description(){
    CompletableFuture<String> future=CompletableFuture.completedFuture("done");
    Throwable throwable=catchThrowable(() -> assertThat(future).isCompletedWithValueMatching(result -> result.equals("foo")));
    assertThat(throwable).isInstanceOf(AssertionError.class).hasMessageContaining("<\"done\">").hasMessageContaining("to match given predicate").hasMessageContaining("a better error message");
  }
  @Test public void should_fail_if_completable_future_is_incomplete(){
    CompletableFuture<String> future=new CompletableFuture<>();
    Throwable throwable=catchThrowable(() -> assertThat(future).isCompletedWithValueMatching(result -> result.equals("done")));
    assertThat(throwable).isInstanceOf(AssertionError.class).hasMessage(shouldBeCompleted(future).create());
  }
  @Test public void should_fail_if_completable_future_has_failed(){
    CompletableFuture<String> future=new CompletableFuture<>();
    future.completeExceptionally(new RuntimeException());
    Throwable throwable=catchThrowable(() -> assertThat(future).isCompletedWithValueMatching(result -> result.equals("done")));
    assertThat(throwable).isInstanceOf(AssertionError.class).hasMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed: java.lang.RuntimeException]%n")).hasMessageContaining("Caused by: java.lang.RuntimeException").hasMessageEndingWith(format("to be completed.%n%s",WARNING));
  }
  @Test public void should_fail_if_completable_future_was_cancelled(){
    CompletableFuture<String> future=new CompletableFuture<>();
    future.cancel(true);
    Throwable throwable=catchThrowable(() -> assertThat(future).isCompletedWithValueMatching(result -> result.equals("done")));
    assertThat(throwable).isInstanceOf(AssertionError.class).hasMessage(shouldBeCompleted(future).create());
  }
}
