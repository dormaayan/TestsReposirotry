public class ShouldBeEqualByComparingFieldByFieldRecursively_create_Test {
  private static final Representation REPRESENTATION=CONFIGURATION_PROVIDER.representation();
  @Test public void should_throw_assertion_error_rather_than_null_pointer_when_one_nested_member_is_null(){
    Jedi yoda=new Jedi("Yoda","Green");
    Jedi noname=new Jedi(null,"Green");
    Throwable throwable1=catchThrowable(() -> assertThat(yoda).isEqualToComparingFieldByFieldRecursively(noname));
    Throwable throwable2=catchThrowable(() -> assertThat(noname).isEqualToComparingFieldByFieldRecursively(yoda));
    assertThat(throwable1).isInstanceOf(AssertionError.class).isNotInstanceOf(NullPointerException.class);
    assertThat(throwable2).isInstanceOf(AssertionError.class).isNotInstanceOf(NullPointerException.class);
  }
  @Test public void should_use_unambiguous_fields_description_when_standard_description_of_actual_and_expected_collection_fields_values_are_identical(){
    WithCollection<String> withHashSet=new WithCollection<>(new LinkedHashSet<String>());
    WithCollection<String> withSortedSet=new WithCollection<>(new TreeSet<String>());
    withHashSet.collection.add("bar");
    withHashSet.collection.add("foo");
    withSortedSet.collection.addAll(withHashSet.collection);
    List<Difference> differences=determineDifferences(withHashSet,withSortedSet,null,null);
    String message=shouldBeEqualByComparingFieldByFieldRecursive(withHashSet,withSortedSet,differences,REPRESENTATION).create(new TextDescription("Test"),REPRESENTATION);
    assertThat(message).isEqualTo(format("[Test] %n" + "Expecting:%n" + "  <WithCollection [collection=[bar, foo]]>%n"+ "to be equal to:%n"+ "  <WithCollection [collection=[bar, foo]]>%n"+ "when recursively comparing field by field, but found the following difference(s):%n"+ "%n"+ "Path to difference: <collection>%n"+ "- actual  : <[\"bar\", \"foo\"] (LinkedHashSet@%s)>%n"+ "- expected: <[\"bar\", \"foo\"] (TreeSet@%s)>",toHexString(System.identityHashCode(withHashSet.collection)),toHexString(System.identityHashCode(withSortedSet.collection))));
  }
  @Test public void should_use_unambiguous_fields_description_when_standard_description_of_actual_and_expected_map_fields_values_are_identical(){
    WithMap<Long,Boolean> withLinkedHashMap=new WithMap<>(new LinkedHashMap<>());
    WithMap<Long,Boolean> withTreeMap=new WithMap<>(new TreeMap<>());
    withLinkedHashMap.map.put(1L,true);
    withLinkedHashMap.map.put(2L,false);
    withTreeMap.map.putAll(withLinkedHashMap.map);
    List<Difference> differences=determineDifferences(withLinkedHashMap,withTreeMap,null,null);
    String message=shouldBeEqualByComparingFieldByFieldRecursive(withLinkedHashMap,withTreeMap,differences,REPRESENTATION).create(new TextDescription("Test"),REPRESENTATION);
    assertThat(message).isEqualTo(format("[Test] %n" + "Expecting:%n" + "  <WithMap [map={1=true, 2=false}]>%n"+ "to be equal to:%n"+ "  <WithMap [map={1=true, 2=false}]>%n"+ "when recursively comparing field by field, but found the following difference(s):%n"+ "%n"+ "Path to difference: <map>%n"+ "- actual  : <{1L=true, 2L=false} (LinkedHashMap@%s)>%n"+ "- expected: <{1L=true, 2L=false} (TreeMap@%s)>",toHexString(System.identityHashCode(withLinkedHashMap.map)),toHexString(System.identityHashCode(withTreeMap.map))));
  }
  @Test public void should_precise_missing_fields_when_actual_does_not_declare_all_expected_fields(){
    Person person=new Person("John","Doe");
    PersonDAO personDAO=new PersonDAO("John","Doe",1L,23);
    List<Difference> differences=determineDifferences(person,personDAO,null,null);
    String message=shouldBeEqualByComparingFieldByFieldRecursive(person,personDAO,differences,REPRESENTATION).create(new TextDescription("Test"),REPRESENTATION);
    String personHash=toHexString(person.hashCode());
    String personDAOHash=toHexString(personDAO.hashCode());
    assertThat(message).isEqualTo(format("[Test] %n" + "Expecting:%n" + "  <org.assertj.core.error.Person@%s>%n"+ "to be equal to:%n"+ "  <org.assertj.core.error.PersonDAO@%s>%n"+ "when recursively comparing field by field, but found the following difference(s):%n"+ "%n"+ "Path to difference: <>%n"+ "- actual  : <org.assertj.core.error.Person@%s>%n"+ "- expected: <org.assertj.core.error.PersonDAO@%s>%n"+ "- reason  : org.assertj.core.error.Person can't be compared to org.assertj.core.error.PersonDAO as PersonDAO does not declare all Person fields, it lacks these:[firstName, lastName]",personHash,personDAOHash,personHash,personDAOHash));
  }
  @Test public void should_not_fall_with_npe_if_field_of_one_of_compared_objects_is_null(){
    final Name actualName=new Name("Andy");
    final Name nullName=new Name(null);
    Throwable error=ThrowableAssert.catchThrowable(new ThrowableAssert.ThrowingCallable(){
      @Override public void call() throws Throwable {
        assertThat(actualName).isEqualToComparingFieldByFieldRecursively(nullName);
      }
    }
);
    assertThat(error).isNotExactlyInstanceOf(NullPointerException.class);
  }
}
