public class IterableAssert_filteredOn_condition_Test extends IterableAssert_filtered_baseTest {
  private Condition<Employee> oldEmployees;
  private Condition<TolkienCharacter> nameStartingWithFro;
  @Override @BeforeEach public void setUp(){
    super.setUp();
    oldEmployees=new Condition<>(employee -> employee.getAge() > 100,"old employees");
    nameStartingWithFro=new Condition<>(hobbit -> hobbit.getName().startsWith("Fro"),"name starts with Fro");
  }
  @Test public void should_filter_iterable_under_test_on_condition(){
    assertThat(employees).filteredOn(oldEmployees).containsOnly(yoda,obiwan);
  }
  @Test public void should_filter_iterable_under_test_on_combined_condition(){
    assertThat(employees).filteredOn(not(oldEmployees)).contains(luke,noname);
  }
  @Test public void should_fail_if_given_condition_is_null(){
    assertThatIllegalArgumentException().isThrownBy(() -> {
      oldEmployees=null;
      assertThat(employees).filteredOn(oldEmployees);
    }
).withMessage("The filter condition should not be null");
  }
  @Test public void shoul_honor_AssertFactory_strongly_typed_navigation_assertions(){
    Iterable<TolkienCharacter> hobbits=hobbits();
    TolkienCharacterAssertFactory tolkienCharacterAssertFactory=new TolkienCharacterAssertFactory();
    assertThat(hobbits,tolkienCharacterAssertFactory).filteredOn(nameStartingWithFro).first().hasAge(33);
    assertThat(hobbits,tolkienCharacterAssertFactory).filteredOn(nameStartingWithFro).last().hasAge(33);
    assertThat(hobbits,tolkienCharacterAssertFactory).filteredOn(nameStartingWithFro).element(0).hasAge(33);
  }
  @Test public void shoul_honor_ClassBased_strongly_typed_navigation_assertions(){
    Iterable<TolkienCharacter> hobbits=hobbits();
    assertThat(hobbits,TolkienCharacterAssert.class).filteredOn(nameStartingWithFro).first().hasAge(33);
    assertThat(hobbits,TolkienCharacterAssert.class).filteredOn(nameStartingWithFro).last().hasAge(33);
    assertThat(hobbits,TolkienCharacterAssert.class).filteredOn(nameStartingWithFro).element(0).hasAge(33);
  }
  @Test public void should_keep_existing_assertion_contextual_information(){
    Iterable<TolkienCharacter> hobbits=hobbits();
    String description="should find Frodo";
    String errorMessage="should have found Frodo";
    Representation representation=UNICODE_REPRESENTATION;
    IterableAssert<TolkienCharacter> filteredAssertion=assertThat(hobbits).as(description).overridingErrorMessage(errorMessage).withRepresentation(representation).filteredOn(nameStartingWithFro);
    assertThat(filteredAssertion.info.descriptionText()).isEqualTo(description);
    assertThat(filteredAssertion.info.overridingErrorMessage()).isEqualTo(errorMessage);
    assertThat(filteredAssertion.info.representation()).isEqualTo(representation);
  }
  @Test public void should_keep_assertion_state(){
    Iterable<String> names=asList("John","Doe","Jane","Doe");
    IterableAssert<String> assertion=assertThat(names).as("test description").withFailMessage("error message").withRepresentation(UNICODE_REPRESENTATION).usingElementComparator(CaseInsensitiveStringComparator.instance).filteredOn(new Condition<>(string -> string.length() == 4,"4 letters")).containsExactly("JOHN","JANE");
    assertThat(assertion.descriptionText()).isEqualTo("test description");
    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
  }
}
