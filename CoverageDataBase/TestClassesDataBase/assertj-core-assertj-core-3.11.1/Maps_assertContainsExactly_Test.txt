/** 
 * Tests for <code> {@link org.assertj.core.internal.Maps#assertContainsExactly(org.assertj.core.api.AssertionInfo,java.util.Map,org.assertj.core.data.MapEntry)}</code> .
 * @author Jean-Christophe Gay
 */
public class Maps_assertContainsExactly_Test extends MapsBaseTest {
  private LinkedHashMap<String,String> linkedActual;
  @BeforeEach public void initLinkedHashMap(){
    linkedActual=new LinkedHashMap<>(2);
    linkedActual.put("name","Yoda");
    linkedActual.put("color","green");
  }
  @SuppressWarnings("unchecked") @Test public void should_fail_if_actual_is_null(){
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> maps.assertContainsExactly(someInfo(),null,entry("name","Yoda"))).withMessage(actualIsNull());
  }
  @SuppressWarnings("unchecked") @Test public void should_fail_if_given_entries_array_is_null(){
    assertThatNullPointerException().isThrownBy(() -> maps.assertContainsExactly(someInfo(),linkedActual,(MapEntry[])null)).withMessage(entriesToLookForIsNull());
  }
  @SuppressWarnings("unchecked") @Test public void should_fail_if_given_entries_array_is_empty(){
    assertThatIllegalArgumentException().isThrownBy(() -> maps.assertContainsExactly(someInfo(),linkedActual,emptyEntries())).withMessage(entriesToLookForIsEmpty());
  }
  @SuppressWarnings("unchecked") @Test public void should_pass_if_actual_and_entries_are_empty(){
    maps.assertContainsExactly(someInfo(),emptyMap(),emptyEntries());
  }
  @SuppressWarnings("unchecked") @Test public void should_pass_if_actual_contains_given_entries_in_order(){
    maps.assertContainsExactly(someInfo(),linkedActual,entry("name","Yoda"),entry("color","green"));
  }
  @SuppressWarnings("unchecked") @Test public void should_fail_if_actual_contains_given_entries_in_disorder(){
    AssertionInfo info=someInfo();
    try {
      maps.assertContainsExactly(info,linkedActual,entry("color","green"),entry("name","Yoda"));
    }
 catch (    AssertionError e) {
      verify(failures).failure(info,elementsDifferAtIndex(entry("name","Yoda"),entry("color","green"),0));
      return;
    }
    shouldHaveThrown(AssertionError.class);
  }
  @Test public void should_fail_if_actual_and_expected_entries_have_different_size(){
    AssertionInfo info=someInfo();
    MapEntry<String,String>[] expected=array(entry("name","Yoda"));
    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> maps.assertContainsExactly(info,linkedActual,expected)).withMessage(shouldHaveSameSizeAs(linkedActual,linkedActual.size(),expected.length).create());
  }
  @Test public void should_fail_if_actual_does_not_contains_every_expected_entries_and_contains_unexpected_one(){
    AssertionInfo info=someInfo();
    MapEntry<String,String>[] expected=array(entry("name","Yoda"),entry("color","green"));
    Map<String,String> underTest=newLinkedHashMap(entry("name","Yoda"),entry("job","Jedi"));
    try {
      maps.assertContainsExactly(info,underTest,expected);
    }
 catch (    AssertionError e) {
      verify(failures).failure(info,shouldContainExactly(underTest,asList(expected),newHashSet(entry("color","green")),newHashSet(entry("job","Jedi"))));
      return;
    }
    shouldHaveThrown(AssertionError.class);
  }
  @Test public void should_fail_if_actual_contains_entry_key_with_different_value(){
    AssertionInfo info=someInfo();
    MapEntry<String,String>[] expectedEntries=array(entry("name","Yoda"),entry("color","yellow"));
    try {
      maps.assertContainsExactly(info,actual,expectedEntries);
    }
 catch (    AssertionError e) {
      verify(failures).failure(info,shouldContainExactly(actual,asList(expectedEntries),newHashSet(entry("color","yellow")),newHashSet(entry("color","green"))));
      return;
    }
    shouldHaveThrown(AssertionError.class);
  }
  @SafeVarargs private static Map<String,String> newLinkedHashMap(  MapEntry<String,String>... entries){
    LinkedHashMap<String,String> result=new LinkedHashMap<>();
    for (    MapEntry<String,String> entry : entries) {
      result.put(entry.key,entry.value);
    }
    return result;
  }
  private static <K,V>Set<MapEntry<K,V>> newHashSet(  MapEntry<K,V> entry){
    LinkedHashSet<MapEntry<K,V>> result=new LinkedHashSet<>();
    result.add(entry);
    return result;
  }
}
