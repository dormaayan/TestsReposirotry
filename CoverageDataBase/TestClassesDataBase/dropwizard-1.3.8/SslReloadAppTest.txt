public class SslReloadAppTest {
  @ClassRule public static final TemporaryFolder FOLDER=new TemporaryFolder();
  private static final X509TrustManager TRUST_ALL=new X509TrustManager(){
    @Override public void checkClientTrusted(    X509Certificate[] x509Certificates,    String s) throws CertificateException {
    }
    @Override public void checkServerTrusted(    X509Certificate[] x509Certificates,    String s) throws CertificateException {
    }
    @Override public X509Certificate[] getAcceptedIssuers(){
      return new X509Certificate[0];
    }
  }
;
  private static Path keystore;
  @Rule public final DropwizardAppRule<Configuration> rule=new DropwizardAppRule<>(SslReloadApp.class,ResourceHelpers.resourceFilePath("sslreload/config.yml"),ConfigOverride.config("server.applicationConnectors[0].keyStorePath",keystore.toString()),ConfigOverride.config("server.adminConnectors[0].keyStorePath",keystore.toString()));
  @BeforeClass public static void setupClass() throws IOException {
    keystore=FOLDER.newFile("keystore.jks").toPath();
    final byte[] keystoreBytes=Resources.toByteArray(Resources.getResource("sslreload/keystore.jks"));
    Files.write(keystore,keystoreBytes);
  }
  @After public void after() throws IOException {
    final byte[] keystoreBytes=Resources.toByteArray(Resources.getResource("sslreload/keystore.jks"));
    Files.write(keystore,keystoreBytes);
  }
  @Test public void reloadCertificateChangesTheServerCertificate() throws Exception {
    final byte[] keystore2Bytes=Resources.toByteArray(Resources.getResource("sslreload/keystore2.jks"));
    Files.write(keystore,keystore2Bytes);
    byte[] firstCertBytes=certBytes(200,"Reloaded certificate configuration\n");
    byte[] secondCertBytes=certBytes(200,"Reloaded certificate configuration\n");
    byte[] thirdCertBytes=certBytes(200,"Reloaded certificate configuration\n");
    assertThat(firstCertBytes).isNotEqualTo(secondCertBytes);
    assertThat(secondCertBytes).isEqualTo(thirdCertBytes);
  }
  @Test public void badReloadDoesNotChangeTheServerCertificate() throws Exception {
    final byte[] badKeystore=Resources.toByteArray(Resources.getResource("sslreload/keystore-diff-pwd.jks"));
    Files.write(keystore,badKeystore);
    byte[] firstCertBytes=certBytes(500,"Keystore was tampered with, or password was incorrect");
    byte[] secondCertBytes=certBytes(500,"Keystore was tampered with, or password was incorrect");
    byte[] thirdCertBytes=certBytes(500,"Keystore was tampered with, or password was incorrect");
    assertThat(firstCertBytes).isEqualTo(secondCertBytes).isEqualTo(thirdCertBytes);
  }
  /** 
 * Issues a POST against the reload ssl admin task, asserts that the code and content are as expected, and finally returns the server certificate 
 */
  private byte[] certBytes(  int code,  String content) throws Exception {
    final URL url=new URL("https://localhost:" + rule.getAdminPort() + "/tasks/reload-ssl");
    final HttpsURLConnection conn=(HttpsURLConnection)url.openConnection();
    try {
      postIt(conn);
      assertThat(conn.getResponseCode()).isEqualTo(code);
      if (code == 200) {
        assertThat(CharStreams.toString(new InputStreamReader(conn.getInputStream(),StandardCharsets.UTF_8))).isEqualTo(content);
      }
 else {
        assertThat(CharStreams.toString(new InputStreamReader(conn.getErrorStream(),StandardCharsets.UTF_8))).contains(content);
      }
      return conn.getServerCertificates()[0].getEncoded();
    }
  finally {
      conn.disconnect();
    }
  }
  /** 
 * Configure SSL and POST request parameters 
 */
  private void postIt(  HttpsURLConnection conn) throws Exception {
    final SSLContext sslCtx=SSLContext.getInstance("TLS");
    sslCtx.init(null,new TrustManager[]{TRUST_ALL},null);
    conn.setHostnameVerifier(new NoopHostnameVerifier());
    conn.setSSLSocketFactory(sslCtx.getSocketFactory());
    conn.setDoOutput(true);
    conn.getOutputStream().write(new byte[]{});
  }
}
