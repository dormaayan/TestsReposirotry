@NotThreadSafe public class DbRollbackCommandTest extends AbstractMigrationTest {
  private final String migrationsFileName="migrations-ddl.xml";
  private final DbRollbackCommand<TestMigrationConfiguration> rollbackCommand=new DbRollbackCommand<>(new TestMigrationDatabaseConfiguration(),TestMigrationConfiguration.class,migrationsFileName);
  private final DbMigrateCommand<TestMigrationConfiguration> migrateCommand=new DbMigrateCommand<>(new TestMigrationDatabaseConfiguration(),TestMigrationConfiguration.class,migrationsFileName);
  private final ByteArrayOutputStream baos=new ByteArrayOutputStream();
  private TestMigrationConfiguration conf;
  private DBI dbi;
  @Before public void setUp() throws Exception {
    final String databaseUrl=getDatabaseUrl();
    conf=createConfiguration(databaseUrl);
    dbi=new DBI(databaseUrl,"sa","");
  }
  @Test public void testRollbackNChanges() throws Exception {
    migrateCommand.run(null,new Namespace(ImmutableMap.of()),conf);
    rollbackCommand.run(null,new Namespace(ImmutableMap.of("count",1)),conf);
    dbi.useHandle(h -> h.execute("alter table persons add column email varchar(128)"));
  }
  @Test public void testRollbackNChangesAsDryRun() throws Exception {
    migrateCommand.run(null,new Namespace(ImmutableMap.of()),conf);
    rollbackCommand.setOutputStream(new PrintStream(baos,true));
    rollbackCommand.run(null,new Namespace(ImmutableMap.of("count",1,"dry-run",true)),conf);
    assertThat(baos.toString(UTF_8)).containsIgnoringCase("ALTER TABLE PUBLIC.persons DROP COLUMN email;");
  }
  @Test public void testRollbackToDate() throws Exception {
    long migrationDate=System.currentTimeMillis();
    migrateCommand.run(null,new Namespace(ImmutableMap.of()),conf);
    rollbackCommand.run(null,new Namespace(ImmutableMap.of("date",new Date(migrationDate - 1000))),conf);
    dbi.useHandle(h -> h.execute("create table persons(id int, name varchar(255))"));
  }
  @Test public void testRollbackToDateAsDryRun() throws Exception {
    long migrationDate=System.currentTimeMillis();
    migrateCommand.run(null,new Namespace(ImmutableMap.of()),conf);
    rollbackCommand.setOutputStream(new PrintStream(baos,true));
    rollbackCommand.run(null,new Namespace(ImmutableMap.of("date",new Date(migrationDate - 1000),"dry-run",true)),conf);
    assertThat(baos.toString(UTF_8)).containsIgnoringCase("ALTER TABLE PUBLIC.persons DROP COLUMN email;").containsIgnoringCase("DROP TABLE PUBLIC.persons;");
  }
  @Test public void testRollbackToTag() throws Exception {
    migrateCommand.run(null,new Namespace(ImmutableMap.of("count",1)),conf);
    final DbTagCommand<TestMigrationConfiguration> tagCommand=new DbTagCommand<>(new TestMigrationDatabaseConfiguration(),TestMigrationConfiguration.class,migrationsFileName);
    tagCommand.run(null,new Namespace(ImmutableMap.of("tag-name",ImmutableList.of("v1"))),conf);
    migrateCommand.run(null,new Namespace(ImmutableMap.of()),conf);
    rollbackCommand.run(null,new Namespace(ImmutableMap.of("tag","v1")),conf);
    dbi.useHandle(h -> h.execute("alter table persons add column email varchar(128)"));
  }
  @Test public void testRollbackToTagAsDryRun() throws Exception {
    migrateCommand.run(null,new Namespace(ImmutableMap.of("count",1)),conf);
    final DbTagCommand<TestMigrationConfiguration> tagCommand=new DbTagCommand<>(new TestMigrationDatabaseConfiguration(),TestMigrationConfiguration.class,migrationsFileName);
    tagCommand.run(null,new Namespace(ImmutableMap.of("tag-name",ImmutableList.of("v1"))),conf);
    migrateCommand.run(null,new Namespace(ImmutableMap.of()),conf);
    rollbackCommand.setOutputStream(new PrintStream(baos,true));
    rollbackCommand.run(null,new Namespace(ImmutableMap.of("tag","v1","dry-run",true)),conf);
    assertThat(baos.toString(UTF_8)).containsIgnoringCase("ALTER TABLE PUBLIC.persons DROP COLUMN email;");
  }
  @Test public void testPrintHelp() throws Exception {
    createSubparser(rollbackCommand).printHelp(new PrintWriter(new OutputStreamWriter(baos,UTF_8),true));
    assertThat(baos.toString(UTF_8)).isEqualTo(String.format("usage: db rollback [-h] [--migrations MIGRATIONS-FILE] [--catalog CATALOG]%n" + "          [--schema SCHEMA] [-n] [-t TAG] [-d DATE] [-c COUNT]%n" + "          [-i CONTEXTS] [file]%n"+ "%n"+ "Rollback the database schema to a previous version.%n"+ "%n"+ "positional arguments:%n"+ "  file                   application configuration file%n"+ "%n"+ "named arguments:%n"+ "  -h, --help             show this help message and exit%n"+ "  --migrations MIGRATIONS-FILE%n"+ "                         the file containing  the  Liquibase migrations for%n"+ "                         the application%n"+ "  --catalog CATALOG      Specify  the   database   catalog   (use  database%n"+ "                         default if omitted)%n"+ "  --schema SCHEMA        Specify the database schema  (use database default%n"+ "                         if omitted)%n"+ "  -n, --dry-run          Output the DDL to stdout, don't run it%n"+ "  -t TAG, --tag TAG      Rollback to the given tag%n"+ "  -d DATE, --date DATE   Rollback to the given date%n"+ "  -c COUNT, --count COUNT%n"+ "                         Rollback the specified number of change sets%n"+ "  -i CONTEXTS, --include CONTEXTS%n"+ "                         include change sets from the given context%n"));
  }
}
