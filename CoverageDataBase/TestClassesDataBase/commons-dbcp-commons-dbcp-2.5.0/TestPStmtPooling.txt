/** 
 * TestSuite for BasicDataSource with prepared statement pooling enabled
 */
public class TestPStmtPooling {
  @Test public void testStmtPool() throws Exception {
    final DataSource ds=createPDS();
    try (Connection conn=ds.getConnection()){
      final Statement stmt1=conn.prepareStatement("select 1 from dual");
      final Statement ustmt1=((DelegatingStatement)stmt1).getInnermostDelegate();
      stmt1.close();
      final Statement stmt2=conn.prepareStatement("select 1 from dual");
      final Statement ustmt2=((DelegatingStatement)stmt2).getInnermostDelegate();
      stmt2.close();
      assertSame(ustmt1,ustmt2);
    }
   }
  /** 
 * Verifies that executing close() on an already closed DelegatingStatement that wraps a PoolablePreparedStatement does not "re-close" the PPS (which could be in use by another client - see DBCP-414).
 */
  @Test public void testMultipleClose() throws Exception {
    final DataSource ds=createPDS();
    PreparedStatement stmt1=null;
    final Connection conn=ds.getConnection();
    stmt1=conn.prepareStatement("select 1 from dual");
    final PoolablePreparedStatement<?> pps1=getPoolablePreparedStatement(stmt1);
    conn.close();
    assertTrue(stmt1.isClosed());
    stmt1.close();
    assertTrue(stmt1.isClosed());
    final Connection conn2=ds.getConnection();
    final PreparedStatement stmt2=conn2.prepareStatement("select 1 from dual");
    Assert.assertSame(pps1,getPoolablePreparedStatement(stmt2));
    stmt1.close();
    assertTrue(!stmt2.isClosed());
    stmt2.executeQuery();
    conn2.close();
    assertTrue(stmt1.isClosed());
    assertTrue(stmt2.isClosed());
  }
  private PoolablePreparedStatement<?> getPoolablePreparedStatement(  Statement s){
    while (s != null) {
      if (s instanceof PoolablePreparedStatement) {
        return (PoolablePreparedStatement<?>)s;
      }
      if (s instanceof DelegatingPreparedStatement) {
        s=((DelegatingPreparedStatement)s).getDelegate();
      }
 else {
        return null;
      }
    }
    return null;
  }
  private DataSource createPDS() throws Exception {
    DriverManager.registerDriver(new TesterDriver());
    final ConnectionFactory connFactory=new DriverManagerConnectionFactory("jdbc:apache:commons:testdriver","u1","p1");
    final PoolableConnectionFactory pcf=new PoolableConnectionFactory(connFactory,null);
    pcf.setPoolStatements(true);
    pcf.setDefaultReadOnly(Boolean.FALSE);
    pcf.setDefaultAutoCommit(Boolean.TRUE);
    final ObjectPool<PoolableConnection> connPool=new GenericObjectPool<>(pcf);
    pcf.setPool(connPool);
    return new PoolingDataSource<>(connPool);
  }
  @Test public void testCallableStatementPooling() throws Exception {
    DriverManager.registerDriver(new TesterDriver());
    final ConnectionFactory connFactory=new DriverManagerConnectionFactory("jdbc:apache:commons:testdriver","u1","p1");
    final ObjectName oName=new ObjectName("UnitTests:DataSource=test");
    final PoolableConnectionFactory pcf=new PoolableConnectionFactory(connFactory,oName);
    pcf.setPoolStatements(true);
    pcf.setDefaultReadOnly(Boolean.FALSE);
    pcf.setDefaultAutoCommit(Boolean.TRUE);
    final GenericObjectPoolConfig<PoolableConnection> config=new GenericObjectPoolConfig<>();
    config.setJmxNameBase("UnitTests:DataSource=test,connectionpool=connections");
    config.setJmxNamePrefix("");
    final ObjectPool<PoolableConnection> connPool=new GenericObjectPool<>(pcf,config);
    pcf.setPool(connPool);
    final PoolingDataSource<?> ds=new PoolingDataSource<>(connPool);
    try (Connection conn=ds.getConnection()){
      final Statement stmt1=conn.prepareStatement("select 1 from dual");
      final Statement ustmt1=((DelegatingStatement)stmt1).getInnermostDelegate();
      final Statement cstmt1=conn.prepareCall("{call home}");
      final Statement ucstmt1=((DelegatingStatement)cstmt1).getInnermostDelegate();
      stmt1.close();
      cstmt1.close();
      final Statement stmt2=conn.prepareStatement("select 1 from dual");
      final Statement ustmt2=((DelegatingStatement)stmt2).getInnermostDelegate();
      final Statement cstmt2=conn.prepareCall("{call home}");
      final Statement ucstmt2=((DelegatingStatement)cstmt2).getInnermostDelegate();
      stmt2.close();
      cstmt2.close();
      assertSame(ustmt1,ustmt2);
      assertSame(ucstmt1,ucstmt2);
      final Statement stmt3=conn.prepareCall("select 1 from dual");
      final Statement ustmt3=((DelegatingStatement)stmt3).getInnermostDelegate();
      stmt3.close();
      assertNotSame(ustmt1,ustmt3);
      assertNotSame(ustmt3,ucstmt1);
    }
     ds.close();
  }
  @Test public void testClosePool() throws Exception {
    DriverManager.registerDriver(new TesterDriver());
    final ConnectionFactory connFactory=new DriverManagerConnectionFactory("jdbc:apache:commons:testdriver","u1","p1");
    final PoolableConnectionFactory pcf=new PoolableConnectionFactory(connFactory,null);
    pcf.setPoolStatements(true);
    pcf.setDefaultReadOnly(Boolean.FALSE);
    pcf.setDefaultAutoCommit(Boolean.TRUE);
    final ObjectPool<PoolableConnection> connPool=new GenericObjectPool<>(pcf);
    pcf.setPool(connPool);
    final PoolingDataSource<?> ds=new PoolingDataSource<>(connPool);
    ((PoolingDataSource<?>)ds).setAccessToUnderlyingConnectionAllowed(true);
    final Connection conn=ds.getConnection();
    try (Statement s=conn.prepareStatement("select 1 from dual")){
    }
     final Connection poolableConnection=((DelegatingConnection<?>)conn).getDelegate();
    final Connection poolingConnection=((DelegatingConnection<?>)poolableConnection).getDelegate();
    poolingConnection.close();
    try (PreparedStatement ps=conn.prepareStatement("select 1 from dual")){
      fail("Expecting SQLException");
    }
 catch (    final SQLException ex) {
      assertTrue(ex.getMessage().endsWith("invalid PoolingConnection."));
    }
    ds.close();
  }
  @Test public void testBatchUpdate() throws Exception {
    DriverManager.registerDriver(new TesterDriver());
    final ConnectionFactory connFactory=new DriverManagerConnectionFactory("jdbc:apache:commons:testdriver","u1","p1");
    final PoolableConnectionFactory pcf=new PoolableConnectionFactory(connFactory,null);
    pcf.setPoolStatements(true);
    pcf.setDefaultReadOnly(Boolean.FALSE);
    pcf.setDefaultAutoCommit(Boolean.TRUE);
    final ObjectPool<PoolableConnection> connPool=new GenericObjectPool<>(pcf);
    pcf.setPool(connPool);
    final PoolingDataSource<?> ds=new PoolingDataSource<>(connPool);
    final Connection conn=ds.getConnection();
    final PreparedStatement ps=conn.prepareStatement("select 1 from dual");
    final Statement inner=((DelegatingPreparedStatement)ps).getInnermostDelegate();
    ps.addBatch();
    ps.close();
    conn.close();
    Assert.assertFalse(inner.isClosed());
    ds.close();
  }
}
