/** 
 * TestSuite for ManagedDataSource with an active transaction in progress.
 */
public class TestManagedDataSourceInTx extends TestManagedDataSource {
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    transactionManager.begin();
  }
  @Override @After public void tearDown() throws Exception {
    if (transactionManager.getTransaction() != null) {
      transactionManager.commit();
    }
    super.tearDown();
  }
  /** 
 * @see #testSharedConnection()
 */
  @Override @Test public void testManagedConnectionEqualsFail() throws Exception {
  }
  @Override @Test public void testNestedConnections(){
  }
  @Override @Test public void testConnectionsAreDistinct() throws Exception {
    final Connection[] conn=new Connection[getMaxTotal()];
    for (int i=0; i < conn.length; i++) {
      conn[i]=newConnection();
      for (int j=0; j < i; j++) {
        Assert.assertNotSame(conn[j],conn[i]);
        Assert.assertNotEquals(conn[j],conn[i]);
        Assert.assertEquals(((DelegatingConnection<?>)conn[j]).getInnermostDelegateInternal(),((DelegatingConnection<?>)conn[i]).getInnermostDelegateInternal());
      }
    }
    for (    final Connection element : conn) {
      element.close();
    }
  }
  @Override @Test public void testHashCode() throws Exception {
    final Connection conn1=newConnection();
    assertNotNull(conn1);
    final Connection conn2=newConnection();
    assertNotNull(conn2);
    Assert.assertNotEquals(conn1.hashCode(),conn2.hashCode());
  }
  @Override @Test public void testMaxTotal() throws Exception {
    final Transaction[] transactions=new Transaction[getMaxTotal()];
    final Connection[] c=new Connection[getMaxTotal()];
    for (int i=0; i < c.length; i++) {
      c[i]=newConnection();
      assertNotNull(c[i]);
      transactions[i]=transactionManager.suspend();
      assertNotNull(transactions[i]);
      transactionManager.begin();
    }
    try {
      newConnection();
      fail("Allowed to open more than DefaultMaxTotal connections.");
    }
 catch (    final java.sql.SQLException e) {
    }
 finally {
      transactionManager.commit();
      for (int i=0; i < c.length; i++) {
        transactionManager.resume(transactions[i]);
        c[i].close();
        transactionManager.commit();
      }
    }
  }
  @Override @Test public void testClearWarnings() throws Exception {
    Connection connection=newConnection();
    assertNotNull(connection);
    final CallableStatement statement=connection.prepareCall("warning");
    assertNotNull(connection.getWarnings());
    final Connection sharedConnection=newConnection();
    assertNotNull(sharedConnection.getWarnings());
    connection.close();
    connection=newConnection();
    assertNotNull(connection.getWarnings());
    assertNotNull(sharedConnection.getWarnings());
    statement.close();
    connection.close();
    sharedConnection.close();
  }
  @Override @Test public void testSharedConnection() throws Exception {
    final DelegatingConnection<?> connectionA=(DelegatingConnection<?>)newConnection();
    final DelegatingConnection<?> connectionB=(DelegatingConnection<?>)newConnection();
    assertFalse(connectionA.equals(connectionB));
    assertFalse(connectionB.equals(connectionA));
    assertTrue(connectionA.innermostDelegateEquals(connectionB.getInnermostDelegate()));
    assertTrue(connectionB.innermostDelegateEquals(connectionA.getInnermostDelegate()));
    connectionA.close();
    connectionB.close();
  }
  @Test public void testSharedTransactionConversion() throws Exception {
    final DelegatingConnection<?> connectionA=(DelegatingConnection<?>)newConnection();
    final DelegatingConnection<?> connectionB=(DelegatingConnection<?>)newConnection();
    assertFalse(connectionA.equals(connectionB));
    assertFalse(connectionB.equals(connectionA));
    assertTrue(connectionA.innermostDelegateEquals(connectionB.getInnermostDelegate()));
    assertTrue(connectionB.innermostDelegateEquals(connectionA.getInnermostDelegate()));
    transactionManager.commit();
    connectionA.getAutoCommit();
    connectionB.getAutoCommit();
    assertFalse(connectionA.equals(connectionB));
    assertFalse(connectionB.equals(connectionA));
    assertFalse(connectionA.innermostDelegateEquals(connectionB.getInnermostDelegate()));
    assertFalse(connectionB.innermostDelegateEquals(connectionA.getInnermostDelegate()));
    transactionManager.begin();
    connectionA.getAutoCommit();
    connectionB.getAutoCommit();
    assertFalse(connectionA.equals(connectionB));
    assertFalse(connectionB.equals(connectionA));
    assertTrue(connectionA.innermostDelegateEquals(connectionB.getInnermostDelegate()));
    assertTrue(connectionB.innermostDelegateEquals(connectionA.getInnermostDelegate()));
    connectionA.close();
    connectionB.close();
  }
  @Test public void testCloseInTransaction() throws Exception {
    final DelegatingConnection<?> connectionA=(DelegatingConnection<?>)newConnection();
    final DelegatingConnection<?> connectionB=(DelegatingConnection<?>)newConnection();
    assertFalse(connectionA.equals(connectionB));
    assertFalse(connectionB.equals(connectionA));
    assertTrue(connectionA.innermostDelegateEquals(connectionB.getInnermostDelegate()));
    assertTrue(connectionB.innermostDelegateEquals(connectionA.getInnermostDelegate()));
    connectionA.close();
    connectionB.close();
    final Connection connection=newConnection();
    assertFalse("Connection should be open",connection.isClosed());
    connection.close();
    assertTrue("Connection should be closed",connection.isClosed());
  }
  @Override @Test public void testAutoCommitBehavior() throws Exception {
    final Connection connection=newConnection();
    assertFalse("Auto-commit should be disabled",connection.getAutoCommit());
    try {
      connection.setAutoCommit(true);
      fail("setAutoCommit method should be disabled while enlisted in a transaction");
    }
 catch (    final SQLException e) {
    }
    assertFalse("Auto-commit should be disabled",connection.getAutoCommit());
    connection.close();
  }
  @Test public void testCommit() throws Exception {
    final Connection connection=newConnection();
    assertFalse("Connection should be open",connection.isClosed());
    try {
      connection.commit();
      fail("commit method should be disabled while enlisted in a transaction");
    }
 catch (    final SQLException e) {
    }
    assertFalse("Connection should be open",connection.isClosed());
    connection.close();
  }
  @Test public void testReadOnly() throws Exception {
    final Connection connection=newConnection();
    assertTrue("Connection be read-only",connection.isReadOnly());
    try {
      connection.setReadOnly(true);
      fail("setReadOnly method should be disabled while enlisted in a transaction");
    }
 catch (    final SQLException e) {
    }
    assertTrue("Connection be read-only",connection.isReadOnly());
    try {
      connection.setReadOnly(false);
      fail("setReadOnly method should be disabled while enlisted in a transaction");
    }
 catch (    final SQLException e) {
    }
    assertTrue("Connection be read-only",connection.isReadOnly());
    connection.close();
  }
  @Override protected void assertBackPointers(  final Connection conn,  final Statement statement) throws SQLException {
    assertFalse(conn.isClosed());
    assertFalse(isClosed(statement));
    assertSame("statement.getConnection() should return the exact same connection instance that was used to create the statement",conn,statement.getConnection());
    final ResultSet resultSet=statement.getResultSet();
    assertFalse(isClosed(resultSet));
    assertSame("resultSet.getStatement() should return the exact same statement instance that was used to create the result set",statement,resultSet.getStatement());
    final ResultSet executeResultSet=statement.executeQuery("select * from dual");
    assertFalse(isClosed(executeResultSet));
    assertSame("resultSet.getStatement() should return the exact same statement instance that was used to create the result set",statement,executeResultSet.getStatement());
    final ResultSet keysResultSet=statement.getGeneratedKeys();
    assertFalse(isClosed(keysResultSet));
    assertSame("resultSet.getStatement() should return the exact same statement instance that was used to create the result set",statement,keysResultSet.getStatement());
    ResultSet preparedResultSet=null;
    if (statement instanceof PreparedStatement) {
      final PreparedStatement preparedStatement=(PreparedStatement)statement;
      preparedResultSet=preparedStatement.executeQuery();
      assertFalse(isClosed(preparedResultSet));
      assertSame("resultSet.getStatement() should return the exact same statement instance that was used to create the result set",statement,preparedResultSet.getStatement());
    }
    resultSet.getStatement().getConnection().close();
  }
  @Override @Test public void testConnectionReturnOnCommit() throws Exception {
    return;
  }
}
