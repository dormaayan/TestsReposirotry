/** 
 * TestSuite for BasicDataSource with prepared statement pooling enabled
 */
public class TestPStmtPoolingBasicDataSource extends TestBasicDataSource {
  @Override @Before public void setUp() throws Exception {
    super.setUp();
    ds.setPoolPreparedStatements(true);
    ds.setMaxOpenPreparedStatements(2);
  }
  @Test public void testPreparedStatementPooling() throws Exception {
    final Connection conn=getConnection();
    assertNotNull(conn);
    final PreparedStatement stmt1=conn.prepareStatement("select 'a' from dual");
    assertNotNull(stmt1);
    final PreparedStatement stmt2=conn.prepareStatement("select 'b' from dual");
    assertNotNull(stmt2);
    assertTrue(stmt1 != stmt2);
    PreparedStatement stmt3=null;
    try (PreparedStatement ps=conn.prepareStatement("select 'c' from dual")){
      fail("expected SQLException");
    }
 catch (    final SQLException e) {
    }
    stmt2.close();
    stmt3=conn.prepareStatement("select 'c' from dual");
    assertNotNull(stmt3);
    assertTrue(stmt3 != stmt1);
    assertTrue(stmt3 != stmt2);
    stmt1.close();
    final PreparedStatement stmt4=conn.prepareStatement("select 'a' from dual");
    assertNotNull(stmt4);
  }
  /** 
 * Verifies that the prepared statement pool behaves as an LRU cache, closing least-recently-used statements idle in the pool to make room for new ones if necessary.
 */
  @Test public void testLRUBehavior() throws Exception {
    ds.setMaxOpenPreparedStatements(3);
    final Connection conn=getConnection();
    assertNotNull(conn);
    final PreparedStatement stmt1=conn.prepareStatement("select 'a' from dual");
    final PreparedStatement inner1=(PreparedStatement)((DelegatingPreparedStatement)stmt1).getInnermostDelegate();
    final PreparedStatement stmt2=conn.prepareStatement("select 'b' from dual");
    final PreparedStatement inner2=(PreparedStatement)((DelegatingPreparedStatement)stmt2).getInnermostDelegate();
    final PreparedStatement stmt3=conn.prepareStatement("select 'c' from dual");
    final PreparedStatement inner3=(PreparedStatement)((DelegatingPreparedStatement)stmt3).getInnermostDelegate();
    stmt1.close();
    Thread.sleep(100);
    stmt2.close();
    Thread.sleep(100);
    stmt3.close();
    final PreparedStatement stmt4=conn.prepareStatement("select 'd' from dual");
    assertNotNull(stmt4);
    try {
      inner1.clearParameters();
      fail("expecting SQLExcption - statement should be closed");
    }
 catch (    final SQLException ex) {
    }
    inner2.clearParameters();
    inner3.clearParameters();
    final PreparedStatement stmt5=conn.prepareStatement("select 'a' from dual");
    final PreparedStatement inner5=(PreparedStatement)((DelegatingPreparedStatement)stmt5).getInnermostDelegate();
    assertNotSame(inner5,inner1);
    try {
      inner2.clearParameters();
      fail("expecting SQLExcption - statement should be closed");
    }
 catch (    final SQLException ex) {
    }
    inner3.clearParameters();
  }
  @Test public void testPStmtCatalog() throws Exception {
    final Connection conn=getConnection();
    conn.setCatalog("catalog1");
    final DelegatingPreparedStatement stmt1=(DelegatingPreparedStatement)conn.prepareStatement("select 'a' from dual");
    final TesterPreparedStatement inner1=(TesterPreparedStatement)stmt1.getInnermostDelegate();
    assertEquals("catalog1",inner1.getCatalog());
    stmt1.close();
    conn.setCatalog("catalog2");
    final DelegatingPreparedStatement stmt2=(DelegatingPreparedStatement)conn.prepareStatement("select 'a' from dual");
    final TesterPreparedStatement inner2=(TesterPreparedStatement)stmt2.getInnermostDelegate();
    assertEquals("catalog2",inner2.getCatalog());
    stmt2.close();
    conn.setCatalog("catalog1");
    final DelegatingPreparedStatement stmt3=(DelegatingPreparedStatement)conn.prepareStatement("select 'a' from dual");
    final TesterPreparedStatement inner3=(TesterPreparedStatement)stmt3.getInnermostDelegate();
    assertEquals("catalog1",inner3.getCatalog());
    stmt3.close();
    assertNotSame(inner1,inner2);
    assertSame(inner1,inner3);
  }
  @Test public void testPStmtPoolingWithNoClose() throws Exception {
    ds.setMaxTotal(1);
    ds.setMaxIdle(1);
    ds.setAccessToUnderlyingConnectionAllowed(true);
    final Connection conn1=getConnection();
    assertNotNull(conn1);
    assertEquals(1,ds.getNumActive());
    assertEquals(0,ds.getNumIdle());
    final PreparedStatement stmt1=conn1.prepareStatement("select 'a' from dual");
    assertNotNull(stmt1);
    final Statement inner1=((DelegatingPreparedStatement)stmt1).getInnermostDelegate();
    assertNotNull(inner1);
    stmt1.close();
    final Connection conn2=conn1;
    assertNotNull(conn2);
    assertEquals(1,ds.getNumActive());
    assertEquals(0,ds.getNumIdle());
    final PreparedStatement stmt2=conn2.prepareStatement("select 'a' from dual");
    assertNotNull(stmt2);
    final Statement inner2=((DelegatingPreparedStatement)stmt2).getInnermostDelegate();
    assertNotNull(inner2);
    assertSame(inner1,inner2);
  }
  @Test public void testPStmtPoolingAcrossClose() throws Exception {
    ds.setMaxTotal(1);
    ds.setMaxIdle(1);
    ds.setAccessToUnderlyingConnectionAllowed(true);
    final Connection conn1=getConnection();
    assertNotNull(conn1);
    assertEquals(1,ds.getNumActive());
    assertEquals(0,ds.getNumIdle());
    final PreparedStatement stmt1=conn1.prepareStatement("select 'a' from dual");
    assertNotNull(stmt1);
    final Statement inner1=((DelegatingPreparedStatement)stmt1).getInnermostDelegate();
    assertNotNull(inner1);
    stmt1.close();
    conn1.close();
    assertEquals(0,ds.getNumActive());
    assertEquals(1,ds.getNumIdle());
    final Connection conn2=getConnection();
    assertNotNull(conn2);
    assertEquals(1,ds.getNumActive());
    assertEquals(0,ds.getNumIdle());
    final PreparedStatement stmt2=conn2.prepareStatement("select 'a' from dual");
    assertNotNull(stmt2);
    final Statement inner2=((DelegatingPreparedStatement)stmt2).getInnermostDelegate();
    assertNotNull(inner2);
    assertSame(inner1,inner2);
  }
  /** 
 * Tests high-concurrency contention for connections and pooled prepared statements. DBCP-414
 */
  @Test public void testMultipleThreads1() throws Exception {
    ds.setMaxWaitMillis(-1);
    ds.setMaxTotal(5);
    ds.setMaxOpenPreparedStatements(-1);
    multipleThreads(5,false,false,-1,3,100,10000);
  }
}
