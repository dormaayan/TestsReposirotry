/** 
 * TestSuite for ManagedConnection.
 */
public class TestManagedConnection {
  protected PoolingDataSource<PoolableConnection> ds=null;
  private GenericObjectPool<PoolableConnection> pool=null;
  protected TransactionManager transactionManager;
  @Before public void setUp() throws Exception {
    transactionManager=new TransactionManagerImpl();
    final Properties properties=new Properties();
    properties.setProperty("user","userName");
    properties.setProperty("password","password");
    final ConnectionFactory connectionFactory=new DriverConnectionFactory(new TesterDriver(),"jdbc:apache:commons:testdriver",properties);
    final XAConnectionFactory xaConnectionFactory=new UncooperativeLocalXAConnectionFactory(transactionManager,connectionFactory);
    final PoolableConnectionFactory factory=new PoolableConnectionFactory(xaConnectionFactory,null);
    factory.setValidationQuery("SELECT DUMMY FROM DUAL");
    factory.setDefaultReadOnly(Boolean.TRUE);
    factory.setDefaultAutoCommit(Boolean.TRUE);
    pool=new GenericObjectPool<>(factory);
    factory.setPool(pool);
    pool.setMaxTotal(10);
    pool.setMaxWaitMillis(100);
    ds=new ManagedDataSource<>(pool,xaConnectionFactory.getTransactionRegistry());
    ds.setAccessToUnderlyingConnectionAllowed(true);
  }
  @After public void tearDown() throws Exception {
    pool.close();
  }
  public Connection getConnection() throws Exception {
    return ds.getConnection();
  }
  @Test public void testConnectionReturnOnErrorWhenEnlistingXAResource() throws Exception {
    transactionManager.begin();
    try {
      final DelegatingConnection<?> connectionA=(DelegatingConnection<?>)getConnection();
      connectionA.close();
    }
 catch (    final SQLException e) {
    }
    transactionManager.commit();
    assertEquals(1,pool.getBorrowedCount());
    assertEquals(1,pool.getDestroyedCount());
    assertEquals(0,pool.getNumActive());
  }
private class UncooperativeLocalXAConnectionFactory extends LocalXAConnectionFactory {
    public UncooperativeLocalXAConnectionFactory(    final TransactionManager transactionManager,    final ConnectionFactory connectionFactory){
      super(transactionManager,connectionFactory);
      try {
        final Field field=LocalXAConnectionFactory.class.getDeclaredField("transactionRegistry");
        field.setAccessible(true);
        field.set(this,new UncooperativeTransactionRegistry(transactionManager));
      }
 catch (      final Exception e) {
        e.printStackTrace();
      }
    }
  }
private class UncooperativeTransactionRegistry extends TransactionRegistry {
    public UncooperativeTransactionRegistry(    final TransactionManager transactionManager){
      super(transactionManager);
    }
    @Override public TransactionContext getActiveTransactionContext() throws SQLException {
      try {
        return new TransactionContext(this,new UncooperativeTransaction(transactionManager.getTransaction()));
      }
 catch (      final SystemException e) {
        return null;
      }
    }
  }
  /** 
 * Transaction that always fails enlistResource.
 */
private class UncooperativeTransaction implements Transaction {
    private final Transaction wrappedTransaction;
    public UncooperativeTransaction(    final Transaction transaction){
      this.wrappedTransaction=transaction;
    }
    @Override public void commit() throws HeuristicMixedException, HeuristicRollbackException, RollbackException, SecurityException, SystemException {
      wrappedTransaction.commit();
    }
    @Override public boolean delistResource(    final XAResource arg0,    final int arg1) throws IllegalStateException, SystemException {
      return wrappedTransaction.delistResource(arg0,arg1);
    }
    @Override public int getStatus() throws SystemException {
      return wrappedTransaction.getStatus();
    }
    @Override public void registerSynchronization(    final Synchronization arg0) throws IllegalStateException, RollbackException, SystemException {
      wrappedTransaction.registerSynchronization(arg0);
    }
    @Override public void rollback() throws IllegalStateException, SystemException {
      wrappedTransaction.rollback();
    }
    @Override public void setRollbackOnly() throws IllegalStateException, SystemException {
      wrappedTransaction.setRollbackOnly();
    }
    @Override public synchronized boolean enlistResource(    final XAResource xaRes){
      return false;
    }
  }
}
