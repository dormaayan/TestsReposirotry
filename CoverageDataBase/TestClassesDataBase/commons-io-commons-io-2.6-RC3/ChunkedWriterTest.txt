public class ChunkedWriterTest {
  @Test public void write_four_chunks() throws Exception {
    final AtomicInteger numWrites=new AtomicInteger();
    final OutputStreamWriter osw=getOutputStreamWriter(numWrites);
    final ChunkedWriter chunked=new ChunkedWriter(osw,10);
    chunked.write("0123456789012345678901234567891".toCharArray());
    chunked.flush();
    assertEquals(4,numWrites.get());
    chunked.close();
  }
  @Test public void write_two_chunks_default_constructor() throws Exception {
    final AtomicInteger numWrites=new AtomicInteger();
    final OutputStreamWriter osw=getOutputStreamWriter(numWrites);
    final ChunkedWriter chunked=new ChunkedWriter(osw);
    chunked.write(new char[1024 * 4 + 1]);
    chunked.flush();
    assertEquals(2,numWrites.get());
    chunked.close();
  }
  private OutputStreamWriter getOutputStreamWriter(  final AtomicInteger numWrites){
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    return new OutputStreamWriter(baos){
      @Override public void write(      final char[] cbuf,      final int off,      final int len) throws IOException {
        numWrites.incrementAndGet();
        super.write(cbuf,off,len);
      }
    }
;
  }
  @Test(expected=IllegalArgumentException.class) public void negative_chunksize_not_permitted() throws Exception {
    (new ChunkedWriter(new OutputStreamWriter(new ByteArrayOutputStream()),0)).close();
    ;
  }
}
