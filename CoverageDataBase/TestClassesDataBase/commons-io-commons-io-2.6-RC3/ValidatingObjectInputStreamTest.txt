public class ValidatingObjectInputStreamTest extends ClosingBase {
  private MockSerializedClass testObject;
  private InputStream testStream;
  static private final ClassNameMatcher ALWAYS_TRUE=new ClassNameMatcher(){
    @Override public boolean matches(    final String className){
      return true;
    }
  }
;
  @Override @Before public void setup() throws IOException {
    testObject=new MockSerializedClass(UUID.randomUUID().toString());
    final ByteArrayOutputStream bos=willClose(new ByteArrayOutputStream());
    final ObjectOutputStream oos=willClose(new ObjectOutputStream(bos));
    oos.writeObject(testObject);
    testStream=willClose(new ByteArrayInputStream(bos.toByteArray()));
  }
  private void assertSerialization(  final ObjectInputStream ois) throws ClassNotFoundException, IOException {
    final MockSerializedClass result=(MockSerializedClass)(ois.readObject());
    assertEquals(testObject,result);
  }
  @Test(expected=InvalidClassException.class) public void noAccept() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)));
  }
  @Test public void exceptionIncludesClassName() throws Exception {
    try {
      assertSerialization(willClose(new ValidatingObjectInputStream(testStream)));
      fail("Expected an InvalidClassException");
    }
 catch (    final InvalidClassException ice) {
      final String name=MockSerializedClass.class.getName();
      assertTrue("Expecting message to contain " + name,ice.getMessage().contains(name));
    }
  }
  @Test public void acceptCustomMatcher() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(ALWAYS_TRUE));
  }
  @Test(expected=InvalidClassException.class) public void rejectCustomMatcher() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(MockSerializedClass.class).reject(ALWAYS_TRUE));
  }
  @Test public void acceptPattern() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(Pattern.compile(".*MockSerializedClass.*")));
  }
  @Test(expected=InvalidClassException.class) public void rejectPattern() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(MockSerializedClass.class).reject(Pattern.compile("org.*")));
  }
  @Test public void acceptWildcard() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept("org.apache.commons.io.*"));
  }
  @Test(expected=InvalidClassException.class) public void rejectWildcard() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(MockSerializedClass.class).reject("org.*"));
  }
  @Test(expected=InvalidClassException.class) public void ourTestClassNotAccepted() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(Integer.class));
  }
  @Test public void ourTestClassOnlyAccepted() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(MockSerializedClass.class));
  }
  @Test public void ourTestClassAcceptedFirst() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(MockSerializedClass.class,Integer.class));
  }
  @Test public void ourTestClassAcceptedSecond() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(Integer.class,MockSerializedClass.class));
  }
  @Test public void ourTestClassAcceptedFirstWildcard() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept("*MockSerializedClass","*Integer"));
  }
  @Test public void ourTestClassAcceptedSecondWildcard() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept("*Integer","*MockSerializedClass"));
  }
  @Test(expected=InvalidClassException.class) public void reject() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(Long.class).reject(MockSerializedClass.class,Integer.class));
  }
  @Test(expected=InvalidClassException.class) public void rejectPrecedence() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).accept(MockSerializedClass.class).reject(MockSerializedClass.class,Integer.class));
  }
  @Test(expected=InvalidClassException.class) public void rejectOnly() throws Exception {
    assertSerialization(willClose(new ValidatingObjectInputStream(testStream)).reject(Integer.class));
  }
  @Test(expected=RuntimeException.class) public void customInvalidMethod() throws Exception {
class CustomVOIS extends ValidatingObjectInputStream {
      CustomVOIS(      final InputStream is) throws IOException {
        super(is);
      }
      @Override protected void invalidClassNameFound(      final String className) throws InvalidClassException {
        throw new RuntimeException("Custom exception");
      }
    }
    ;
    assertSerialization(willClose(new CustomVOIS(testStream)).reject(Integer.class));
  }
}
