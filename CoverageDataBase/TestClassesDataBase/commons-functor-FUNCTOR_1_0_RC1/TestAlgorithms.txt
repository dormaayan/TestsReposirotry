/** 
 * @version $Revision$ $Date$
 * @author Rodney Waldhoff
 */
@SuppressWarnings("unchecked") public class TestAlgorithms {
  @Before public void setUp() throws Exception {
    list=new ArrayList();
    evens=new ArrayList();
    doubled=new ArrayList();
    listWithDuplicates=new ArrayList();
    sum=0;
    for (int i=0; i < 10; i++) {
      list.add(new Integer(i));
      doubled.add(new Integer(i * 2));
      listWithDuplicates.add(new Integer(i));
      listWithDuplicates.add(new Integer(i));
      sum+=i;
      if (i % 2 == 0) {
        evens.add(new Integer(i));
      }
    }
  }
  @After public void tearDown() throws Exception {
    list=null;
    evens=null;
    listWithDuplicates=null;
    sum=0;
  }
  @Test public void testDetect(){
    assertEquals(new Integer(3),FindWithinGenerator.instance().evaluate(IteratorToGeneratorAdapter.adapt(list.iterator()),equalsThree));
    try {
      FindWithinGenerator.instance().evaluate(IteratorToGeneratorAdapter.adapt(list.iterator()),equalsTwentyThree);
      fail("Expected NoSuchElementException");
    }
 catch (    NoSuchElementException e) {
    }
  }
  @Test public void testDetectIfNone(){
    assertEquals(new Integer(3),new FindWithinGenerator("Xyzzy").evaluate(IteratorToGeneratorAdapter.adapt(list.iterator()),equalsThree));
    assertEquals("Xyzzy",new FindWithinGenerator("Xyzzy").evaluate(IteratorToGeneratorAdapter.adapt(list.iterator()),equalsTwentyThree));
  }
  @Test public void testRun(){
    Summer summer=new Summer();
    IteratorToGeneratorAdapter.adapt(list.iterator()).run(summer);
    assertEquals(sum,summer.sum);
  }
  @Test public void testSelect1(){
    Collection result=new FilteredGenerator(IteratorToGeneratorAdapter.adapt(list.iterator()),isEven).toCollection();
    assertNotNull(result);
    assertEquals(evens,result);
  }
  @Test public void testSelect2(){
    ArrayList result=new ArrayList();
    assertSame(result,new FilteredGenerator(IteratorToGeneratorAdapter.adapt(list.iterator()),isEven).to(result));
    assertEquals(evens,result);
  }
  @Test public void testReject1(){
    Collection result=new FilteredGenerator(IteratorToGeneratorAdapter.adapt(list.iterator()),new UnaryNot(isOdd)).toCollection();
    assertNotNull(result);
    assertEquals(evens,result);
  }
  @Test public void testReject2(){
    ArrayList result=new ArrayList();
    assertSame(result,new FilteredGenerator(IteratorToGeneratorAdapter.adapt(list.iterator()),new UnaryNot(isOdd)).to(result));
    assertEquals(evens,result);
  }
  @Test public void testRetain(){
    RetainMatching.instance().run(list.iterator(),isEven);
    assertEquals(evens,list);
  }
  @Test public void testRemove(){
    RemoveMatching.instance().run(list.iterator(),isOdd);
    assertEquals(evens,list);
  }
  @Test public void testTransform(){
    InPlaceTransform.instance().run(list.listIterator(),new UnaryFunction(){
      public Object evaluate(      Object obj){
        return new Integer(((Number)obj).intValue() * 2);
      }
    }
);
    assertEquals(doubled,list);
  }
  @Test public void testApplyToGenerator(){
    Generator gen=new IntegerRange(1,5);
    Summer summer=new Summer();
    new TransformedGenerator(gen,new Doubler()).run(summer);
    assertEquals(2 * (1 + 2 + 3+ 4),summer.sum);
  }
  @Test public void testApply(){
    Collection result=new TransformedGenerator(IteratorToGeneratorAdapter.adapt(list.iterator()),new Doubler()).toCollection();
    assertNotNull(result);
    assertEquals(doubled,result);
  }
  @Test public void testApply2(){
    Set set=new HashSet();
    assertSame(set,new TransformedGenerator(IteratorToGeneratorAdapter.adapt(list.iterator()),Identity.instance()).to(set));
    assertEquals(list.size(),set.size());
    for (Iterator iter=list.iterator(); iter.hasNext(); ) {
      assertTrue(set.contains(iter.next()));
    }
  }
  @Test public void testApply3(){
    Set set=new HashSet();
    assertSame(set,new TransformedGenerator(IteratorToGeneratorAdapter.adapt(listWithDuplicates.iterator()),Identity.instance()).to(set));
    assertTrue(listWithDuplicates.size() > set.size());
    for (Iterator iter=listWithDuplicates.iterator(); iter.hasNext(); ) {
      assertTrue(set.contains(iter.next()));
    }
  }
  @Test public void testContains(){
    assertTrue(GeneratorContains.instance().test(IteratorToGeneratorAdapter.adapt(list.iterator()),equalsThree));
    assertFalse(GeneratorContains.instance().test(IteratorToGeneratorAdapter.adapt(list.iterator()),equalsTwentyThree));
  }
  @Test public void testFoldLeft(){
    FoldLeft foldLeft=new FoldLeft(new BinaryFunction(){
      public Object evaluate(      Object a,      Object b){
        return new Integer(((Number)a).intValue() + ((Number)b).intValue());
      }
    }
);
    assertEquals(new Integer(sum),foldLeft.evaluate(IteratorToGeneratorAdapter.adapt(list.iterator())));
    assertEquals(new Integer(sum),foldLeft.evaluate(IteratorToGeneratorAdapter.adapt(list.iterator()),new Integer(0)));
  }
  @Test public void testFoldRight(){
    FoldRight foldRight=new FoldRight(new BinaryFunction(){
      public Object evaluate(      Object left,      Object right){
        StringBuffer buf=left instanceof StringBuffer ? (StringBuffer)left : new StringBuffer().append(left);
        return buf.append(right);
      }
    }
);
    assertEquals("0123456789",foldRight.evaluate(IteratorToGeneratorAdapter.adapt(list.iterator())).toString());
    assertEquals("0123456789x",foldRight.evaluate(IteratorToGeneratorAdapter.adapt(list.iterator()),"x").toString());
  }
  @Test public void testDoUntil(){
    for (int i=0; i < 3; i++) {
      Counter counter=new Counter();
      new DoUntil(counter,new Offset(i)).run();
      assertEquals(i + 1,counter.count);
    }
  }
  @Test public void testDoWhile(){
    for (int i=0; i < 3; i++) {
      Counter counter=new Counter();
      new DoWhile(counter,new Limit(i)).run();
      assertEquals(i + 1,counter.count);
    }
  }
  @Test public void testUntilDo(){
    for (int i=0; i < 3; i++) {
      Counter counter=new Counter();
      new UntilDo(new Offset(i),counter).run();
      assertEquals(i,counter.count);
    }
  }
  @Test public void testWhileDo(){
    for (int i=0; i < 3; i++) {
      Counter counter=new Counter();
      new WhileDo(new Limit(i),counter).run();
      assertEquals(i,counter.count);
    }
  }
  @Test public void testRecurse(){
    assertEquals(new Integer(5),new RecursiveEvaluation(new RecFunc(0,false)).evaluate());
    Function func=(Function)new RecursiveEvaluation(new RecFunc(0,true)).evaluate();
    assertEquals(new Integer(5),func.evaluate());
  }
  /** 
 * Recursive function for test. 
 */
class RecFunc implements Function {
    int times=0;
    boolean returnFunc=false;
    public RecFunc(    int times,    boolean returnFunc){
      this.times=times;
      this.returnFunc=returnFunc;
    }
    public Object evaluate(){
      if (times < 5) {
        return new RecFunc(++times,returnFunc);
      }
 else {
        if (returnFunc) {
          return new Function(){
            public Object evaluate(){
              return new Integer(times);
            }
          }
;
        }
 else {
          return new Integer(times);
        }
      }
    }
  }
  private List list=null;
  private List doubled=null;
  private List evens=null;
  private List listWithDuplicates=null;
  private int sum=0;
  private UnaryPredicate equalsThree=LeftBoundPredicate.bind(IsEqual.instance(),new Integer(3));
  private UnaryPredicate equalsTwentyThree=LeftBoundPredicate.bind(IsEqual.instance(),new Integer(23));
  private UnaryPredicate isEven=new UnaryPredicate(){
    public boolean test(    Object obj){
      return ((Number)obj).intValue() % 2 == 0;
    }
  }
;
  private UnaryPredicate isOdd=new UnaryPredicate(){
    public boolean test(    Object obj){
      return ((Number)obj).intValue() % 2 != 0;
    }
  }
;
static class Counter implements Procedure {
    public void run(){
      count++;
    }
    public int count=0;
  }
static class Summer implements UnaryProcedure {
    public void run(    Object that){
      sum+=((Number)that).intValue();
    }
    public int sum=0;
  }
static class Doubler implements UnaryFunction {
    public Object evaluate(    Object obj){
      return new Integer(2 * ((Number)obj).intValue());
    }
  }
}
