/** 
 * An example of implementing the quicksort sorting algorithm using commons-functor. <p> See the extensive in line comments for details.
 * @version $Revision$ $Date$
 * @author Rodney Waldhoff
 */
@SuppressWarnings("unchecked") public class QuicksortExample {
  @Test public void testSortEmpty(){
    List empty=Collections.EMPTY_LIST;
    List result=quicksort(empty);
    assertTrue("Sorting an empty list should produce an empty list.",result.isEmpty());
  }
  @Test public void testSortSingleElementList(){
    List list=new ArrayList();
    list.add("element");
    List sorted=quicksort(list);
    assertTrue("The quicksort() method should return a distinct list.",list != sorted);
    assertEquals("Sorting a single-element list should produce an equivalent list",list,sorted);
  }
  @Test public void testSortSingleValueList(){
    List list=new ArrayList();
    for (int i=0; i < 10; i++) {
      list.add("element");
    }
    List sorted=quicksort(list);
    assertTrue("The quicksort() method should return a distinct list.",list != sorted);
    assertEquals(list,sorted);
  }
  @Test public void testSortSorted(){
    List list=new ArrayList();
    for (int i=0; i < 10; i++) {
      list.add(new Integer(i));
    }
    List sorted=quicksort(list);
    assertTrue("The quicksort() method should return a distinct list.",list != sorted);
    assertEquals("Sorting an already sorted list should produce an equivalent list",list,sorted);
  }
  @Test public void testSortReversed(){
    List expected=new ArrayList();
    List tosort=new ArrayList();
    for (int i=0; i < 10; i++) {
      expected.add(new Integer(i));
      tosort.add(new Integer(9 - i));
    }
    assertEquals(expected,quicksort(tosort));
  }
  @Test public void testSortShuffled(){
    List expected=new ArrayList();
    for (int i=0; i < 10; i++) {
      expected.add(new Integer(i));
    }
    List tosort=new ArrayList(expected);
    Collections.shuffle(tosort);
    assertEquals(expected,quicksort(tosort));
  }
  @Test public void testSortRandom(){
    Random random=new Random();
    List tosort=new ArrayList();
    for (int i=0; i < 10; i++) {
      tosort.add(new Integer(random.nextInt(10)));
    }
    List expected=new ArrayList(tosort);
    Collections.sort(expected);
    assertEquals(expected,quicksort(tosort));
  }
  private static final int SIZE=1000;
  private static final int COUNT=100;
  @Test public void testTimings(){
    long elapsed=0L;
    Random random=new Random();
    for (int i=0; i < COUNT; i++) {
      List tosort=new ArrayList(SIZE);
      for (int j=0; j < SIZE; j++) {
        tosort.add(new Integer(random.nextInt(SIZE)));
      }
      long start=System.currentTimeMillis();
      quicksort(tosort);
      long stop=System.currentTimeMillis();
      elapsed+=stop - start;
    }
  }
  public List quicksort(  List list){
    return (List)(quicksort.evaluate(list));
  }
  private UnaryFunction quicksort=new ConditionalUnaryFunction(IsEmpty.instance(),new Constant(Collections.EMPTY_LIST),new ListFunction(){
    public Object evaluate(    List list){
      List result=new ArrayList(list.size());
      result.addAll((List)quicksort.evaluate(lesserTail.evaluate(head.evaluate(list),tail.evaluate(list))));
      result.add(head.evaluate(list));
      result.addAll((List)quicksort.evaluate(greaterTail.evaluate(head.evaluate(list),tail.evaluate(list))));
      return result;
    }
  }
);
public abstract class ListFunction implements UnaryFunction {
    public abstract Object evaluate(    List list);
    public Object evaluate(    Object obj){
      if (obj instanceof List) {
        return evaluate((List)obj);
      }
 else       if (null == obj) {
        throw new NullPointerException("The argument must not be null.");
      }
 else {
        throw new ClassCastException("The argument must be a List, found " + obj.getClass().getName());
      }
    }
  }
public abstract class ObjectListFunction implements BinaryFunction {
    public abstract Object evaluate(    Object head,    List tail);
    public Object evaluate(    Object left,    Object right){
      if (left != null && right instanceof List) {
        return evaluate(left,(List)right);
      }
 else       if (null == left) {
        throw new NullPointerException("The left argument must not be null.");
      }
 else       if (null == right) {
        throw new NullPointerException("The right argument must not be null.");
      }
 else {
        throw new ClassCastException("The right argument must be a List, found " + right.getClass().getName());
      }
    }
  }
  private UnaryFunction head=new ListFunction(){
    public Object evaluate(    List list){
      return list.get(0);
    }
  }
;
  private UnaryFunction tail=new ListFunction(){
    public Object evaluate(    List list){
      return list.size() < 2 ? Collections.EMPTY_LIST : list.subList(1,list.size());
    }
  }
;
  private BinaryFunction lesserTail=new ObjectListFunction(){
    public Object evaluate(    Object head,    List tail){
      return new FilteredGenerator(IteratorToGeneratorAdapter.adapt(tail.iterator()),IsLessThan.instance((Comparable)head)).toCollection();
    }
  }
;
  private BinaryFunction greaterTail=new ObjectListFunction(){
    public Object evaluate(    Object head,    List tail){
      return new FilteredGenerator(IteratorToGeneratorAdapter.adapt(tail.iterator()),IsGreaterThanOrEqual.instance((Comparable)head)).toCollection();
    }
  }
;
  public void testHeadFunction(){
    List list=new ArrayList();
    try {
      head.evaluate(list);
      fail("Expected IndexOutOfBoundsException when evaluating head of an empty list");
    }
 catch (    IndexOutOfBoundsException e) {
    }
    list.add("First");
    assertEquals("First",head.evaluate(list));
    list.add("Second");
    assertEquals("First",head.evaluate(list));
  }
  public void testTailFunction(){
    List list=new ArrayList();
{
      List result=(List)(tail.evaluate(list));
      assertTrue("Tail of an empty list is empty.",result.isEmpty());
    }
    list.add("First");
{
      List result=(List)(tail.evaluate(list));
      assertTrue("Tail of a one element list is empty.",result.isEmpty());
    }
    list.add("Second");
{
      List result=(List)(tail.evaluate(list));
      assertEquals("Tail of a two element list has one element.",1,result.size());
      assertEquals("Second",result.get(0));
    }
    list.add("Third");
{
      List result=(List)(tail.evaluate(list));
      assertEquals("Tail of a three element list has two elements.",2,result.size());
      assertEquals("Second",result.get(0));
      assertEquals("Third",result.get(1));
    }
  }
  public void testLesserTail(){
    List list=new ArrayList();
    for (int i=0; i < 10; i++) {
      list.add(new Integer(i));
    }
    for (int i=0; i < 10; i++) {
      Integer val=new Integer(i);
      List lesser=(List)lesserTail.evaluate(val,list);
      assertEquals(i,lesser.size());
      for (int j=0; j < i; j++) {
        assertEquals(new Integer(j),lesser.get(j));
      }
    }
  }
  public void testGreaterTail(){
    List list=new ArrayList();
    for (int i=0; i < 10; i++) {
      list.add(new Integer(i));
    }
    for (int i=0; i < 10; i++) {
      Integer val=new Integer(i);
      List greater=(List)greaterTail.evaluate(val,list);
      assertEquals(10 - i,greater.size());
      for (int j=i; j < 10; j++) {
        assertEquals(new Integer(j),greater.get(j - i));
      }
    }
  }
}
