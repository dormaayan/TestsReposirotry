public class TestHttpAsyncPrematureTermination extends HttpCoreNIOTestBase {
  @Before public void setUp() throws Exception {
    initServer();
    initClient();
  }
  @After public void tearDown() throws Exception {
    shutDownClient();
    shutDownServer();
  }
  private InetSocketAddress start() throws Exception {
    this.server.start();
    this.client.start();
    final ListenerEndpoint endpoint=this.server.getListenerEndpoint();
    endpoint.waitFor();
    return (InetSocketAddress)endpoint.getAddress();
  }
  @Test public void testConnectionTerminatedProcessingRequest() throws Exception {
    this.server.registerHandler("*",new HttpAsyncRequestHandler<HttpRequest>(){
      @Override public HttpAsyncRequestConsumer<HttpRequest> processRequest(      final HttpRequest request,      final HttpContext context) throws HttpException, IOException {
        final HttpConnection conn=(HttpConnection)context.getAttribute(HttpCoreContext.HTTP_CONNECTION);
        conn.shutdown();
        return new BasicAsyncRequestConsumer();
      }
      @Override public void handle(      final HttpRequest request,      final HttpAsyncExchange httpExchange,      final HttpContext context) throws HttpException, IOException {
        final HttpResponse response=httpExchange.getResponse();
        response.setEntity(new NStringEntity("all is well",ContentType.TEXT_PLAIN));
        httpExchange.submitResponse();
      }
    }
);
    final InetSocketAddress address=start();
    final HttpHost target=new HttpHost("localhost",address.getPort());
    final CountDownLatch latch=new CountDownLatch(1);
    final FutureCallback<HttpResponse> callback=new FutureCallback<HttpResponse>(){
      @Override public void cancelled(){
        latch.countDown();
      }
      @Override public void failed(      final Exception ex){
        latch.countDown();
      }
      @Override public void completed(      final HttpResponse response){
        Assert.fail();
      }
    }
;
    final HttpRequest request=new BasicHttpRequest("GET","/");
    final HttpContext context=new BasicHttpContext();
    this.client.execute(target,request,context,callback);
    Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
  }
  @Test public void testConnectionTerminatedHandlingRequest() throws Exception {
    final CountDownLatch responseStreamClosed=new CountDownLatch(1);
    final InputStream testInputStream=new ByteArrayInputStream("all is well".getBytes(Consts.ASCII)){
      @Override public void close() throws IOException {
        responseStreamClosed.countDown();
        super.close();
      }
    }
;
    this.server.registerHandler("*",new HttpAsyncRequestHandler<HttpRequest>(){
      @Override public HttpAsyncRequestConsumer<HttpRequest> processRequest(      final HttpRequest request,      final HttpContext context) throws HttpException, IOException {
        return new BasicAsyncRequestConsumer();
      }
      @Override public void handle(      final HttpRequest request,      final HttpAsyncExchange httpExchange,      final HttpContext context) throws HttpException, IOException {
        final HttpConnection conn=(HttpConnection)context.getAttribute(HttpCoreContext.HTTP_CONNECTION);
        conn.shutdown();
        final HttpResponse response=httpExchange.getResponse();
        response.setEntity(new InputStreamEntity(testInputStream,-1));
        httpExchange.submitResponse();
      }
    }
);
    final InetSocketAddress address=start();
    final HttpHost target=new HttpHost("localhost",address.getPort());
    final CountDownLatch latch=new CountDownLatch(1);
    final FutureCallback<HttpResponse> callback=new FutureCallback<HttpResponse>(){
      @Override public void cancelled(){
        latch.countDown();
      }
      @Override public void failed(      final Exception ex){
        latch.countDown();
      }
      @Override public void completed(      final HttpResponse response){
        Assert.fail();
      }
    }
;
    final HttpRequest request=new BasicHttpRequest("GET","/");
    final HttpContext context=new BasicHttpContext();
    this.client.execute(target,request,context,callback);
    Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
    Assert.assertTrue(responseStreamClosed.await(5,TimeUnit.SECONDS));
  }
  @Test public void testConnectionTerminatedSendingResponse() throws Exception {
    this.server.registerHandler("*",new HttpAsyncRequestHandler<HttpRequest>(){
      @Override public HttpAsyncRequestConsumer<HttpRequest> processRequest(      final HttpRequest request,      final HttpContext context) throws HttpException, IOException {
        return new BasicAsyncRequestConsumer();
      }
      @Override public void handle(      final HttpRequest request,      final HttpAsyncExchange httpExchange,      final HttpContext context) throws HttpException, IOException {
        final HttpResponse response=httpExchange.getResponse();
        response.setEntity(new NStringEntity("all is well",ContentType.TEXT_PLAIN));
        httpExchange.submitResponse(new BasicAsyncResponseProducer(response){
          @Override public synchronized void produceContent(          final ContentEncoder encoder,          final IOControl ioControl) throws IOException {
            ioControl.shutdown();
          }
        }
);
      }
    }
);
    final InetSocketAddress address=start();
    final HttpHost target=new HttpHost("localhost",address.getPort());
    final CountDownLatch latch=new CountDownLatch(1);
    final FutureCallback<HttpResponse> callback=new FutureCallback<HttpResponse>(){
      @Override public void cancelled(){
        latch.countDown();
      }
      @Override public void failed(      final Exception ex){
        latch.countDown();
      }
      @Override public void completed(      final HttpResponse response){
        Assert.fail();
      }
    }
;
    final HttpRequest request=new BasicHttpRequest("GET","/");
    final HttpContext context=new BasicHttpContext();
    this.client.execute(target,request,context,callback);
    Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
  }
}
