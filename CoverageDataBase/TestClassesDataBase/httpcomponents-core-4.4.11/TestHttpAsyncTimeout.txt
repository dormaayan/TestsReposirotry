@RunWith(Parameterized.class) public class TestHttpAsyncTimeout extends HttpCoreNIOTestBase {
  @Parameterized.Parameters(name="{0}") public static Collection<Object[]> protocols(){
    return Arrays.asList(new Object[][]{{ProtocolScheme.http},{ProtocolScheme.https}});
  }
  public TestHttpAsyncTimeout(  final ProtocolScheme scheme){
    super(scheme);
  }
  private ServerSocket serverSocket;
  @Before public void setUp() throws Exception {
    initClient();
  }
  @After public void tearDown() throws Exception {
    serverSocket.close();
    shutDownClient();
  }
  private InetSocketAddress start() throws Exception {
    this.client.start();
    serverSocket=new ServerSocket(0);
    return new InetSocketAddress(serverSocket.getInetAddress(),serverSocket.getLocalPort());
  }
  @Test public void testHandshakeTimeout() throws Exception {
    final InetSocketAddress address=start();
    final HttpHost target=new HttpHost("localhost",address.getPort(),getScheme().name());
    final CountDownLatch latch=new CountDownLatch(1);
    final FutureCallback<HttpResponse> callback=new FutureCallback<HttpResponse>(){
      @Override public void cancelled(){
        latch.countDown();
      }
      @Override public void failed(      final Exception ex){
        latch.countDown();
      }
      @Override public void completed(      final HttpResponse response){
        Assert.fail();
      }
    }
;
    final HttpRequest request=new BasicHttpRequest("GET","/");
    final HttpContext context=new BasicHttpContext();
    this.client.setTimeout(1000);
    this.client.execute(new BasicAsyncRequestProducer(target,request),new BasicAsyncResponseConsumer(),context,callback);
    final Socket accepted=serverSocket.accept();
    try {
      Assert.assertTrue(latch.await(10,TimeUnit.SECONDS));
    }
  finally {
      accepted.close();
    }
  }
}
