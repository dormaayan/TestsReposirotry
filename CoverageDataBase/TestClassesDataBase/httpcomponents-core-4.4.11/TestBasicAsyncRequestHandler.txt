public class TestBasicAsyncRequestHandler {
  private HttpRequestHandler requestHandler;
  private BasicAsyncRequestHandler asyncRequestHandler;
  private HttpContext context;
  private HttpRequest request;
  private HttpResponse response;
  private HttpAsyncExchange httpexchange;
  @Before public void setUp() throws Exception {
    this.requestHandler=Mockito.mock(HttpRequestHandler.class);
    this.asyncRequestHandler=new BasicAsyncRequestHandler(this.requestHandler);
    this.context=new BasicHttpContext();
    this.request=Mockito.mock(HttpRequest.class);
    this.response=Mockito.mock(HttpResponse.class);
    this.httpexchange=Mockito.mock(HttpAsyncExchange.class);
    Mockito.when(this.httpexchange.getRequest()).thenReturn(this.request);
    Mockito.when(this.httpexchange.getResponse()).thenReturn(this.response);
  }
  @After public void tearDown() throws Exception {
  }
  @Test public void testInvalidConstruction() throws Exception {
    try {
      new BasicAsyncRequestHandler(null);
      Assert.fail("IllegalArgumentException expected");
    }
 catch (    final IllegalArgumentException ex) {
    }
  }
  @Test public void testProcessRequest() throws Exception {
    final HttpAsyncRequestConsumer<HttpRequest> requestConsumer=this.asyncRequestHandler.processRequest(this.request,this.context);
    Assert.assertTrue(requestConsumer instanceof BasicAsyncRequestConsumer);
  }
  @Test public void testHandleRequest() throws Exception {
    Mockito.when(this.request.getRequestLine()).thenReturn(new BasicRequestLine("GET","/",HttpVersion.HTTP_1_0));
    this.asyncRequestHandler.handle(this.request,this.httpexchange,this.context);
    Mockito.verify(this.requestHandler).handle(Matchers.eq(this.request),Matchers.eq(this.response),Matchers.eq(this.context));
    Mockito.verify(this.httpexchange).submitResponse();
  }
}
