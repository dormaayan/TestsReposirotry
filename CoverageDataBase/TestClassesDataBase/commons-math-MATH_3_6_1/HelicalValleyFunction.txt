private static class HelicalValleyFunction extends MinpackFunction {
  public HelicalValleyFunction(  double[] startParams,  double theoreticalStartCost){
    super(3,startParams,0.0,new double[]{1.0,0.0,0.0});
  }
  @Override public double[][] computeJacobian(  double[] variables){
    double x1=variables[0];
    double x2=variables[1];
    double tmpSquare=x1 * x1 + x2 * x2;
    double tmp1=twoPi * tmpSquare;
    double tmp2=FastMath.sqrt(tmpSquare);
    return new double[][]{{100 * x2 / tmp1,-100 * x1 / tmp1,10},{10 * x1 / tmp2,10 * x2 / tmp2,0},{0,0,1}};
  }
  @Override public double[] computeValue(  double[] variables){
    double x1=variables[0];
    double x2=variables[1];
    double x3=variables[2];
    double tmp1;
    if (x1 == 0) {
      tmp1=(x2 >= 0) ? 0.25 : -0.25;
    }
 else {
      tmp1=FastMath.atan(x2 / x1) / twoPi;
      if (x1 < 0) {
        tmp1+=0.5;
      }
    }
    double tmp2=FastMath.sqrt(x1 * x1 + x2 * x2);
    return new double[]{10.0 * (x3 - 10 * tmp1),10.0 * (tmp2 - 1),x3};
  }
  private static final double twoPi=2.0 * FastMath.PI;
}
