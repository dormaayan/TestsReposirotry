/** 
 * Test cases for  {@link AggregateSummaryStatistics}
 */
public class AggregateSummaryStatisticsTest {
  /** 
 * Tests the standard aggregation behavior
 */
  @Test public void testAggregation(){
    AggregateSummaryStatistics aggregate=new AggregateSummaryStatistics();
    SummaryStatistics setOneStats=aggregate.createContributingStatistics();
    SummaryStatistics setTwoStats=aggregate.createContributingStatistics();
    Assert.assertNotNull("The set one contributing stats are null",setOneStats);
    Assert.assertNotNull("The set two contributing stats are null",setTwoStats);
    Assert.assertNotSame("Contributing stats objects are the same",setOneStats,setTwoStats);
    setOneStats.addValue(2);
    setOneStats.addValue(3);
    setOneStats.addValue(5);
    setOneStats.addValue(7);
    setOneStats.addValue(11);
    Assert.assertEquals("Wrong number of set one values",5,setOneStats.getN());
    Assert.assertTrue("Wrong sum of set one values",Precision.equals(28.0,setOneStats.getSum(),1));
    setTwoStats.addValue(2);
    setTwoStats.addValue(4);
    setTwoStats.addValue(8);
    Assert.assertEquals("Wrong number of set two values",3,setTwoStats.getN());
    Assert.assertTrue("Wrong sum of set two values",Precision.equals(14.0,setTwoStats.getSum(),1));
    Assert.assertEquals("Wrong number of aggregate values",8,aggregate.getN());
    Assert.assertTrue("Wrong aggregate sum",Precision.equals(42.0,aggregate.getSum(),1));
  }
  /** 
 * Verify that aggregating over a partition gives the same results as direct computation. 1) Randomly generate a dataset of 10-100 values from [-100, 100] 2) Divide the dataset it into 2-5 partitions 3) Create an AggregateSummaryStatistic and ContributingStatistics for each partition 4) Compare results from the AggregateSummaryStatistic with values returned by a single SummaryStatistics instance that is provided the full dataset
 */
  @Test public void testAggregationConsistency(){
    double[] totalSample=generateSample();
    double[][] subSamples=generatePartition(totalSample);
    int nSamples=subSamples.length;
    AggregateSummaryStatistics aggregate=new AggregateSummaryStatistics();
    SummaryStatistics totalStats=new SummaryStatistics();
    SummaryStatistics componentStats[]=new SummaryStatistics[nSamples];
    for (int i=0; i < nSamples; i++) {
      componentStats[i]=aggregate.createContributingStatistics();
      for (int j=0; j < subSamples[i].length; j++) {
        componentStats[i].addValue(subSamples[i][j]);
      }
    }
    for (int i=0; i < totalSample.length; i++) {
      totalStats.addValue(totalSample[i]);
    }
    Assert.assertEquals(totalStats.getSummary(),aggregate.getSummary());
  }
  /** 
 * Test aggregate function by randomly generating a dataset of 10-100 values from [-100, 100], dividing it into 2-5 partitions, computing stats for each partition and comparing the result of aggregate(...) applied to the collection of per-partition SummaryStatistics with a single SummaryStatistics computed over the full sample.
 */
  @Test public void testAggregate(){
    double[] totalSample=generateSample();
    double[][] subSamples=generatePartition(totalSample);
    int nSamples=subSamples.length;
    SummaryStatistics totalStats=new SummaryStatistics();
    for (int i=0; i < totalSample.length; i++) {
      totalStats.addValue(totalSample[i]);
    }
    SummaryStatistics[] subSampleStats=new SummaryStatistics[nSamples];
    for (int i=0; i < nSamples; i++) {
      subSampleStats[i]=new SummaryStatistics();
    }
    Collection<SummaryStatistics> aggregate=new ArrayList<SummaryStatistics>();
    for (int i=0; i < nSamples; i++) {
      for (int j=0; j < subSamples[i].length; j++) {
        subSampleStats[i].addValue(subSamples[i][j]);
      }
      aggregate.add(subSampleStats[i]);
    }
    StatisticalSummary aggregatedStats=AggregateSummaryStatistics.aggregate(aggregate);
    assertEquals(totalStats.getSummary(),aggregatedStats,10E-12);
  }
  /** 
 * Similar to  {@link #testAggregate()} but operating on{@link StatisticalSummary} instead.
 */
  @Test public void testAggregateStatisticalSummary(){
    double[] totalSample=generateSample();
    double[][] subSamples=generatePartition(totalSample);
    int nSamples=subSamples.length;
    SummaryStatistics totalStats=new SummaryStatistics();
    for (int i=0; i < totalSample.length; i++) {
      totalStats.addValue(totalSample[i]);
    }
    SummaryStatistics[] subSampleStats=new SummaryStatistics[nSamples];
    for (int i=0; i < nSamples; i++) {
      subSampleStats[i]=new SummaryStatistics();
    }
    Collection<StatisticalSummary> aggregate=new ArrayList<StatisticalSummary>();
    for (int i=0; i < nSamples; i++) {
      for (int j=0; j < subSamples[i].length; j++) {
        subSampleStats[i].addValue(subSamples[i][j]);
      }
      aggregate.add(subSampleStats[i].getSummary());
    }
    StatisticalSummary aggregatedStats=AggregateSummaryStatistics.aggregate(aggregate);
    assertEquals(totalStats.getSummary(),aggregatedStats,10E-12);
  }
  @Test public void testAggregateDegenerate(){
    double[] totalSample={1,2,3,4,5};
    double[][] subSamples={{1},{2},{3},{4},{5}};
    SummaryStatistics totalStats=new SummaryStatistics();
    for (int i=0; i < totalSample.length; i++) {
      totalStats.addValue(totalSample[i]);
    }
    SummaryStatistics[] subSampleStats=new SummaryStatistics[5];
    for (int i=0; i < 5; i++) {
      subSampleStats[i]=new SummaryStatistics();
    }
    Collection<SummaryStatistics> aggregate=new ArrayList<SummaryStatistics>();
    for (int i=0; i < 5; i++) {
      for (int j=0; j < subSamples[i].length; j++) {
        subSampleStats[i].addValue(subSamples[i][j]);
      }
      aggregate.add(subSampleStats[i]);
    }
    StatisticalSummaryValues aggregatedStats=AggregateSummaryStatistics.aggregate(aggregate);
    assertEquals(totalStats.getSummary(),aggregatedStats,10E-12);
  }
  @Test public void testAggregateSpecialValues(){
    double[] totalSample={Double.POSITIVE_INFINITY,2,3,Double.NaN,5};
    double[][] subSamples={{Double.POSITIVE_INFINITY,2},{3},{Double.NaN},{5}};
    SummaryStatistics totalStats=new SummaryStatistics();
    for (int i=0; i < totalSample.length; i++) {
      totalStats.addValue(totalSample[i]);
    }
    SummaryStatistics[] subSampleStats=new SummaryStatistics[5];
    for (int i=0; i < 4; i++) {
      subSampleStats[i]=new SummaryStatistics();
    }
    Collection<SummaryStatistics> aggregate=new ArrayList<SummaryStatistics>();
    for (int i=0; i < 4; i++) {
      for (int j=0; j < subSamples[i].length; j++) {
        subSampleStats[i].addValue(subSamples[i][j]);
      }
      aggregate.add(subSampleStats[i]);
    }
    StatisticalSummaryValues aggregatedStats=AggregateSummaryStatistics.aggregate(aggregate);
    assertEquals(totalStats.getSummary(),aggregatedStats,10E-12);
  }
  /** 
 * Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up to delta, with NaNs, infinities returned in the same spots. For max, min, n, values have to agree exactly, delta is used only for sum, mean, variance, std dev.
 */
  protected static void assertEquals(  StatisticalSummary expected,  StatisticalSummary observed,  double delta){
    TestUtils.assertEquals(expected.getMax(),observed.getMax(),0);
    TestUtils.assertEquals(expected.getMin(),observed.getMin(),0);
    Assert.assertEquals(expected.getN(),observed.getN());
    TestUtils.assertEquals(expected.getSum(),observed.getSum(),delta);
    TestUtils.assertEquals(expected.getMean(),observed.getMean(),delta);
    TestUtils.assertEquals(expected.getStandardDeviation(),observed.getStandardDeviation(),delta);
    TestUtils.assertEquals(expected.getVariance(),observed.getVariance(),delta);
  }
  /** 
 * Generates a random sample of double values. Sample size is random, between 10 and 100 and values are uniformly distributed over [-100, 100].
 * @return array of random double values
 */
  private double[] generateSample(){
    final IntegerDistribution size=new UniformIntegerDistribution(10,100);
    final RealDistribution randomData=new UniformRealDistribution(-100,100);
    final int sampleSize=size.sample();
    final double[] out=randomData.sample(sampleSize);
    return out;
  }
  /** 
 * Generates a partition of <sample> into up to 5 sequentially selected subsamples with randomly selected partition points.
 * @param sample array to partition
 * @return rectangular array with rows = subsamples
 */
  private double[][] generatePartition(  double[] sample){
    final int length=sample.length;
    final double[][] out=new double[5][];
    int cur=0;
    int offset=0;
    int sampleCount=0;
    for (int i=0; i < 5; i++) {
      if (cur == length || offset == length) {
        break;
      }
      final int next;
      if (i == 4 || cur == length - 1) {
        next=length - 1;
      }
 else {
        next=(new UniformIntegerDistribution(cur,length - 1)).sample();
      }
      final int subLength=next - cur + 1;
      out[i]=new double[subLength];
      System.arraycopy(sample,offset,out[i],0,subLength);
      cur=next + 1;
      sampleCount++;
      offset+=subLength;
    }
    if (sampleCount < 5) {
      double[][] out2=new double[sampleCount][];
      for (int j=0; j < sampleCount; j++) {
        final int curSize=out[j].length;
        out2[j]=new double[curSize];
        System.arraycopy(out[j],0,out2[j],0,curSize);
      }
      return out2;
    }
 else {
      return out;
    }
  }
}
