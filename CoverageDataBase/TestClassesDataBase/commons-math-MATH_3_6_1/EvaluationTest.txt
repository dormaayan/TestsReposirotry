/** 
 * The only features tested here are utility methods defined in  {@link LeastSquaresProblem.Evaluation} that compute thechi-square and parameters standard-deviations.
 */
public class EvaluationTest {
  /** 
 * Create a  {@link LeastSquaresBuilder} from a {@link StatisticalReferenceDataset}.
 * @param dataset the source data
 * @return a builder for further customization.
 */
  public LeastSquaresBuilder builder(  StatisticalReferenceDataset dataset){
    StatisticalReferenceDataset.LeastSquaresProblem problem=dataset.getLeastSquaresProblem();
    final double[] start=dataset.getParameters();
    final double[] observed=dataset.getData()[1];
    final double[] weights=new double[observed.length];
    Arrays.fill(weights,1d);
    return new LeastSquaresBuilder().model(problem.getModelFunction(),problem.getModelFunctionJacobian()).target(observed).weight(new DiagonalMatrix(weights)).start(start);
  }
  @Test public void testComputeResiduals(){
    RealVector point=new ArrayRealVector(2);
    Evaluation evaluation=new LeastSquaresBuilder().target(new ArrayRealVector(new double[]{3,-1})).model(new MultivariateJacobianFunction(){
      public Pair<RealVector,RealMatrix> value(      RealVector point){
        return new Pair<RealVector,RealMatrix>(new ArrayRealVector(new double[]{1,2}),MatrixUtils.createRealIdentityMatrix(2));
      }
    }
).weight(MatrixUtils.createRealIdentityMatrix(2)).build().evaluate(point);
    Assert.assertArrayEquals(evaluation.getResiduals().toArray(),new double[]{2,-3},Precision.EPSILON);
  }
  @Test public void testComputeCovariance() throws IOException {
    RealVector point=new ArrayRealVector(2);
    Evaluation evaluation=new LeastSquaresBuilder().model(new MultivariateJacobianFunction(){
      public Pair<RealVector,RealMatrix> value(      RealVector point){
        return new Pair<RealVector,RealMatrix>(new ArrayRealVector(2),MatrixUtils.createRealDiagonalMatrix(new double[]{1,1e-2}));
      }
    }
).weight(MatrixUtils.createRealDiagonalMatrix(new double[]{1,1})).target(new ArrayRealVector(2)).build().evaluate(point);
    TestUtils.assertEquals("covariance",evaluation.getCovariances(FastMath.nextAfter(1e-4,0.0)),MatrixUtils.createRealMatrix(new double[][]{{1,0},{0,1e4}}),Precision.EPSILON);
    try {
      evaluation.getCovariances(FastMath.nextAfter(1e-4,1.0));
      Assert.fail("Expected Exception");
    }
 catch (    SingularMatrixException e) {
    }
  }
  @Test public void testComputeValueAndJacobian(){
    final RealVector point=new ArrayRealVector(new double[]{1,2});
    Evaluation evaluation=new LeastSquaresBuilder().weight(new DiagonalMatrix(new double[]{16,4})).model(new MultivariateJacobianFunction(){
      public Pair<RealVector,RealMatrix> value(      RealVector actualPoint){
        Assert.assertArrayEquals(point.toArray(),actualPoint.toArray(),Precision.EPSILON);
        return new Pair<RealVector,RealMatrix>(new ArrayRealVector(new double[]{3,4}),MatrixUtils.createRealMatrix(new double[][]{{5,6},{7,8}}));
      }
    }
).target(new double[2]).build().evaluate(point);
    RealVector residuals=evaluation.getResiduals();
    RealMatrix jacobian=evaluation.getJacobian();
    Assert.assertArrayEquals(evaluation.getPoint().toArray(),point.toArray(),0);
    Assert.assertArrayEquals(new double[]{-12,-8},residuals.toArray(),Precision.EPSILON);
    TestUtils.assertEquals("jacobian",jacobian,MatrixUtils.createRealMatrix(new double[][]{{20,24},{14,16}}),Precision.EPSILON);
  }
  @Test public void testComputeCost() throws IOException {
    final StatisticalReferenceDataset dataset=StatisticalReferenceDatasetFactory.createKirby2();
    final LeastSquaresProblem lsp=builder(dataset).build();
    final double expected=dataset.getResidualSumOfSquares();
    final double cost=lsp.evaluate(lsp.getStart()).getCost();
    final double actual=cost * cost;
    Assert.assertEquals(dataset.getName(),expected,actual,1e-11 * expected);
  }
  @Test public void testComputeRMS() throws IOException {
    final StatisticalReferenceDataset dataset=StatisticalReferenceDatasetFactory.createKirby2();
    final LeastSquaresProblem lsp=builder(dataset).build();
    final double expected=FastMath.sqrt(dataset.getResidualSumOfSquares() / dataset.getNumObservations());
    final double actual=lsp.evaluate(lsp.getStart()).getRMS();
    Assert.assertEquals(dataset.getName(),expected,actual,1e-11 * expected);
  }
  @Test public void testComputeSigma() throws IOException {
    final StatisticalReferenceDataset dataset=StatisticalReferenceDatasetFactory.createKirby2();
    final LeastSquaresProblem lsp=builder(dataset).build();
    final double[] expected=dataset.getParametersStandardDeviations();
    final Evaluation evaluation=lsp.evaluate(lsp.getStart());
    final double cost=evaluation.getCost();
    final RealVector sig=evaluation.getSigma(1e-14);
    final int dof=lsp.getObservationSize() - lsp.getParameterSize();
    for (int i=0; i < sig.getDimension(); i++) {
      final double actual=FastMath.sqrt(cost * cost / dof) * sig.getEntry(i);
      Assert.assertEquals(dataset.getName() + ", parameter #" + i,expected[i],actual,1e-6 * expected[i]);
    }
  }
  @Test public void testEvaluateCopiesPoint() throws IOException {
    StatisticalReferenceDataset dataset=StatisticalReferenceDatasetFactory.createKirby2();
    LeastSquaresProblem lsp=builder(dataset).build();
    RealVector point=new ArrayRealVector(lsp.getParameterSize());
    Evaluation evaluation=lsp.evaluate(point);
    Assert.assertNotSame(point,evaluation.getPoint());
    point.setEntry(0,1);
    Assert.assertEquals(evaluation.getPoint().getEntry(0),0,0);
  }
  @Test public void testLazyEvaluation(){
    final RealVector dummy=new ArrayRealVector(new double[]{0});
    final LeastSquaresProblem p=LeastSquaresFactory.create(LeastSquaresFactory.model(dummyModel(),dummyJacobian()),dummy,dummy,null,null,0,0,true,null);
    final Evaluation eval=p.evaluate(dummy);
    try {
      eval.getResiduals();
      Assert.fail("Exception expected");
    }
 catch (    RuntimeException e) {
      Assert.assertEquals("dummyModel",e.getMessage());
    }
    try {
      eval.getJacobian();
      Assert.fail("Exception expected");
    }
 catch (    RuntimeException e) {
      Assert.assertEquals("dummyJacobian",e.getMessage());
    }
  }
  @Test public void testLazyEvaluationPrecondition(){
    final RealVector dummy=new ArrayRealVector(new double[]{0});
    final MultivariateJacobianFunction m1=new MultivariateJacobianFunction(){
      public Pair<RealVector,RealMatrix> value(      RealVector notUsed){
        return new Pair<RealVector,RealMatrix>(null,null);
      }
    }
;
    try {
      LeastSquaresFactory.create(m1,dummy,dummy,null,null,0,0,true,null);
      Assert.fail("Expecting MathIllegalStateException");
    }
 catch (    MathIllegalStateException e) {
    }
    final MultivariateJacobianFunction m2=new ValueAndJacobianFunction(){
      public Pair<RealVector,RealMatrix> value(      RealVector notUsed){
        return new Pair<RealVector,RealMatrix>(null,null);
      }
      public RealVector computeValue(      final double[] params){
        return null;
      }
      public RealMatrix computeJacobian(      final double[] params){
        return null;
      }
    }
;
    LeastSquaresFactory.create(m2,dummy,dummy,null,null,0,0,true,null);
  }
  @Test public void testDirectEvaluation(){
    final RealVector dummy=new ArrayRealVector(new double[]{0});
    final LeastSquaresProblem p=LeastSquaresFactory.create(LeastSquaresFactory.model(dummyModel(),dummyJacobian()),dummy,dummy,null,null,0,0,false,null);
    try {
      p.evaluate(dummy);
      Assert.fail("Exception expected");
    }
 catch (    RuntimeException e) {
      final String msg=e.getMessage();
      Assert.assertTrue(msg.equals("dummyModel") || msg.equals("dummyJacobian"));
    }
  }
  /** 
 * Used for testing direct vs lazy evaluation. 
 */
  private MultivariateVectorFunction dummyModel(){
    return new MultivariateVectorFunction(){
      public double[] value(      double[] p){
        throw new RuntimeException("dummyModel");
      }
    }
;
  }
  /** 
 * Used for testing direct vs lazy evaluation. 
 */
  private MultivariateMatrixFunction dummyJacobian(){
    return new MultivariateMatrixFunction(){
      public double[][] value(      double[] p){
        throw new RuntimeException("dummyJacobian");
      }
    }
;
  }
}
