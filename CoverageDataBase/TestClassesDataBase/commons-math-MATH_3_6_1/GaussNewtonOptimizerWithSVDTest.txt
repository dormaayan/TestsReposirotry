/** 
 * <p>Some of the unit tests are re-implementations of the MINPACK <a href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. The redistribution policy for MINPACK is available <a href="http://www.netlib.org/minpack/disclaimer">here</a>/
 */
public class GaussNewtonOptimizerWithSVDTest extends AbstractLeastSquaresOptimizerAbstractTest {
  @Override public int getMaxIterations(){
    return 1000;
  }
  @Override public LeastSquaresOptimizer getOptimizer(){
    return new GaussNewtonOptimizer(Decomposition.SVD);
  }
  @Test public void testMaxEvaluations() throws Exception {
    try {
      CircleVectorial circle=new CircleVectorial();
      circle.addPoint(30.0,68.0);
      circle.addPoint(50.0,-6.0);
      circle.addPoint(110.0,-20.0);
      circle.addPoint(35.0,15.0);
      circle.addPoint(45.0,97.0);
      LeastSquaresProblem lsp=builder(circle).checkerPair(new SimpleVectorValueChecker(1e-30,1e-30)).maxIterations(Integer.MAX_VALUE).start(new double[]{98.680,47.345}).build();
      optimizer.optimize(lsp);
      fail(optimizer);
    }
 catch (    TooManyEvaluationsException e) {
    }
  }
  @Override @Test public void testCircleFittingBadInit(){
    try {
      super.testCircleFittingBadInit();
      fail(optimizer);
    }
 catch (    AssertionError e) {
    }
  }
  @Override @Test public void testHahn1() throws IOException {
    try {
      super.testHahn1();
      fail(optimizer);
    }
 catch (    ConvergenceException e) {
    }
catch (    TooManyEvaluationsException e) {
    }
  }
  @Test @Override public void testGetIterations(){
    try {
      super.testGetIterations();
      fail(optimizer);
    }
 catch (    TooManyEvaluationsException e) {
    }
  }
  @Test @Override public void testNonInvertible() throws Exception {
    LinearProblem problem=new LinearProblem(new double[][]{{1,2,-3},{2,1,3},{-3,0,-9}},new double[]{1,1,1});
    Optimum optimum=optimizer.optimize(problem.getBuilder().build());
    Plane span=new Plane(Vector3D.ZERO,new Vector3D(1,2,-3),new Vector3D(2,1,0),TOl);
    double expected=FastMath.abs(span.getOffset(new Vector3D(1,1,1)));
    double actual=optimum.getResiduals().getNorm();
    Assert.assertEquals(expected,actual,TOl);
  }
}
