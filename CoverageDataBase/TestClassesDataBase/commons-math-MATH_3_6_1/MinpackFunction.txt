private static abstract class MinpackFunction {
  protected int n;
  protected int m;
  protected double[] startParams;
  protected double theoreticalMinCost;
  protected double[] theoreticalMinParams;
  protected double costAccuracy;
  protected double paramsAccuracy;
  protected MinpackFunction(  int m,  double[] startParams,  double theoreticalMinCost,  double[] theoreticalMinParams){
    this.m=m;
    this.n=startParams.length;
    this.startParams=startParams.clone();
    this.theoreticalMinCost=theoreticalMinCost;
    this.theoreticalMinParams=theoreticalMinParams;
    this.costAccuracy=1.0e-8;
    this.paramsAccuracy=1.0e-5;
  }
  protected static double[] buildArray(  int n,  double x){
    double[] array=new double[n];
    Arrays.fill(array,x);
    return array;
  }
  public double[] getTarget(){
    return buildArray(m,0.0);
  }
  public double[] getWeight(){
    return buildArray(m,1.0);
  }
  public double[] getStartPoint(){
    return startParams.clone();
  }
  protected void setCostAccuracy(  double costAccuracy){
    this.costAccuracy=costAccuracy;
  }
  protected void setParamsAccuracy(  double paramsAccuracy){
    this.paramsAccuracy=paramsAccuracy;
  }
  public int getN(){
    return startParams.length;
  }
  public void checkTheoreticalMinCost(  double rms){
    double threshold=costAccuracy * (1.0 + theoreticalMinCost);
    Assert.assertEquals(theoreticalMinCost,FastMath.sqrt(m) * rms,threshold);
  }
  public void checkTheoreticalMinParams(  PointVectorValuePair optimum){
    double[] params=optimum.getPointRef();
    if (theoreticalMinParams != null) {
      for (int i=0; i < theoreticalMinParams.length; ++i) {
        double mi=theoreticalMinParams[i];
        double vi=params[i];
        Assert.assertEquals(mi,vi,paramsAccuracy * (1.0 + FastMath.abs(mi)));
      }
    }
  }
  public ModelFunction getModelFunction(){
    return new ModelFunction(new MultivariateVectorFunction(){
      public double[] value(      double[] point){
        return computeValue(point);
      }
    }
);
  }
  public ModelFunctionJacobian getModelFunctionJacobian(){
    return new ModelFunctionJacobian(new MultivariateMatrixFunction(){
      public double[][] value(      double[] point){
        return computeJacobian(point);
      }
    }
);
  }
  public abstract double[][] computeJacobian(  double[] variables);
  public abstract double[] computeValue(  double[] variables);
}
