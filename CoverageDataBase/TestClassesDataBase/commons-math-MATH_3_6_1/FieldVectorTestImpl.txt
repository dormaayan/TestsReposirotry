public static class FieldVectorTestImpl<T extends FieldElement<T>> implements FieldVector<T>, Serializable {
  private static final long serialVersionUID=3970959016014158539L;
  private final Field<T> field;
  /** 
 * Entries of the vector. 
 */
  protected T[] data;
  /** 
 * Build an array of elements.
 * @param length size of the array to build
 * @return a new array
 */
  @SuppressWarnings("unchecked") private T[] buildArray(  final int length){
    return (T[])Array.newInstance(field.getRuntimeClass(),length);
  }
  public FieldVectorTestImpl(  T[] d){
    field=d[0].getField();
    data=d.clone();
  }
  public Field<T> getField(){
    return field;
  }
  private UnsupportedOperationException unsupported(){
    return new UnsupportedOperationException("Not supported, unneeded for test purposes");
  }
  public FieldVector<T> copy(){
    throw unsupported();
  }
  public FieldVector<T> add(  FieldVector<T> v){
    throw unsupported();
  }
  public FieldVector<T> add(  T[] v){
    throw unsupported();
  }
  public FieldVector<T> subtract(  FieldVector<T> v){
    throw unsupported();
  }
  public FieldVector<T> subtract(  T[] v){
    throw unsupported();
  }
  public FieldVector<T> mapAdd(  T d){
    throw unsupported();
  }
  public FieldVector<T> mapAddToSelf(  T d){
    throw unsupported();
  }
  public FieldVector<T> mapSubtract(  T d){
    throw unsupported();
  }
  public FieldVector<T> mapSubtractToSelf(  T d){
    throw unsupported();
  }
  public FieldVector<T> mapMultiply(  T d){
    T[] out=buildArray(data.length);
    for (int i=0; i < data.length; i++) {
      out[i]=data[i].multiply(d);
    }
    return new FieldVectorTestImpl<T>(out);
  }
  public FieldVector<T> mapMultiplyToSelf(  T d){
    throw unsupported();
  }
  public FieldVector<T> mapDivide(  T d){
    throw unsupported();
  }
  public FieldVector<T> mapDivideToSelf(  T d){
    throw unsupported();
  }
  public FieldVector<T> mapInv(){
    throw unsupported();
  }
  public FieldVector<T> mapInvToSelf(){
    throw unsupported();
  }
  public FieldVector<T> ebeMultiply(  FieldVector<T> v){
    throw unsupported();
  }
  public FieldVector<T> ebeMultiply(  T[] v){
    throw unsupported();
  }
  public FieldVector<T> ebeDivide(  FieldVector<T> v){
    throw unsupported();
  }
  public FieldVector<T> ebeDivide(  T[] v){
    throw unsupported();
  }
  public T[] getData(){
    return data.clone();
  }
  public T dotProduct(  FieldVector<T> v){
    T dot=field.getZero();
    for (int i=0; i < data.length; i++) {
      dot=dot.add(data[i].multiply(v.getEntry(i)));
    }
    return dot;
  }
  public T dotProduct(  T[] v){
    T dot=field.getZero();
    for (int i=0; i < data.length; i++) {
      dot=dot.add(data[i].multiply(v[i]));
    }
    return dot;
  }
  public FieldVector<T> projection(  FieldVector<T> v){
    throw unsupported();
  }
  public FieldVector<T> projection(  T[] v){
    throw unsupported();
  }
  public FieldMatrix<T> outerProduct(  FieldVector<T> v){
    throw unsupported();
  }
  public FieldMatrix<T> outerProduct(  T[] v){
    throw unsupported();
  }
  public T getEntry(  int index){
    return data[index];
  }
  public int getDimension(){
    return data.length;
  }
  public FieldVector<T> append(  FieldVector<T> v){
    throw unsupported();
  }
  public FieldVector<T> append(  T d){
    throw unsupported();
  }
  public FieldVector<T> append(  T[] a){
    throw unsupported();
  }
  public FieldVector<T> getSubVector(  int index,  int n){
    throw unsupported();
  }
  public void setEntry(  int index,  T value){
    throw unsupported();
  }
  public void setSubVector(  int index,  FieldVector<T> v){
    throw unsupported();
  }
  public void setSubVector(  int index,  T[] v){
    throw unsupported();
  }
  public void set(  T value){
    throw unsupported();
  }
  public T[] toArray(){
    return data.clone();
  }
}
