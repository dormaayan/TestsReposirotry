private static class WatsonFunction extends MinpackFunction {
  public WatsonFunction(  int n,  double x0,  double theoreticalStartCost,  double theoreticalMinCost,  double[] theoreticalMinParams){
    super(31,buildArray(n,x0),theoreticalMinCost,theoreticalMinParams);
  }
  @Override public double[][] computeJacobian(  double[] variables){
    double[][] jacobian=new double[m][];
    for (int i=0; i < (m - 2); ++i) {
      double div=(i + 1) / 29.0;
      double s2=0.0;
      double dx=1.0;
      for (int j=0; j < n; ++j) {
        s2+=dx * variables[j];
        dx*=div;
      }
      double temp=2 * div * s2;
      dx=1.0 / div;
      jacobian[i]=new double[n];
      for (int j=0; j < n; ++j) {
        jacobian[i][j]=dx * (j - temp);
        dx*=div;
      }
    }
    jacobian[m - 2]=new double[n];
    jacobian[m - 2][0]=1;
    jacobian[m - 1]=new double[n];
    jacobian[m - 1][0]=-2 * variables[0];
    jacobian[m - 1][1]=1;
    return jacobian;
  }
  @Override public double[] computeValue(  double[] variables){
    double[] f=new double[m];
    for (int i=0; i < (m - 2); ++i) {
      double div=(i + 1) / 29.0;
      double s1=0;
      double dx=1;
      for (int j=1; j < n; ++j) {
        s1+=j * dx * variables[j];
        dx*=div;
      }
      double s2=0;
      dx=1;
      for (int j=0; j < n; ++j) {
        s2+=dx * variables[j];
        dx*=div;
      }
      f[i]=s1 - s2 * s2 - 1;
    }
    double x1=variables[0];
    double x2=variables[1];
    f[m - 2]=x1;
    f[m - 1]=x2 - x1 * x1 - 1;
    return f;
  }
}
