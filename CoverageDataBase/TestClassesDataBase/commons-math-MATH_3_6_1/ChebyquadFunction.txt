private static class ChebyquadFunction extends MinpackFunction {
  private static double[] buildChebyquadArray(  int n,  double factor){
    double[] array=new double[n];
    double inv=factor / (n + 1);
    for (int i=0; i < n; ++i) {
      array[i]=(i + 1) * inv;
    }
    return array;
  }
  public ChebyquadFunction(  int n,  int m,  double factor,  double theoreticalStartCost,  double theoreticalMinCost,  double[] theoreticalMinParams){
    super(m,buildChebyquadArray(n,factor),theoreticalMinCost,theoreticalMinParams);
  }
  @Override public double[][] computeJacobian(  double[] variables){
    double[][] jacobian=new double[m][];
    for (int i=0; i < m; ++i) {
      jacobian[i]=new double[n];
    }
    double dx=1.0 / n;
    for (int j=0; j < n; ++j) {
      double tmp1=1;
      double tmp2=2 * variables[j] - 1;
      double temp=2 * tmp2;
      double tmp3=0;
      double tmp4=2;
      for (int i=0; i < m; ++i) {
        jacobian[i][j]=dx * tmp4;
        double ti=4 * tmp2 + temp * tmp4 - tmp3;
        tmp3=tmp4;
        tmp4=ti;
        ti=temp * tmp2 - tmp1;
        tmp1=tmp2;
        tmp2=ti;
      }
    }
    return jacobian;
  }
  @Override public double[] computeValue(  double[] variables){
    double[] f=new double[m];
    for (int j=0; j < n; ++j) {
      double tmp1=1;
      double tmp2=2 * variables[j] - 1;
      double temp=2 * tmp2;
      for (int i=0; i < m; ++i) {
        f[i]+=tmp2;
        double ti=temp * tmp2 - tmp1;
        tmp1=tmp2;
        tmp2=ti;
      }
    }
    double dx=1.0 / n;
    boolean iev=false;
    for (int i=0; i < m; ++i) {
      f[i]*=dx;
      if (iev) {
        f[i]+=1.0 / (i * (i + 2));
      }
      iev=!iev;
    }
    return f;
  }
}
