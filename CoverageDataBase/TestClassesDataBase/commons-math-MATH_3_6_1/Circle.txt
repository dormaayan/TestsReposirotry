/** 
 * ODE representing a point moving on a circle with provided center and angular rate. 
 */
private static class Circle extends AbstractParameterizable implements MainStateJacobianProvider, ParameterJacobianProvider {
  public static final String CX="cx";
  public static final String CY="cy";
  public static final String OMEGA="omega";
  private final double[] y0;
  private double cx;
  private double cy;
  private double omega;
  public Circle(  double[] y0,  double cx,  double cy,  double omega){
    super(CX,CY,OMEGA);
    this.y0=y0.clone();
    this.cx=cx;
    this.cy=cy;
    this.omega=omega;
  }
  public int getDimension(){
    return 2;
  }
  public void computeDerivatives(  double t,  double[] y,  double[] yDot){
    yDot[0]=omega * (cy - y[1]);
    yDot[1]=omega * (y[0] - cx);
  }
  public void computeMainStateJacobian(  double t,  double[] y,  double[] yDot,  double[][] dFdY){
    dFdY[0][0]=0;
    dFdY[0][1]=-omega;
    dFdY[1][0]=omega;
    dFdY[1][1]=0;
  }
  public void computeParameterJacobian(  double t,  double[] y,  double[] yDot,  String paramName,  double[] dFdP) throws UnknownParameterException {
    complainIfNotSupported(paramName);
    if (paramName.equals(CX)) {
      dFdP[0]=0;
      dFdP[1]=-omega;
    }
 else     if (paramName.equals(CY)) {
      dFdP[0]=omega;
      dFdP[1]=0;
    }
 else {
      dFdP[0]=cy - y[1];
      dFdP[1]=y[0] - cx;
    }
  }
  public double[] exactY(  double t){
    double cos=FastMath.cos(omega * t);
    double sin=FastMath.sin(omega * t);
    double dx0=y0[0] - cx;
    double dy0=y0[1] - cy;
    return new double[]{cx + cos * dx0 - sin * dy0,cy + sin * dx0 + cos * dy0};
  }
  public double[][] exactDyDy0(  double t){
    double cos=FastMath.cos(omega * t);
    double sin=FastMath.sin(omega * t);
    return new double[][]{{cos,-sin},{sin,cos}};
  }
  public double[] exactDyDcx(  double t){
    double cos=FastMath.cos(omega * t);
    double sin=FastMath.sin(omega * t);
    return new double[]{1 - cos,-sin};
  }
  public double[] exactDyDcy(  double t){
    double cos=FastMath.cos(omega * t);
    double sin=FastMath.sin(omega * t);
    return new double[]{sin,1 - cos};
  }
  public double[] exactDyDom(  double t){
    double cos=FastMath.cos(omega * t);
    double sin=FastMath.sin(omega * t);
    double dx0=y0[0] - cx;
    double dy0=y0[1] - cy;
    return new double[]{-t * (sin * dx0 + cos * dy0),t * (cos * dx0 - sin * dy0)};
  }
}
