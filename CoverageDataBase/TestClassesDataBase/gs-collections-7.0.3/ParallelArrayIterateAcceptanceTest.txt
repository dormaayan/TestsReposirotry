public class ParallelArrayIterateAcceptanceTest {
  private int count=0;
  private final MutableSet<String> threadNames=MultiReaderUnifiedSet.newSet();
  @Test public void oneLevelCall(){
    new RecursiveProcedure().value(1);
synchronized (this) {
      Assert.assertEquals("all iterations completed",20000,this.count);
    }
  }
  @Test public void nestedCall(){
    new RecursiveProcedure().value(2);
synchronized (this) {
      Assert.assertEquals("all iterations completed",419980,this.count);
    }
    Assert.assertTrue("uses multiple threads",this.threadNames.size() > 1);
  }
private class RecursiveProcedure implements Procedure<Integer> {
    private static final long serialVersionUID=1L;
    private final ExecutorService executorService=ParallelIterate.newPooledExecutor("ParallelArrayIterateAcceptanceTest",false);
    @Override public void value(    Integer object){
      int level=object.intValue();
      if (level > 0) {
        ParallelArrayIterateAcceptanceTest.this.threadNames.add(Thread.currentThread().getName());
        this.executeParallelIterate(level - 1,this.executorService);
      }
 else {
        this.simulateWork();
      }
    }
    private void simulateWork(){
synchronized (ParallelArrayIterateAcceptanceTest.this) {
        ParallelArrayIterateAcceptanceTest.this.count++;
      }
    }
    private void executeParallelIterate(    int level,    ExecutorService executorService){
      MutableList<Integer> items=Lists.mutable.of();
      for (int i=0; i < 20000; i++) {
        items.add(i % 1000 == 0 ? level : 0);
      }
      ParallelIterate.forEach(items,new RecursiveProcedure(),executorService);
    }
  }
}
