static final class TimeKeeper {
  private static final SystemTimeProvider PROVIDER=new SystemTimeProvider();
  private static final long PAIN_THRESHOLD=10000L;
  private static final int MILLIS_TO_NANOS=1000000;
  private TimeKeeper(){
    throw new AssertionError("Suppress default constructor for noninstantiability");
  }
  /** 
 * This method can take either a Runnable or a RunnableWithSetup.  In the case of RunnableWithSetup, the setup method will be called first, without impacting the timing.
 */
  public static long millisecondsToRun(  Runnable runnable){
    return TimeKeeper.nanosecondsToRun(runnable) / (long)MILLIS_TO_NANOS;
  }
  public static long currentTimeNanoseconds(){
    return PROVIDER.currentTimeNanoseconds();
  }
  public static long currentTimeMilliseconds(){
    return PROVIDER.currentTimeMilliseconds();
  }
  /** 
 * This method can take either a Runnable or a RunnableWithSetup.  In the case of RunnableWithSetup, the setup method will be called first, without impacting the timing.
 */
  public static long nanosecondsToRun(  Runnable runnable){
    long start=TimeKeeper.getCurrentTimeAsNanos();
    runnable.run();
    long end=TimeKeeper.getCurrentTimeAsNanos();
    return end - start;
  }
  private static long getCurrentTimeAsNanos(){
    return TimeKeeper.currentTimeNanoseconds();
  }
  private static void doLog(  String message,  int count,  long total,  double average){
    LOGGER.info("{} Count: {} Total(ms): {} Avg(ms): {}",message,count,TimeKeeper.longNanosToMillisString(total),TimeKeeper.doubleNanosToMillisString(average));
  }
  public static double logAverageMillisecondsToRun(  String message,  Runnable runnable,  int count){
    long start=TimeKeeper.getCurrentTimeAsNanos();
    for (int i=0; i < count; i++) {
      runnable.run();
    }
    long totalNanos=TimeKeeper.getCurrentTimeAsNanos() - start;
    double averageTime=(double)totalNanos / (double)count;
    TimeKeeper.doLog(message,count,totalNanos,averageTime);
    return averageTime / (double)TimeKeeper.MILLIS_TO_NANOS;
  }
  private static String doubleNanosToMillisString(  double nanos){
    return NumberFormat.getInstance().format(nanos / MILLIS_TO_NANOS);
  }
  private static String longNanosToMillisString(  long nanos){
    return NumberFormat.getInstance().format(nanos / MILLIS_TO_NANOS);
  }
  public static double logAverageMillisecondsToRun(  String message,  Runnable runnable,  int count,  int warmUpCount){
    TimeKeeper.warmUp(warmUpCount,runnable);
    TimeKeeper.gcAndYield();
    return TimeKeeper.logAverageMillisecondsToRun(message,runnable,count);
  }
  private static void gcAndYield(){
    SerialParallelLazyPerformanceTest.forceGC();
  }
  private static void warmUp(  int warmUpCount,  Runnable runnable){
    long start=TimeKeeper.currentTimeMilliseconds();
    for (int i=0; i < warmUpCount; i++) {
      TimeKeeper.millisecondsToRun(runnable);
      if (TimeKeeper.currentTimeMilliseconds() - start > PAIN_THRESHOLD) {
        break;
      }
    }
  }
private static class SystemTimeProvider {
    public long currentTimeMilliseconds(){
      return System.currentTimeMillis();
    }
    public long currentTimeNanoseconds(){
      return System.nanoTime();
    }
  }
}
