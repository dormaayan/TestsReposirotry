public class TestAsyncCRUDSimpleEntity {
  private static final String ASYNC_LOGGER_STRING="info.archinnov.achilles.AsyncLogger";
  private static final Logger LOGGER=LoggerFactory.getLogger(ASYNC_LOGGER_STRING);
  private static final String CALLED="Called";
  @Rule public AchillesTestResource<ManagerFactory> resource=AchillesTestResourceBuilder.forJunit().entityClassesToTruncate(SimpleEntity.class).truncateBeforeAndAfterTest().build((cluster,statementsCache) -> ManagerFactoryBuilder.builder(cluster).withManagedEntityClasses(SimpleEntity.class).doForceSchemaCreation(true).withStatementsCache(statementsCache).withDefaultKeyspaceName(DEFAULT_CASSANDRA_EMBEDDED_KEYSPACE_NAME).build());
  private Session session=resource.getNativeSession();
  private ScriptExecutor scriptExecutor=resource.getScriptExecutor();
  private SimpleEntity_Manager manager=resource.getManagerFactory().forSimpleEntity();
  @Test public void should_insert_async() throws Exception {
    final long id=RandomUtils.nextLong(0L,Long.MAX_VALUE);
    final Date date=new Date();
    final SimpleEntity entity=new SimpleEntity(id,date,"value");
    final CountDownLatch latch=new CountDownLatch(1);
    final CassandraLogAsserter logAsserter=new CassandraLogAsserter();
    logAsserter.prepareLogLevel(ASYNC_LOGGER_STRING,"%msg - [%thread]%n");
    manager.crud().insert(entity).withResultSetAsyncListener(rs -> {
      LOGGER.info(CALLED);
      latch.countDown();
      return rs;
    }
).executeAsync();
    latch.await();
    logAsserter.assertContains("Called - [achilles-default-executor");
    final List<Row> rows=session.execute("SELECT * FROM simple WHERE id = " + id).all();
    assertThat(rows).hasSize(1);
    final Row row=rows.get(0);
    assertThat(row.getLong("id")).isEqualTo(id);
    assertThat(row.getTimestamp("date")).isEqualTo(date);
    assertThat(row.getString("value")).isEqualTo("value");
  }
  @Test public void should_find_by_id_async() throws Exception {
    final long id=RandomUtils.nextLong(0,Long.MAX_VALUE);
    scriptExecutor.executeScriptTemplate("SimpleEntity/insert_single_row.cql",ImmutableMap.of("id",id,"table","simple"));
    final Date date=buildDateKey();
    final CountDownLatch latch=new CountDownLatch(1);
    final CassandraLogAsserter logAsserter=new CassandraLogAsserter();
    logAsserter.prepareLogLevel(ASYNC_LOGGER_STRING,"%msg - [%thread]%n");
    final CompletableFuture<Tuple2<SimpleEntity,ExecutionInfo>> tuple2=manager.crud().findById(id,date).withResultSetAsyncListener(rs -> {
      LOGGER.info(CALLED);
      latch.countDown();
      return rs;
    }
).getAsyncWithStats();
    latch.await();
    final SimpleEntity actual=tuple2.get()._1();
    final ExecutionInfo executionInfo=tuple2.get()._2();
    assertThat(actual).isNotNull();
    assertThat(actual.getConsistencyList()).containsExactly(ConsistencyLevel.QUORUM,ConsistencyLevel.LOCAL_ONE);
    assertThat(executionInfo.getQueriedHost().isUp()).isTrue();
    logAsserter.assertContains("Called - [achilles-default-executor");
  }
  @Test public void should_delete_instance_async() throws Exception {
    final long id=RandomUtils.nextLong(0L,Long.MAX_VALUE);
    final Date date=buildDateKey();
    final SimpleEntity entity=new SimpleEntity(id,date,"value");
    scriptExecutor.executeScriptTemplate("SimpleEntity/insert_single_row.cql",ImmutableMap.of("id",id,"table","simple"));
    final CountDownLatch latch=new CountDownLatch(1);
    final CassandraLogAsserter logAsserter=new CassandraLogAsserter();
    logAsserter.prepareLogLevel(ASYNC_LOGGER_STRING,"%msg - [%thread]%n");
    final CompletableFuture<ExecutionInfo> future=manager.crud().delete(entity).withResultSetAsyncListener(rs -> {
      LOGGER.info(CALLED);
      latch.countDown();
      return rs;
    }
).executeAsyncWithStats();
    latch.await();
    logAsserter.assertContains("Called");
    final List<Row> rows=session.execute("SELECT * FROM simple WHERE id = " + id).all();
    assertThat(rows).isEmpty();
    final ExecutionInfo executionInfo=future.get();
    assertThat(executionInfo.getQueriedHost().isUp()).isTrue();
  }
  private Date buildDateKey() throws ParseException {
    SimpleDateFormat dateFormat=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
    dateFormat.setTimeZone(TimeZone.getTimeZone("GMT"));
    return dateFormat.parse("2015-10-01 00:00:00 GMT");
  }
}
