public class AnnotationTreeTest extends AbstractTestProcessor {
  private GlobalParsingContext globalParsingContext=GlobalParsingContext.defaultContext();
  @Test public void should_build_annotation_tree_for_map_javac() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement mapElt=findFieldByName(typeElement,"map");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,mapElt);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(annotationTree).isNotNull();
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(EmptyCollectionIfNull.class.getSimpleName(),Frozen.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName(),Frozen.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Frozen.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Tuple3.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(String.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Frozen.class.getSimpleName(),EmptyCollectionIfNull.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Date.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_annotation_tree_for_map_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement mapElt=findFieldByName(typeElement,"map");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,mapElt);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(annotationTree).isNotNull();
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(EmptyCollectionIfNull.class.getSimpleName(),Frozen.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName(),Frozen.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Frozen.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Tuple3.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(String.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Frozen.class.getSimpleName(),EmptyCollectionIfNull.class.getSimpleName());
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Date.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).withCompilerOptions("-nowarn","-1.8").processedWith(this).compilesWithoutError();
  }
  @Test public void should_build_trees_for_other_fields_javac() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement idElm=findFieldByName(typeElement,"id");
        final VariableElement timeElm=findFieldByName(typeElement,"time");
        final VariableElement listElm=findFieldByName(typeElement,"list");
        final VariableElement setElm=findFieldByName(typeElement,"set");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,idElm);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Long.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());
        annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,timeElm);
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Date.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName());
        annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,listElm);
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(List.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,setElm);
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Set.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Double.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_trees_for_other_fields_javac_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement idElm=findFieldByName(typeElement,"id");
        final VariableElement timeElm=findFieldByName(typeElement,"time");
        final VariableElement listElm=findFieldByName(typeElement,"list");
        final VariableElement setElm=findFieldByName(typeElement,"set");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,idElm);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Long.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());
        annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,timeElm);
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Date.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName());
        annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,listElm);
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(List.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,setElm);
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Set.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Double.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Enumerated.class.getSimpleName());
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Test public void should_build_trees_json_map_javac() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement jsonMap=findFieldByName(typeElement,"jsonMap");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,jsonMap);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName());
        assertThat(annotationTree.hasNext()).isFalse();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_trees_json_map_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement jsonMap=findFieldByName(typeElement,"jsonMap");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,jsonMap);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName());
        assertThat(annotationTree.hasNext()).isFalse();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Test public void should_build_trees_map_with_nested_json_javac() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement mapWithNestedJson=findFieldByName(typeElement,"mapWithNestedJson");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,mapWithNestedJson);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(List.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName());
        assertThat(annotationTree.hasNext()).isFalse();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_trees_map_with_nested_json_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement mapWithNestedJson=findFieldByName(typeElement,"mapWithNestedJson");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,mapWithNestedJson);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(List.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(JSON.class.getSimpleName());
        assertThat(annotationTree.hasNext()).isFalse();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Test public void should_build_trees_map_for_level1_nesting_javac() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement level1NestingElm=findFieldByName(typeElement,"level1Nesting");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,level1NestingElm);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(List.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(String.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_trees_map_for_level1_nesting_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement level1NestingElm=findFieldByName(typeElement,"level1Nesting");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,level1NestingElm);
        Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(List.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Map.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
        annotationTree=annotationTree.next();
        annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(String.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).isEmpty();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Test public void should_build_treemap_for_codec_annotation_javac() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement mapWithCodec=findFieldByName(typeElement,"mapWithCodec");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,mapWithCodec).next();
        final Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Codec.class.getSimpleName());
        final CodecContext codecContext=annotationTree.getAnnotations().get(Codec.class).getTyped("codecContext");
        assertThat(codecContext.codecType).isEqualTo(ClassName.get(IntToStringCodec.class));
        assertThat(codecContext.sourceType).isEqualTo(ClassName.get(Integer.class));
        assertThat(codecContext.targetType).isEqualTo(ClassName.get(String.class));
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_treemap_for_codec_annotation_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement mapWithCodec=findFieldByName(typeElement,"mapWithCodec");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,mapWithCodec).next();
        final Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Integer.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Codec.class.getSimpleName());
        final CodecContext codecContext=annotationTree.getAnnotations().get(Codec.class).getTyped("codecContext");
        assertThat(codecContext.codecType).isEqualTo(ClassName.get(IntToStringCodec.class));
        assertThat(codecContext.sourceType).isEqualTo(ClassName.get(Integer.class));
        assertThat(codecContext.targetType).isEqualTo(ClassName.get(String.class));
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Test public void should_build_treemap_for_computed_annotation_javac() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement writetime=findFieldByName(typeElement,"writetime");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,writetime);
        final Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Long.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Computed.class.getSimpleName());
        final TypedMap typedMap=annotationTree.getAnnotations().get(Computed.class);
        assertThat(typedMap.<String>getTyped("function")).isEqualTo("writetime");
        assertThat(typedMap.<String>getTyped("alias")).isEqualTo("writetime_col");
        assertThat(typedMap.<Class<?>>getTyped("cqlClass")).isEqualTo(Long.class);
        assertThat(typedMap.<List<String>>getTyped("targetColumns")).containsExactly("id","value");
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_treemap_for_computed_annotation_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement writetime=findFieldByName(typeElement,"writetime");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,writetime);
        final Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(Long.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Computed.class.getSimpleName());
        final TypedMap typedMap=annotationTree.getAnnotations().get(Computed.class);
        assertThat(typedMap.<String>getTyped("function")).isEqualTo("writetime");
        assertThat(typedMap.<String>getTyped("alias")).isEqualTo("writetime_col");
        assertThat(typedMap.<Class<?>>getTyped("cqlClass")).isEqualTo(Long.class);
        assertThat(typedMap.<List<String>>getTyped("targetColumns")).containsExactly("id","value");
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Test public void should_build_treemap_for_clustering_column_annotation_java() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement clusteringCol=findFieldByName(typeElement,"clusteringCol");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,clusteringCol);
        final Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(UUID.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(ClusteringColumn.class.getSimpleName());
        final TypedMap typedMap=annotationTree.getAnnotations().get(ClusteringColumn.class);
        assertThat(typedMap.<Integer>getTyped("order")).isEqualTo(2);
        assertThat(typedMap.<Boolean>getTyped("asc")).isFalse();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_treemap_for_clustering_column_annotation_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement clusteringCol=findFieldByName(typeElement,"clusteringCol");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,clusteringCol);
        final Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(UUID.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(ClusteringColumn.class.getSimpleName());
        final TypedMap typedMap=annotationTree.getAnnotations().get(ClusteringColumn.class);
        assertThat(typedMap.<Integer>getTyped("order")).isEqualTo(2);
        assertThat(typedMap.<Boolean>getTyped("asc")).isFalse();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  @Ignore @Test public void should_build_treemap_for_frozen_udt_annotation_ecj() throws Exception {
    setExec(aptUtils -> {
      try {
        final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(TestEntityForAnnotationTree.class.getCanonicalName());
        final VariableElement testUdt=findFieldByName(typeElement,"testUdt");
        AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,testUdt);
        final Set<String> annotationNames=getAnnotationNames(annotationTree.getAnnotations());
        assertThat(isTypeOf(TestUDT.class,annotationTree.getCurrentType())).isTrue();
        assertThat(annotationNames).containsOnly(Frozen.class.getSimpleName());
        final TypedMap typedMap=annotationTree.getAnnotations().get(Frozen.class);
        assertThat(typedMap.isEmpty()).isTrue();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        aptUtils.messager.printMessage(Diagnostic.Kind.ERROR,ex.getMessage());
      }
    }
);
    Truth.ASSERT.about(JavaSourceSubjectFactory.javaSource()).that(loadClass(TestEntityForAnnotationTree.class)).processedWith(this).compilesWithoutError();
  }
  private Set<String> getAnnotationNames(  Map<Class<? extends Annotation>,TypedMap> annotationInfo){
    return annotationInfo.keySet().stream().map(x -> x.getSimpleName()).collect(Collectors.toSet());
  }
  private VariableElement findFieldByName(  TypeElement typeElement,  String fieldName){
    return ElementFilter.fieldsIn(typeElement.getEnclosedElements()).stream().filter(x -> x.getSimpleName().contentEquals(fieldName)).findFirst().get();
  }
}
