public class FieldInfoParserTest extends AbstractTestProcessor {
  private final InternalNamingStrategy strategy=new SnakeCaseNaming();
  private GlobalParsingContext globalParsingContext=GlobalParsingContext.defaultContext();
  @Before public void setUp(){
    super.testEntityClass=TestEntityForFieldInfo.class;
  }
  @Test public void should_build_partition_column_type() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"id");
      final Tuple2<CodeBlock,ColumnType> codeBlock=parser.buildColumnType(globalParsingContext,elm,"id",typeName);
      assertThat(codeBlock._1().toString()).isEqualTo("info.archinnov.achilles.internals.metamodel.columns.ColumnType.PARTITION");
    }
);
    launchTest();
  }
  @Test public void should_build_clustering_column_type() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"clust1");
      final Tuple2<CodeBlock,ColumnType> codeBlock=parser.buildColumnType(globalParsingContext,elm,"clust1",typeName);
      assertThat(codeBlock._1().toString()).isEqualTo("info.archinnov.achilles.internals.metamodel.columns.ColumnType.CLUSTERING");
    }
);
    launchTest();
  }
  @Test public void should_build_static_column_type() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"staticCol");
      final Tuple2<CodeBlock,ColumnType> codeBlock=parser.buildColumnType(globalParsingContext,elm,"staticCol",typeName);
      assertThat(codeBlock._1().toString()).isEqualTo("info.archinnov.achilles.internals.metamodel.columns.ColumnType.STATIC");
    }
);
    launchTest();
  }
  @Test public void should_build_computed_column_type() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"computed");
      final Tuple2<CodeBlock,ColumnType> codeBlock=parser.buildColumnType(globalParsingContext,elm,"computed",typeName);
      assertThat(codeBlock._1().toString()).isEqualTo("info.archinnov.achilles.internals.metamodel.columns.ColumnType.COMPUTED");
    }
);
    launchTest();
  }
  @Test public void should_build_normal_column_type() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"normal");
      final Tuple2<CodeBlock,ColumnType> codeBlock=parser.buildColumnType(globalParsingContext,elm,"normal",typeName);
      assertThat(codeBlock._1().toString()).isEqualTo("info.archinnov.achilles.internals.metamodel.columns.ColumnType.NORMAL");
    }
);
    launchTest();
  }
  @Test public void should_build_counter_column_type() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"counter");
      final Tuple2<CodeBlock,ColumnType> codeBlock=parser.buildColumnType(globalParsingContext,elm,"counter",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.columns.ColumnType.COUNTER");
    }
);
    launchTest();
  }
  @Test public void should_build_static_counter_column_type() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"staticCounter");
      final Tuple2<CodeBlock,ColumnType> codeBlock=parser.buildColumnType(globalParsingContext,elm,"staticCounter",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.columns.ColumnType.STATIC_COUNTER");
    }
);
    launchTest();
  }
  @Test public void should_fail_if_both_partition_and_clustering_column() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"partitionAndClustering");
      parser.buildColumnType(globalParsingContext,elm,"partitionAndClustering",typeName);
    }
);
    failTestWithMessage("Field 'partitionAndClustering' in class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "cannot have both @PartitionKey AND @ClusteringColumn annotations");
  }
  @Test public void should_fail_if_both_partition_and_static_column() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"partitionAndStatic");
      parser.buildColumnType(globalParsingContext,elm,"partitionAndStatic",typeName);
    }
);
    failTestWithMessage("Field 'partitionAndStatic' in class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "cannot have both @Static AND @PartitionKey annotations");
  }
  @Test public void should_fail_if_both_partition_and_computed_column() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"partitionAndComputed");
      parser.buildColumnType(globalParsingContext,elm,"partitionAndComputed",typeName);
    }
);
    failTestWithMessage("Field 'partitionAndComputed' in class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "cannot have both @Computed AND @PartitionKey annotations");
  }
  @Test public void should_fail_if_both_clustering_and_static_column() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"clusteringAndStatic");
      parser.buildColumnType(globalParsingContext,elm,"clusteringAndStatic",typeName);
    }
);
    failTestWithMessage("Field 'clusteringAndStatic' in class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "cannot have both @Static AND @ClusteringColumn annotations");
  }
  @Test public void should_fail_if_both_clustering_and_computed_column() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"clusteringAndComputed");
      parser.buildColumnType(globalParsingContext,elm,"clusteringAndComputed",typeName);
    }
);
    failTestWithMessage("Field 'clusteringAndComputed' in class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "cannot have both @Computed AND @ClusteringColumn annotations");
  }
  @Test public void should_fail_if_both_static_and_computed_column() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"staticAndComputed");
      parser.buildColumnType(globalParsingContext,elm,"staticAndComputed",typeName);
    }
);
    failTestWithMessage("Field 'staticAndComputed' in class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "cannot have both @Computed AND @Static annotations");
  }
  @Test public void should_fail_if_partition_key_order_zero() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"wrongPartitionOrder");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"wrongPartitionOrder",typeName);
    }
);
    failTestWithMessage("@PartitionKey order on field 'wrongPartitionOrder' of class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "should be > 0, the ordering starts at 1");
  }
  @Test public void should_fail_if_clustering_column_order_zero() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"wrongClusteringOrder");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"wrongClusteringOrder",typeName);
    }
);
    failTestWithMessage("@ClusteringColumn order on field 'wrongClusteringOrder' of class " + "'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo' " + "should be > 0, the ordering starts at 1");
  }
  @Test public void should_build_partition_column_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"id");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final Tuple2<CodeBlock,ColumnInfo> codeBlock=parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"id",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("new info.archinnov.achilles.internals.metamodel.columns.PartitionKeyInfo(1, false)");
    }
);
    launchTest();
  }
  @Test public void should_build_clustering_column_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"clust2");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final Tuple2<CodeBlock,ColumnInfo> codeBlock=parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"clust2",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("new info.archinnov.achilles.internals.metamodel.columns.ClusteringColumnInfo(2, false, com.datastax.driver.core.ClusteringOrder.DESC)");
    }
);
    launchTest();
  }
  @Test public void should_build_static_column_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"staticCol");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final Tuple2<CodeBlock,ColumnInfo> codeBlock=parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"staticCol",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("new info.archinnov.achilles.internals.metamodel.columns.ColumnInfo(false)");
    }
);
    launchTest();
  }
  @Test public void should_build_computed_column_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"computed");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final Tuple2<CodeBlock,ColumnInfo> codeBlock=parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"computed",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("new info.archinnov.achilles.internals.metamodel.columns.ComputedColumnInfo(\"writetime\", \"writetime\", java.util.Arrays.asList(new String[]{\"staticCol\",\"normal\"}), java.lang.Long.class)");
    }
);
    launchTest();
  }
  @Test public void should_build_normal_column_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"normal");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final Tuple2<CodeBlock,ColumnInfo> codeBlock=parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"normal",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("new info.archinnov.achilles.internals.metamodel.columns.ColumnInfo(false)");
    }
);
    launchTest();
  }
  @Test public void should_build_frozen_column_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final TypeName typeName=ClassName.get(TestEntityForFieldInfo.class);
      VariableElement elm=findFieldInType(typeElement,"udt");
      AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final Tuple2<CodeBlock,ColumnInfo> codeBlock=parser.buildColumnInfo(globalParsingContext,annotationTree,elm,"udt",typeName);
      assertThat(codeBlock._1().toString().trim().replaceAll("\n","")).isEqualTo("new info.archinnov.achilles.internals.metamodel.columns.ColumnInfo(true)");
    }
);
    launchTest();
  }
  @Test public void should_build_list_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"indexedList");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.COLLECTION, \"indexed_list_index\", \"\", \"\")");
    }
);
    launchTest();
  }
  @Test public void should_build_list_nested_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"nestedIndexList");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.COLLECTION, \"list_index\", \"\", \"\")");
    }
);
    launchTest();
  }
  @Test public void should_build_list_not_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"notIndexedList");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.noIndex()");
    }
);
    launchTest();
  }
  @Test public void should_build_map_entry_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"indexedEntryMap");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.CUSTOM, \"indexed_entry_map_index\", \"java.lang.Long\", \"\")");
    }
);
    launchTest();
  }
  @Test public void should_build_map_key_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"indexedKeyMap");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.MAP_KEY, \"indexed_key_map_index\", \"\", \"\")");
    }
);
    launchTest();
  }
  @Test public void should_build_map_value_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"indexedValueMap");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.MAP_VALUE, \"indexed_value_map_index\", \"\", \"\")");
    }
);
    launchTest();
  }
  @Test public void should_fail_building_map_with_multiple_indices() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"duplicatedIndicesForMap");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      parser.buildNativeIndexInfo(annotationTree,elm,context);
    }
);
    failTestWithMessage("Cannot have @Index on Map key AND value type in field 'duplicatedIndicesForMap' of class 'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo'",TestEntityForFieldInfo.class);
  }
  @Test public void should_build_not_indexed_map_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"notIndexedMap");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.noIndex()");
    }
);
    launchTest();
  }
  @Test public void should_build_udt_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"indexedUdt");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.NORMAL, \"indexed_udt_index\", \"\", \"\")");
    }
);
    launchTest();
  }
  @Test public void should_build_frozen_list_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"indexedFrozenList");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.forNative(info.archinnov.achilles.internals.metamodel.index.IndexType.FULL, \"indexed_frozen_list_index\", \"\", \"\")");
    }
);
    launchTest();
  }
  @Test public void should_build_not_indexed_column_index_info() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"normal");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      final CodeBlock codeBlock=parser.buildNativeIndexInfo(annotationTree,elm,context)._1();
      assertThat(codeBlock.toString().trim().replaceAll("\n","")).isEqualTo("info.archinnov.achilles.internals.metamodel.index.IndexInfo.noIndex()");
    }
);
    launchTest();
  }
  @Test public void should_generate_field_info_for_consistencyLevel() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"consistencyLevel");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      FieldInfoContext fieldInfo=parser.buildFieldInfo(elm,annotationTree,context);
      assertThat(fieldInfo.codeBlock.toString().trim().replaceAll("\n","")).isEqualTo(readCodeLineFromFile("expected_code/method_parser/should_generate_field_info_for_consistencyLevel.txt"));
    }
);
    launchTest();
  }
  @Test public void should_generate_field_info_for_primitiveBoolean() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"primitiveBoolean");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      FieldInfoContext fieldInfo=parser.buildFieldInfo(elm,annotationTree,context);
      assertThat(fieldInfo.codeBlock.toString().trim().replaceAll("\n","")).isEqualTo(readCodeLineFromFile("expected_code/method_parser/should_generate_field_info_for_primitiveBoolean.txt"));
    }
);
    launchTest();
  }
  @Test public void should_generate_field_info_for_objectBoolean() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"objectBoolean");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      FieldInfoContext fieldInfo=parser.buildFieldInfo(elm,annotationTree,context);
      assertThat(fieldInfo.codeBlock.toString().trim().replaceAll("\n","")).isEqualTo(readCodeLineFromFile("expected_code/method_parser/should_generate_field_info_for_objectBoolean.txt"));
    }
);
    launchTest();
  }
  @Test public void should_generate_field_info_for_UpperCase() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"upperCase");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      FieldInfoContext fieldInfo=parser.buildFieldInfo(elm,annotationTree,context);
      assertThat(fieldInfo.codeBlock.toString().trim().replaceAll("\n","")).isEqualTo(readCodeLineFromFile("expected_code/method_parser/should_generate_field_info_for_UpperCase.txt"));
    }
);
    launchTest();
  }
  @Test public void should_generate_field_info_for_map() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"map");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      FieldInfoContext fieldInfo=parser.buildFieldInfo(elm,annotationTree,context);
      assertThat(fieldInfo.codeBlock.toString().trim().replaceAll("\n","")).isEqualTo(readCodeLineFromFile("expected_code/method_parser/should_generate_field_info_for_map.txt"));
    }
);
    launchTest();
  }
  @Test public void should_generate_field_info_for_column_with_no_setter() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final List<AccessorsExclusionContext> exclusionContexts=Arrays.asList(new AccessorsExclusionContext("columnWithNoSetter",false,true));
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,exclusionContexts,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"columnWithNoSetter");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      FieldInfoContext fieldInfo=parser.buildFieldInfo(elm,annotationTree,context);
      assertThat(fieldInfo.codeBlock.toString().trim().replaceAll("\n","")).isEqualTo(readCodeLineFromFile("expected_code/method_parser/should_generate_field_info_for_column_with_no_setter.txt"));
    }
);
    launchTest();
  }
  @Test public void should_generate_field_info_for_public_final_columns() throws Exception {
    setExec(aptUtils -> {
      final FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final List<AccessorsExclusionContext> exclusionContexts=Arrays.asList(new AccessorsExclusionContext("immutableColumn",true,true));
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,exclusionContexts,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"immutableColumn");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      FieldInfoContext fieldInfo=parser.buildFieldInfo(elm,annotationTree,context);
      assertThat(fieldInfo.codeBlock.toString().trim().replaceAll("\n","")).isEqualTo(readCodeLineFromFile("expected_code/method_parser/should_generate_field_info_for_public_final_columns.txt"));
    }
);
    launchTest();
  }
  @Test public void should_fail_compilation_when_no_getter() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"integer");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      parser.buildFieldInfo(elm,annotationTree,context);
    }
);
    failTestWithMessage("Cannot find getter of names '[getInteger]' for field 'integer' in class 'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo'");
  }
  @Test public void should_fail_compilation_when_no_setter() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"testUdt");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      parser.buildFieldInfo(elm,annotationTree,context);
    }
);
    failTestWithMessage("Cannot find setter 'void setTestUdt(info.archinnov.achilles.internals.sample_classes.parser.field.TestUDT value)' for field 'testUdt' in class 'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo'");
  }
  @Test public void should_fail_compilation_when_no_suitable_setter() throws Exception {
    setExec(aptUtils -> {
      FieldInfoParser parser=new FieldInfoParser(aptUtils);
      final String className=TestEntityForFieldInfo.class.getCanonicalName();
      final TypeElement typeElement=aptUtils.elementUtils.getTypeElement(className);
      final EntityParsingContext context=new EntityParsingContext(typeElement,ClassName.get(TestEntityForFieldInfo.class),strategy,globalParsingContext);
      VariableElement elm=findFieldInType(typeElement,"set");
      final AnnotationTree annotationTree=AnnotationTree.buildFrom(aptUtils,globalParsingContext,elm);
      parser.buildFieldInfo(elm,annotationTree,context);
    }
);
    failTestWithMessage("Cannot find setter 'void setSet(java.util.Set<com.datastax.driver.core.ConsistencyLevel> value)' for field 'set' in class 'info.archinnov.achilles.internals.sample_classes.parser.field_info.TestEntityForFieldInfo'");
  }
}
