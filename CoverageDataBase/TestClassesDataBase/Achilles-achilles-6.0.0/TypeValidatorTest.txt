@RunWith(MockitoJUnitRunner.class) public class TypeValidatorTest {
  @Captor ArgumentCaptor<String> messageCaptor;
  @Captor ArgumentCaptor<Object> objectCaptor;
  @Mock private AptUtils aptUtils;
  private TypeValidator typeValidator=new TypeValidator(){
    @Override public List<TypeName> getAllowedTypes(){
      return TypeUtils.ALLOWED_TYPES_3_10;
    }
  }
;
  @Test public void should_validate_primitiveByte() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("primitiveByte").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
  }
  @Test public void should_validate_objectByte() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("objectByte").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_primitiveByteArray() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("primitiveByteArray").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_objectByteArray() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("objectByteArray").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_listString() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("listString").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(2)).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_setByte() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("setByte").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(2)).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_mapByteArray() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("mapByteArray").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(3)).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_tuple1() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("tuple1").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(2)).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_tuple2() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("tuple2").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(4)).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_tuple3() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("tuple3").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(4)).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_validate_tupleValue() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("tupleValue").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(1)).validateTrue(eq(true),anyString(),anyVararg());
  }
  @Test public void should_fail_on_invalidType() throws Exception {
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("invalidType").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(1)).validateTrue(eq(false),messageCaptor.capture(),objectCaptor.capture(),objectCaptor.capture());
    assertThat(messageCaptor.getValue()).isEqualTo("Type '%s' in '%s' is not a valid type for CQL");
    assertThat(objectCaptor.getAllValues()).containsExactly(typeName.toString(),typeName.toString());
  }
  @Test public void should_fail_on_invalidTypeNestedType() throws Exception {
    String consistencyLevel=ConsistencyLevel.class.getCanonicalName();
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("invalidTypeNestedType").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(3)).validateTrue(eq(true),anyString(),anyVararg());
    verify(aptUtils,times(1)).validateTrue(eq(false),messageCaptor.capture(),objectCaptor.capture(),objectCaptor.capture());
    assertThat(messageCaptor.getValue()).isEqualTo("Type '%s' in '%s' is not a valid type for CQL");
    assertThat(objectCaptor.getAllValues()).containsExactly(consistencyLevel,typeName.toString());
  }
  @Test public void should_fail_on_invalidUpperBound() throws Exception {
    String consistencyLevel=ConsistencyLevel.class.getCanonicalName();
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("invalidUpperBound").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(1)).validateTrue(eq(true),anyString(),anyVararg());
    verify(aptUtils,times(1)).validateTrue(eq(false),messageCaptor.capture(),objectCaptor.capture(),objectCaptor.capture());
    assertThat(messageCaptor.getValue()).isEqualTo("Type '%s' in '%s' is not a valid type for CQL");
    assertThat(objectCaptor.getAllValues()).containsExactly(consistencyLevel,typeName.toString());
  }
  @Test public void should_fail_on_invalidLowerBound() throws Exception {
    String object=Object.class.getCanonicalName();
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("invalidLowerBound").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(1)).validateTrue(eq(true),anyString(),anyVararg());
    verify(aptUtils,times(1)).validateTrue(eq(false),messageCaptor.capture(),objectCaptor.capture(),objectCaptor.capture());
    assertThat(messageCaptor.getValue()).isEqualTo("Type '%s' in '%s' is not a valid type for CQL");
    assertThat(objectCaptor.getAllValues()).containsExactly(object,typeName.toString());
  }
  @Test public void should_fail_on_invalidWildCard() throws Exception {
    String object=Object.class.getCanonicalName();
    final TypeName typeName=TypeName.get(TestTypes.class.getDeclaredField("invalidWildCard").getGenericType());
    typeValidator.validateAllowedTypes(aptUtils,typeName,typeName);
    verify(aptUtils,times(1)).validateTrue(eq(true),anyString(),anyVararg());
    verify(aptUtils,times(1)).validateTrue(eq(false),messageCaptor.capture(),objectCaptor.capture(),objectCaptor.capture());
    assertThat(messageCaptor.getValue()).isEqualTo("Type '%s' in '%s' is not a valid type for CQL");
    assertThat(objectCaptor.getAllValues()).containsExactly(object,typeName.toString());
  }
public static class TestTypes {
    private byte primitiveByte;
    private Byte objectByte;
    private byte[] primitiveByteArray;
    private Byte[] objectByteArray;
    private List<String> listString;
    private Set<Byte> setByte;
    private Map<Integer,Byte[]> mapByteArray;
    private Tuple1<String> tuple1;
    private Tuple2<List<Integer>,Byte[]> tuple2;
    private Tuple3<? extends Date,Integer,Byte> tuple3;
    private TupleValue tupleValue;
    private ConsistencyLevel invalidType;
    private List<Map<Integer,ConsistencyLevel>> invalidTypeNestedType;
    private List<? extends ConsistencyLevel> invalidUpperBound;
    private List<? super String> invalidLowerBound;
    private List<?> invalidWildCard;
  }
}
