public class ConnectionSpecSelectorTest {
static {
    Internal.initializeInstanceForTests();
  }
  public static final SSLHandshakeException RETRYABLE_EXCEPTION=new SSLHandshakeException("Simulated handshake exception");
  private HandshakeCertificates handshakeCertificates=localhost();
  @Test public void nonRetryableIOException() throws Exception {
    ConnectionSpecSelector connectionSpecSelector=createConnectionSpecSelector(ConnectionSpec.MODERN_TLS,ConnectionSpec.COMPATIBLE_TLS);
    SSLSocket socket=createSocketWithEnabledProtocols(TlsVersion.TLS_1_1,TlsVersion.TLS_1_0);
    connectionSpecSelector.configureSecureSocket(socket);
    boolean retry=connectionSpecSelector.connectionFailed(new IOException("Non-handshake exception"));
    assertFalse(retry);
    socket.close();
  }
  @Test public void nonRetryableSSLHandshakeException() throws Exception {
    ConnectionSpecSelector connectionSpecSelector=createConnectionSpecSelector(ConnectionSpec.MODERN_TLS,ConnectionSpec.COMPATIBLE_TLS);
    SSLSocket socket=createSocketWithEnabledProtocols(TlsVersion.TLS_1_1,TlsVersion.TLS_1_0);
    connectionSpecSelector.configureSecureSocket(socket);
    SSLHandshakeException trustIssueException=new SSLHandshakeException("Certificate handshake exception");
    trustIssueException.initCause(new CertificateException());
    boolean retry=connectionSpecSelector.connectionFailed(trustIssueException);
    assertFalse(retry);
    socket.close();
  }
  @Test public void retryableSSLHandshakeException() throws Exception {
    ConnectionSpecSelector connectionSpecSelector=createConnectionSpecSelector(ConnectionSpec.MODERN_TLS,ConnectionSpec.COMPATIBLE_TLS);
    SSLSocket socket=createSocketWithEnabledProtocols(TlsVersion.TLS_1_1,TlsVersion.TLS_1_0);
    connectionSpecSelector.configureSecureSocket(socket);
    boolean retry=connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
    assertTrue(retry);
    socket.close();
  }
  @Test public void someFallbacksSupported() throws Exception {
    ConnectionSpec sslV3=new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS).tlsVersions(TlsVersion.SSL_3_0).build();
    ConnectionSpecSelector connectionSpecSelector=createConnectionSpecSelector(ConnectionSpec.MODERN_TLS,ConnectionSpec.COMPATIBLE_TLS,sslV3);
    TlsVersion[] enabledSocketTlsVersions={TlsVersion.TLS_1_1,TlsVersion.TLS_1_0};
    SSLSocket socket=createSocketWithEnabledProtocols(enabledSocketTlsVersions);
    connectionSpecSelector.configureSecureSocket(socket);
    assertEnabledProtocols(socket,TlsVersion.TLS_1_1,TlsVersion.TLS_1_0);
    boolean retry=connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
    assertTrue(retry);
    socket.close();
    socket=createSocketWithEnabledProtocols(enabledSocketTlsVersions);
    connectionSpecSelector.configureSecureSocket(socket);
    assertEnabledProtocols(socket,TlsVersion.TLS_1_0);
    retry=connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
    assertFalse(retry);
    socket.close();
  }
  private static ConnectionSpecSelector createConnectionSpecSelector(  ConnectionSpec... connectionSpecs){
    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
  }
  private SSLSocket createSocketWithEnabledProtocols(  TlsVersion... tlsVersions) throws IOException {
    SSLSocket socket=(SSLSocket)handshakeCertificates.sslSocketFactory().createSocket();
    socket.setEnabledProtocols(javaNames(tlsVersions));
    return socket;
  }
  private static void assertEnabledProtocols(  SSLSocket socket,  TlsVersion... required){
    Set<String> actual=new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
    Set<String> expected=new LinkedHashSet<>(Arrays.asList(javaNames(required)));
    assertEquals(expected,actual);
  }
  private static String[] javaNames(  TlsVersion... tlsVersions){
    String[] protocols=new String[tlsVersions.length];
    for (int i=0; i < tlsVersions.length; i++) {
      protocols[i]=tlsVersions[i].javaName();
    }
    return protocols;
  }
}
