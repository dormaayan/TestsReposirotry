/** 
 * Test how HTTP/2 interacts with HTTP features. 
 */
@RunWith(Parameterized.class) public final class HttpOverHttp2Test {
  private static final Logger http2Logger=Logger.getLogger(Http2.class.getName());
  private static final HandshakeCertificates handshakeCertificates=localhost();
  @Parameters(name="{0}") public static Collection<Protocol> data(){
    return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE,Protocol.HTTP_2);
  }
  @Rule public final TemporaryFolder tempDir=new TemporaryFolder();
  @Rule public final MockWebServer server=new MockWebServer();
  private OkHttpClient client;
  private Cache cache;
  private TestLogHandler http2Handler=new TestLogHandler();
  private Level previousLevel;
  private String scheme;
  private Protocol protocol;
  public HttpOverHttp2Test(  Protocol protocol){
    this.client=protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
    this.scheme=protocol == Protocol.HTTP_2 ? "https" : "http";
    this.protocol=protocol;
  }
  private static OkHttpClient buildH2PriorKnowledgeClient(){
    return defaultClient().newBuilder().protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE)).build();
  }
  private static OkHttpClient buildHttp2Client(){
    return defaultClient().newBuilder().protocols(Arrays.asList(Protocol.HTTP_2,Protocol.HTTP_1_1)).sslSocketFactory(handshakeCertificates.sslSocketFactory(),handshakeCertificates.trustManager()).hostnameVerifier(new RecordingHostnameVerifier()).build();
  }
  @Before public void setUp(){
    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
    }
 else {
      server.useHttps(handshakeCertificates.sslSocketFactory(),false);
    }
    cache=new Cache(tempDir.getRoot(),Integer.MAX_VALUE);
    http2Logger.addHandler(http2Handler);
    previousLevel=http2Logger.getLevel();
    http2Logger.setLevel(Level.FINE);
  }
  @After public void tearDown(){
    Authenticator.setDefault(null);
    http2Logger.removeHandler(http2Handler);
    http2Logger.setLevel(previousLevel);
    client.connectionPool().evictAll();
  }
  @Test public void get() throws Exception {
    server.enqueue(new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet"));
    Call call=client.newCall(new Request.Builder().url(server.url("/foo")).build());
    Response response=call.execute();
    assertEquals("ABCDE",response.body().string());
    assertEquals(200,response.code());
    assertEquals("",response.message());
    assertEquals(protocol,response.protocol());
    RecordedRequest request=server.takeRequest();
    assertEquals("GET /foo HTTP/1.1",request.getRequestLine());
    assertEquals(scheme,request.getHeader(":scheme"));
    assertEquals(server.getHostName() + ":" + server.getPort(),request.getHeader(":authority"));
  }
  @Test public void emptyResponse() throws IOException {
    server.enqueue(new MockResponse());
    Call call=client.newCall(new Request.Builder().url(server.url("/foo")).build());
    Response response=call.execute();
    assertEquals(-1,response.body().byteStream().read());
    response.body().close();
  }
  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
    final byte[] postBytes="FGHIJ".getBytes(Util.UTF_8);
    server.enqueue(new MockResponse().setBody("ABCDE"));
    Call call=client.newCall(new Request.Builder().url(server.url("/foo")).post(new RequestBody(){
      @Override public MediaType contentType(){
        return MediaType.get("text/plain; charset=utf-8");
      }
      @Override public void writeTo(      BufferedSink sink) throws IOException {
        sink.write(postBytes);
      }
    }
).build());
    Response response=call.execute();
    assertEquals("ABCDE",response.body().string());
    RecordedRequest request=server.takeRequest();
    assertEquals("POST /foo HTTP/1.1",request.getRequestLine());
    assertArrayEquals(postBytes,request.getBody().readByteArray());
    assertNull(request.getHeader("Content-Length"));
  }
  @Test public void userSuppliedContentLengthHeader() throws Exception {
    final byte[] postBytes="FGHIJ".getBytes(Util.UTF_8);
    server.enqueue(new MockResponse().setBody("ABCDE"));
    Call call=client.newCall(new Request.Builder().url(server.url("/foo")).post(new RequestBody(){
      @Override public MediaType contentType(){
        return MediaType.get("text/plain; charset=utf-8");
      }
      @Override public long contentLength(){
        return postBytes.length;
      }
      @Override public void writeTo(      BufferedSink sink) throws IOException {
        sink.write(postBytes);
      }
    }
).build());
    Response response=call.execute();
    assertEquals("ABCDE",response.body().string());
    RecordedRequest request=server.takeRequest();
    assertEquals("POST /foo HTTP/1.1",request.getRequestLine());
    assertArrayEquals(postBytes,request.getBody().readByteArray());
    assertEquals(postBytes.length,Integer.parseInt(request.getHeader("Content-Length")));
  }
  @Test public void closeAfterFlush() throws Exception {
    final byte[] postBytes="FGHIJ".getBytes(Util.UTF_8);
    server.enqueue(new MockResponse().setBody("ABCDE"));
    Call call=client.newCall(new Request.Builder().url(server.url("/foo")).post(new RequestBody(){
      @Override public MediaType contentType(){
        return MediaType.get("text/plain; charset=utf-8");
      }
      @Override public long contentLength(){
        return postBytes.length;
      }
      @Override public void writeTo(      BufferedSink sink) throws IOException {
        sink.write(postBytes);
        sink.flush();
        sink.close();
      }
    }
).build());
    Response response=call.execute();
    assertEquals("ABCDE",response.body().string());
    RecordedRequest request=server.takeRequest();
    assertEquals("POST /foo HTTP/1.1",request.getRequestLine());
    assertArrayEquals(postBytes,request.getBody().readByteArray());
    assertEquals(postBytes.length,Integer.parseInt(request.getHeader("Content-Length")));
  }
  @Test public void connectionReuse() throws Exception {
    server.enqueue(new MockResponse().setBody("ABCDEF"));
    server.enqueue(new MockResponse().setBody("GHIJKL"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/r1")).build());
    Call call2=client.newCall(new Request.Builder().url(server.url("/r1")).build());
    Response response1=call1.execute();
    Response response2=call2.execute();
    assertEquals("ABC",response1.body().source().readUtf8(3));
    assertEquals("GHI",response2.body().source().readUtf8(3));
    assertEquals("DEF",response1.body().source().readUtf8(3));
    assertEquals("JKL",response2.body().source().readUtf8(3));
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
    response1.close();
    response2.close();
  }
  @Test public void connectionWindowUpdateAfterCanceling() throws Exception {
    server.enqueue(new MockResponse().setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
    server.enqueue(new MockResponse().setBody("abc"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
    call1.cancel();
    assertFalse("Call should not have completed successfully.",Util.discard(response1.body().source(),1,TimeUnit.SECONDS));
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("abc",response2.body().string());
  }
  /** 
 * Wait for the client to receive  {@code dataLength} DATA frames. 
 */
  private void waitForDataFrames(  int dataLength) throws Exception {
    int expectedFrameCount=dataLength / 16384;
    int dataFrameCount=0;
    while (dataFrameCount < expectedFrameCount) {
      String log=http2Handler.take();
      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
        dataFrameCount++;
      }
    }
  }
  @Test public void connectionWindowUpdateOnClose() throws Exception {
    server.enqueue(new MockResponse().setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
    server.enqueue(new MockResponse().setBody("abc"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
    call1.cancel();
    response1.close();
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("abc",response2.body().string());
  }
  @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
    server.enqueue(new MockResponse().setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE])));
    server.enqueue(new MockResponse().setBody("abc"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
    assertEquals(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE,response1.body().contentLength());
    int read=response1.body().source().read(new byte[8192]);
    assertEquals(8192,read);
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals(200,response2.code());
    response1.close();
    assertEquals("abc",response2.body().string());
  }
  /** 
 * https://github.com/square/okhttp/issues/373 
 */
  @Test @Ignore public void synchronousRequest() throws Exception {
    server.enqueue(new MockResponse().setBody("A"));
    server.enqueue(new MockResponse().setBody("A"));
    ExecutorService executor=Executors.newCachedThreadPool();
    CountDownLatch countDownLatch=new CountDownLatch(2);
    executor.execute(new AsyncRequest("/r1",countDownLatch));
    executor.execute(new AsyncRequest("/r2",countDownLatch));
    countDownLatch.await();
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
  }
  @Test public void gzippedResponseBody() throws Exception {
    server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip").setBody(gzip("ABCABCABC")));
    Call call=client.newCall(new Request.Builder().url(server.url("/r1")).build());
    Response response=call.execute();
    assertEquals("ABCABCABC",response.body().string());
  }
  @Test public void authenticate() throws Exception {
    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED).addHeader("www-authenticate: Basic realm=\"protected area\"").setBody("Please authenticate."));
    server.enqueue(new MockResponse().setBody("Successful auth!"));
    String credential=Credentials.basic("username","password");
    client=client.newBuilder().authenticator(new RecordingOkAuthenticator(credential,"Basic")).build();
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("Successful auth!",response.body().string());
    RecordedRequest denied=server.takeRequest();
    assertNull(denied.getHeader("Authorization"));
    RecordedRequest accepted=server.takeRequest();
    assertEquals("GET / HTTP/1.1",accepted.getRequestLine());
    assertEquals(credential,accepted.getHeader("Authorization"));
  }
  @Test public void redirect() throws Exception {
    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP).addHeader("Location: /foo").setBody("This page has moved!"));
    server.enqueue(new MockResponse().setBody("This is the new location!"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("This is the new location!",response.body().string());
    RecordedRequest request1=server.takeRequest();
    assertEquals("/",request1.getPath());
    RecordedRequest request2=server.takeRequest();
    assertEquals("/foo",request2.getPath());
  }
  @Test public void readAfterLastByte() throws Exception {
    server.enqueue(new MockResponse().setBody("ABC"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    InputStream in=response.body().byteStream();
    assertEquals('A',in.read());
    assertEquals('B',in.read());
    assertEquals('C',in.read());
    assertEquals(-1,in.read());
    assertEquals(-1,in.read());
    in.close();
  }
  @Test public void readResponseHeaderTimeout() throws Exception {
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
    server.enqueue(new MockResponse().setBody("A"));
    client=client.newBuilder().readTimeout(1000,MILLISECONDS).build();
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    try {
      call1.execute();
      fail("Should have timed out!");
    }
 catch (    SocketTimeoutException expected) {
      assertEquals("timeout",expected.getMessage());
    }
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("A",response2.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
  }
  /** 
 * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
 */
  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
    char[] body=new char[4096];
    Arrays.fill(body,'y');
    server.enqueue(new MockResponse().setBody(new String(body)).throttleBody(1024,1,SECONDS));
    client=client.newBuilder().readTimeout(2,SECONDS).build();
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals(new String(body),response.body().string());
  }
  /** 
 * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in time.
 */
  @Test public void readTimeoutOnSlowConnection() throws Exception {
    String body=TestUtil.repeat('y',2048);
    server.enqueue(new MockResponse().setBody(body).throttleBody(1024,1,SECONDS));
    server.enqueue(new MockResponse().setBody(body));
    client=client.newBuilder().readTimeout(500,MILLISECONDS).build();
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    try {
      response1.body().string();
      fail("Should have timed out!");
    }
 catch (    SocketTimeoutException expected) {
      assertEquals("timeout",expected.getMessage());
    }
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals(body,response2.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
  }
  @Test public void connectionTimeout() throws Exception {
    server.enqueue(new MockResponse().setBody("A").setBodyDelay(1,SECONDS));
    OkHttpClient client1=client.newBuilder().readTimeout(2000,MILLISECONDS).build();
    Call call1=client1.newCall(new Request.Builder().url(server.url("/")).build());
    OkHttpClient client2=client.newBuilder().readTimeout(200,MILLISECONDS).build();
    Call call2=client2.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    assertEquals("A",response1.body().string());
    try {
      call2.execute();
      fail();
    }
 catch (    IOException expected) {
    }
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
  }
  @Test public void responsesAreCached() throws IOException {
    client=client.newBuilder().cache(cache).build();
    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    assertEquals("A",response1.body().string());
    assertEquals(1,cache.requestCount());
    assertEquals(1,cache.networkCount());
    assertEquals(0,cache.hitCount());
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("A",response2.body().string());
    Call call3=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response3=call3.execute();
    assertEquals("A",response3.body().string());
    assertEquals(3,cache.requestCount());
    assertEquals(1,cache.networkCount());
    assertEquals(2,cache.hitCount());
  }
  @Test public void conditionalCache() throws IOException {
    client=client.newBuilder().cache(cache).build();
    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    assertEquals("A",response1.body().string());
    assertEquals(1,cache.requestCount());
    assertEquals(1,cache.networkCount());
    assertEquals(0,cache.hitCount());
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("A",response2.body().string());
    assertEquals(2,cache.requestCount());
    assertEquals(2,cache.networkCount());
    assertEquals(1,cache.hitCount());
  }
  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
    client=client.newBuilder().cache(cache).build();
    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    assertEquals("AB",response1.body().source().readUtf8(2));
    response1.body().close();
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("ABCD",response2.body().source().readUtf8());
    response2.body().close();
  }
  @Test public void sendRequestCookies() throws Exception {
    RecordingCookieJar cookieJar=new RecordingCookieJar();
    Cookie requestCookie=new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build();
    cookieJar.enqueueRequestCookies(requestCookie);
    client=client.newBuilder().cookieJar(cookieJar).build();
    server.enqueue(new MockResponse());
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("",response.body().string());
    RecordedRequest request=server.takeRequest();
    assertEquals("a=b",request.getHeader("Cookie"));
  }
  @Test public void receiveResponseCookies() throws Exception {
    RecordingCookieJar cookieJar=new RecordingCookieJar();
    client=client.newBuilder().cookieJar(cookieJar).build();
    server.enqueue(new MockResponse().addHeader("set-cookie: a=b"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("",response.body().string());
    cookieJar.assertResponseCookies("a=b; path=/");
  }
  /** 
 * https://github.com/square/okhttp/issues/1191 
 */
  @Ignore @Test public void cancelWithStreamNotCompleted() throws Exception {
    client.connectionPool().evictAll();
    assertEquals(0,client.connectionPool().connectionCount());
    server.enqueue(new MockResponse().setBody("abc"));
    server.enqueue(new MockResponse().setBody("def"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call1.execute();
    call1.cancel();
    assertEquals(1,client.connectionPool().connectionCount());
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("def",response2.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    response.close();
  }
  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
    server.enqueue(new MockResponse().setBody("abc"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("abc",response.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
  }
  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
    server.enqueue(new MockResponse().setBody("abc"));
    client=client.newBuilder().dns(new DoubleInetAddressDns()).build();
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("abc",response.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(0,server.takeRequest().getSequenceNumber());
  }
  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.httpCode));
    server.enqueue(new MockResponse().setBody("abc"));
    client=client.newBuilder().dns(new DoubleInetAddressDns()).build();
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("abc",response.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
    assertEquals(0,server.takeRequest().getSequenceNumber());
  }
  @Test public void recoverFromCancelReusesConnection() throws Exception {
    server.enqueue(new MockResponse().setBodyDelay(10,TimeUnit.SECONDS).setBody("abc"));
    server.enqueue(new MockResponse().setBody("def"));
    client=client.newBuilder().dns(new DoubleInetAddressDns()).build();
    callAndCancel(0);
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("def",response.body().string());
    assertEquals(1,server.takeRequest().getSequenceNumber());
  }
  @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
    server.enqueue(new MockResponse().setBodyDelay(10,TimeUnit.SECONDS).setBody("abc"));
    server.enqueue(new MockResponse().setBodyDelay(10,TimeUnit.SECONDS).setBody("def"));
    server.enqueue(new MockResponse().setBody("ghi"));
    client=client.newBuilder().dns(new DoubleInetAddressDns()).build();
    callAndCancel(0);
    callAndCancel(1);
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("ghi",response.body().string());
    assertEquals(2,server.takeRequest().getSequenceNumber());
  }
  /** 
 * Make a call and canceling it as soon as it's accepted by the server. 
 */
  private void callAndCancel(  int expectedSequenceNumber) throws Exception {
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    call.enqueue(new Callback(){
      @Override public void onFailure(      Call call1,      IOException e){
      }
      @Override public void onResponse(      Call call1,      Response response){
      }
    }
);
    assertEquals(expectedSequenceNumber,server.takeRequest().getSequenceNumber());
    call.cancel();
  }
  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
  }
  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
  }
  private void noRecoveryFromErrorWithRetryDisabled(  ErrorCode errorCode) throws Exception {
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(errorCode.httpCode));
    server.enqueue(new MockResponse().setBody("abc"));
    client=client.newBuilder().retryOnConnectionFailure(false).build();
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    try {
      call.execute();
      fail();
    }
 catch (    StreamResetException expected) {
      assertEquals(errorCode,expected.errorCode);
    }
  }
  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {
    server.enqueue(new MockResponse().setResponseCode(401));
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START).setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
    server.enqueue(new MockResponse().setBody("DEF"));
    server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location","/foo"));
    server.enqueue(new MockResponse().setBody("ABC"));
    final CountDownLatch latch=new CountDownLatch(1);
    final BlockingQueue<String> responses=new SynchronousQueue<>();
    okhttp3.Authenticator authenticator=new okhttp3.Authenticator(){
      @Override public Request authenticate(      Route route,      Response response) throws IOException {
        responses.offer(response.body().string());
        try {
          latch.await();
        }
 catch (        InterruptedException e) {
          throw new AssertionError();
        }
        return response.request();
      }
    }
;
    OkHttpClient blockingAuthClient=client.newBuilder().authenticator(authenticator).build();
    Callback callback=new Callback(){
      @Override public void onFailure(      Call call,      IOException e){
        fail();
      }
      @Override public void onResponse(      Call call,      Response response) throws IOException {
        responses.offer(response.body().string());
      }
    }
;
    Request request=new Request.Builder().url(server.url("/")).build();
    blockingAuthClient.newCall(request).enqueue(callback);
    String response1=responses.take();
    assertEquals("",response1);
    assertEquals(0,server.takeRequest().getSequenceNumber());
    client.newCall(request).enqueue(callback);
    String response2=responses.take();
    assertEquals("DEF",response2);
    assertEquals(1,server.takeRequest().getSequenceNumber());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    latch.countDown();
    String response3=responses.take();
    assertEquals("ABC",response3);
    assertEquals(1,server.takeRequest().getSequenceNumber());
    assertEquals(2,server.takeRequest().getSequenceNumber());
  }
  @Test public void nonAsciiResponseHeader() throws Exception {
    server.enqueue(new MockResponse().addHeaderLenient("Alpha","α").addHeaderLenient("β","Beta"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    response.close();
    assertEquals("α",response.header("Alpha"));
    assertEquals("Beta",response.header("β"));
  }
  @Test public void serverSendsPushPromise_GET() throws Exception {
    PushPromise pushPromise=new PushPromise("GET","/foo/bar",Headers.of("foo","bar"),new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
    server.enqueue(new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet").withPush(pushPromise));
    Call call=client.newCall(new Request.Builder().url(server.url("/foo")).build());
    Response response=call.execute();
    assertEquals("ABCDE",response.body().string());
    assertEquals(200,response.code());
    assertEquals("",response.message());
    RecordedRequest request=server.takeRequest();
    assertEquals("GET /foo HTTP/1.1",request.getRequestLine());
    assertEquals(scheme,request.getHeader(":scheme"));
    assertEquals(server.getHostName() + ":" + server.getPort(),request.getHeader(":authority"));
    RecordedRequest pushedRequest=server.takeRequest();
    assertEquals("GET /foo/bar HTTP/1.1",pushedRequest.getRequestLine());
    assertEquals("bar",pushedRequest.getHeader("foo"));
  }
  @Test public void serverSendsPushPromise_HEAD() throws Exception {
    PushPromise pushPromise=new PushPromise("HEAD","/foo/bar",Headers.of("foo","bar"),new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
    server.enqueue(new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet").withPush(pushPromise));
    Call call=client.newCall(new Request.Builder().url(server.url("/foo")).build());
    Response response=call.execute();
    assertEquals("ABCDE",response.body().string());
    assertEquals(200,response.code());
    assertEquals("",response.message());
    RecordedRequest request=server.takeRequest();
    assertEquals("GET /foo HTTP/1.1",request.getRequestLine());
    assertEquals(scheme,request.getHeader(":scheme"));
    assertEquals(server.getHostName() + ":" + server.getPort(),request.getHeader(":authority"));
    RecordedRequest pushedRequest=server.takeRequest();
    assertEquals("HEAD /foo/bar HTTP/1.1",pushedRequest.getRequestLine());
    assertEquals("bar",pushedRequest.getHeader("foo"));
  }
  @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
    server.enqueue(new MockResponse().setBody("ABC"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).method("DELETE",null).build());
    Response response=call.execute();
    assertEquals("ABC",response.body().string());
    assertEquals(protocol,response.protocol());
    List<String> logs=http2Handler.takeAll();
    assertThat("header logged",firstFrame(logs,"HEADERS"),containsString("HEADERS       END_STREAM|END_HEADERS"));
  }
  @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
    server.enqueue(new MockResponse().setBody("ABC"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).method("DELETE",Util.EMPTY_REQUEST).build());
    Response response=call.execute();
    assertEquals("ABC",response.body().string());
    assertEquals(protocol,response.protocol());
    List<String> logs=http2Handler.takeAll();
    assertThat("header logged",firstFrame(logs,"HEADERS"),containsString("HEADERS       END_HEADERS"));
    assertThat("data logged",firstFrame(logs,"DATA"),containsString("0 DATA          END_STREAM"));
  }
  @Test public void pingsTransmitted() throws Exception {
    client=client.newBuilder().pingInterval(500,TimeUnit.MILLISECONDS).build();
    server.enqueue(new MockResponse().setBodyDelay(750,TimeUnit.MILLISECONDS).setBody("ABC"));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("ABC",response.body().string());
    assertEquals(protocol,response.protocol());
    List<String> logs=http2Handler.takeAll();
    assertEquals(1,countFrames(logs,"FINE: >> 0x00000000     8 PING          "));
    assertEquals(1,countFrames(logs,"FINE: << 0x00000000     8 PING          "));
    assertEquals(1,countFrames(logs,"FINE: >> 0x00000000     8 PING          ACK"));
    assertEquals(1,countFrames(logs,"FINE: << 0x00000000     8 PING          ACK"));
  }
  @Test public void missingPongsFailsConnection() throws Exception {
    client=client.newBuilder().readTimeout(10,TimeUnit.SECONDS).pingInterval(500,TimeUnit.MILLISECONDS).build();
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    long executeAtNanos=System.nanoTime();
    try {
      call.execute();
      fail();
    }
 catch (    StreamResetException expected) {
      assertEquals("stream was reset: PROTOCOL_ERROR",expected.getMessage());
    }
    long elapsedUntilFailure=System.nanoTime() - executeAtNanos;
    assertEquals(1000,TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure),250d);
    List<String> logs=http2Handler.takeAll();
    assertEquals(1,countFrames(logs,"FINE: >> 0x00000000     8 PING          "));
    assertEquals(0,countFrames(logs,"FINE: << 0x00000000     8 PING          ACK"));
  }
  private String firstFrame(  List<String> logs,  String type){
    for (    String log : logs) {
      if (log.contains(type)) {
        return log;
      }
    }
    return null;
  }
  private int countFrames(  List<String> logs,  String message){
    int result=0;
    for (    String log : logs) {
      if (log.equals(message)) {
        result++;
      }
    }
    return result;
  }
  /** 
 * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and confirm that the third concurrent request prepared a new connection.
 */
  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
    Settings settings=new Settings();
    settings.set(Settings.MAX_CONCURRENT_STREAMS,2);
    server.enqueue(new MockResponse().withSettings(settings));
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("",response.body().string());
    server.enqueue(new MockResponse().setBody("ABC"));
    server.enqueue(new MockResponse().setBody("DEF"));
    server.enqueue(new MockResponse().setBody("GHI"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    Call call3=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response3=call3.execute();
    assertEquals("ABC",response1.body().string());
    assertEquals("DEF",response2.body().string());
    assertEquals("GHI",response3.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(1,server.takeRequest().getSequenceNumber());
    assertEquals(2,server.takeRequest().getSequenceNumber());
    assertEquals(0,server.takeRequest().getSequenceNumber());
  }
  @Test public void connectionNotReusedAfterShutdown() throws Exception {
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_END).setBody("ABC"));
    server.enqueue(new MockResponse().setBody("DEF"));
    Call call1=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response1=call1.execute();
    assertEquals("ABC",response1.body().string());
    Call call2=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response2=call2.execute();
    assertEquals("DEF",response2.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(0,server.takeRequest().getSequenceNumber());
  }
  /** 
 * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to writing our request, we get a GOAWAY frame from the server.
 */
  @Test public void connectionShutdownAfterHealthCheck() throws Exception {
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_END).setBody("ABC"));
    server.enqueue(new MockResponse().setBody("DEF"));
    OkHttpClient client2=client.newBuilder().addNetworkInterceptor(new Interceptor(){
      boolean executedCall;
      @Override public Response intercept(      Chain chain) throws IOException {
        if (!executedCall) {
          executedCall=true;
          Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
          Response response=call.execute();
          assertEquals("ABC",response.body().string());
          RealConnection connection=(RealConnection)chain.connection();
          while (connection.isHealthy(false))           ;
        }
        return chain.proceed(chain.request());
      }
    }
).build();
    Call call=client2.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("DEF",response.body().string());
    assertEquals(0,server.takeRequest().getSequenceNumber());
    assertEquals(0,server.takeRequest().getSequenceNumber());
  }
  @Test public void responseHeadersAfterGoaway() throws Exception {
    server.enqueue(new MockResponse().setHeadersDelay(1,SECONDS).setBody("ABC"));
    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_END).setBody("DEF"));
    final BlockingQueue<String> bodies=new SynchronousQueue<>();
    Callback callback=new Callback(){
      @Override public void onResponse(      Call call,      Response response) throws IOException {
        bodies.add(response.body().string());
      }
      @Override public void onFailure(      Call call,      IOException e){
        System.out.println(e);
      }
    }
;
    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
    assertEquals("DEF",bodies.poll(2,SECONDS));
    assertEquals("ABC",bodies.poll(2,SECONDS));
    assertEquals(2,server.getRequestCount());
  }
  /** 
 * We don't know if the connection will support HTTP/2 until after we've connected. When multiple connections are requested concurrently OkHttp will pessimistically connect multiple times, then close any unnecessary connections. This test confirms that behavior works as intended. <p>This test uses proxy tunnels to get a hook while a connection is being established.
 */
  @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
    assumeTrue(protocol == Protocol.HTTP_2);
    server.useHttps(handshakeCertificates.sslSocketFactory(),true);
    client.connectionPool().evictAll();
    final QueueDispatcher queueDispatcher=new QueueDispatcher();
    queueDispatcher.enqueueResponse(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    queueDispatcher.enqueueResponse(new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
    queueDispatcher.enqueueResponse(new MockResponse().setBody("call2 response"));
    queueDispatcher.enqueueResponse(new MockResponse().setBody("call1 response"));
    server.setDispatcher(new Dispatcher(){
      int requestCount;
      @Override public MockResponse dispatch(      RecordedRequest request) throws InterruptedException {
        MockResponse result=queueDispatcher.dispatch(request);
        requestCount++;
        if (requestCount == 1) {
          try {
            Call call2=client.newCall(new Request.Builder().url("https://android.com/call2").build());
            Response response2=call2.execute();
            assertEquals("call2 response",response2.body().string());
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        return result;
      }
      @Override public MockResponse peek(){
        return queueDispatcher.peek();
      }
      @Override public void shutdown(){
        queueDispatcher.shutdown();
      }
    }
);
    client=client.newBuilder().proxy(server.toProxyAddress()).build();
    Call call1=client.newCall(new Request.Builder().url("https://android.com/call1").build());
    Response response2=call1.execute();
    assertEquals("call1 response",response2.body().string());
    RecordedRequest call1Connect=server.takeRequest();
    assertEquals("CONNECT",call1Connect.getMethod());
    assertEquals(0,call1Connect.getSequenceNumber());
    RecordedRequest call2Connect=server.takeRequest();
    assertEquals("CONNECT",call2Connect.getMethod());
    assertEquals(0,call2Connect.getSequenceNumber());
    RecordedRequest call2Get=server.takeRequest();
    assertEquals("GET",call2Get.getMethod());
    assertEquals("/call2",call2Get.getPath());
    assertEquals(0,call2Get.getSequenceNumber());
    RecordedRequest call1Get=server.takeRequest();
    assertEquals("GET",call1Get.getMethod());
    assertEquals("/call1",call1Get.getPath());
    assertEquals(1,call1Get.getSequenceNumber());
    assertEquals(1,client.connectionPool().connectionCount());
  }
  /** 
 * https://github.com/square/okhttp/issues/3103 
 */
  @Test public void domainFronting() throws Exception {
    client=client.newBuilder().addNetworkInterceptor(new Interceptor(){
      @Override public Response intercept(      Chain chain) throws IOException {
        Request request=chain.request().newBuilder().header("Host","privateobject.com").build();
        return chain.proceed(request);
      }
    }
).build();
    server.enqueue(new MockResponse());
    Call call=client.newCall(new Request.Builder().url(server.url("/")).build());
    Response response=call.execute();
    assertEquals("",response.body().string());
    RecordedRequest recordedRequest=server.takeRequest();
    assertEquals("privateobject.com",recordedRequest.getHeader(":authority"));
  }
  private Buffer gzip(  String bytes) throws IOException {
    Buffer bytesOut=new Buffer();
    BufferedSink sink=Okio.buffer(new GzipSink(bytesOut));
    sink.writeUtf8(bytes);
    sink.close();
    return bytesOut;
  }
class AsyncRequest implements Runnable {
    String path;
    CountDownLatch countDownLatch;
    AsyncRequest(    String path,    CountDownLatch countDownLatch){
      this.path=path;
      this.countDownLatch=countDownLatch;
    }
    @Override public void run(){
      try {
        Call call=client.newCall(new Request.Builder().url(server.url(path)).build());
        Response response=call.execute();
        assertEquals("A",response.body().string());
        countDownLatch.countDown();
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
  }
}
