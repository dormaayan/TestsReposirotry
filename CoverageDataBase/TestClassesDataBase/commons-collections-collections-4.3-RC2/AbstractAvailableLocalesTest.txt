@RunWith(Parameterized.class) public abstract class AbstractAvailableLocalesTest {
  @Parameters(name="{0}") public static Locale[] getSortedAvailableLocales(){
    final Locale[] availableLocales=Locale.getAvailableLocales();
    Arrays.sort(availableLocales,new ObjectToStringComparator());
    return availableLocales;
  }
  public static List<Locale> getSortedDeclaredLocales(){
    final Field[] allFields=FieldUtils.getAllFields(Locale.class);
    final List<Locale> availableLocales=new ArrayList<>(allFields.length);
    for (    final Field field : allFields) {
      final int modifiers=field.getModifiers();
      if (field.getType() == Locale.class && Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers)) {
        try {
          availableLocales.add((Locale)field.get(Locale.class));
        }
 catch (        IllegalArgumentException|IllegalAccessException e) {
          throw new IllegalStateException("Field " + field,e);
        }
      }
    }
    Collections.sort(availableLocales,new ObjectToStringComparator());
    return availableLocales;
  }
  private final Locale locale;
  @Rule public final SetDefaultLocaleTestRule rule;
  public AbstractAvailableLocalesTest(  final Locale locale){
    super();
    this.locale=locale;
    this.rule=new SetDefaultLocaleTestRule(locale);
  }
  public Locale getLocale(){
    return locale;
  }
}
