/** 
 * Tests for ReverseComparator.
 */
public class ReverseComparatorTest extends AbstractComparatorTest<Integer> {
  public ReverseComparatorTest(  final String testName){
    super(testName);
  }
  /** 
 * For the purposes of this test, return a ReverseComparator that wraps the java.util.Collections.reverseOrder() Comparator.  The resulting comparator should sort according to natural Order.  (Note: we wrap a Comparator taken from the JDK so that we can save a "canonical" form in SVN.
 * @return Comparator that returns "natural" order
 */
  @Override public Comparator<Integer> makeObject(){
    return new ReverseComparator<>(Collections.<Integer>reverseOrder());
  }
  @Override public String getCompatibilityVersion(){
    return "4";
  }
  @Override public List<Integer> getComparableObjectsOrdered(){
    final List<Integer> list=new LinkedList<>();
    list.add(Integer.valueOf(1));
    list.add(Integer.valueOf(2));
    list.add(Integer.valueOf(3));
    list.add(Integer.valueOf(4));
    list.add(Integer.valueOf(5));
    return list;
  }
  /** 
 * Override this inherited test since Collections.reverseOrder doesn't adhere to the "soft" Comparator contract, and we've already "canonized" the comparator returned by makeComparator.
 */
  @Override @Test public void testSerializeDeserializeThenCompare() throws Exception {
    final Comparator<?> comp=new ReverseComparator<>(new ComparableComparator<String>());
    final ByteArrayOutputStream buffer=new ByteArrayOutputStream();
    final ObjectOutputStream out=new ObjectOutputStream(buffer);
    out.writeObject(comp);
    out.close();
    final ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));
    final Object dest=in.readObject();
    in.close();
    assertEquals("obj != deserialize(serialize(obj))",comp,dest);
  }
}
