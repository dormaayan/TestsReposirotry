@RunWith(DefaultServer.class) @ProxyIgnore public class LoadBalancerConnectionPoolingTestCase {
  public static final int TTL=2000;
  private static Undertow undertow;
  private static final Set<ServerConnection> activeConnections=Collections.newSetFromMap(new ConcurrentHashMap<>());
  static final String host=DefaultServer.getHostAddress("default");
  static int port=DefaultServer.getHostPort("default");
  @BeforeClass public static void before() throws Exception {
    ProxyHandler proxyHandler=ProxyHandler.builder().setProxyClient(new LoadBalancingProxyClient().setConnectionsPerThread(1).setSoftMaxConnectionsPerThread(0).setTtl(TTL).setMaxQueueSize(1000).addHost(new URI("http",null,host,port,null,null,null),"s1")).setMaxRequestTime(10000).build();
    undertow=Undertow.builder().setIoThreads(1).addHttpListener(port + 1,host).setHandler(proxyHandler).build();
    undertow.start();
    DefaultServer.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      HttpServerExchange exchange) throws Exception {
        final ServerConnection con=exchange.getConnection();
        if (!activeConnections.contains(con)) {
          System.out.println("added " + con);
          activeConnections.add(con);
          con.addCloseListener(new ServerConnection.CloseListener(){
            @Override public void closed(            ServerConnection connection){
              System.out.println("Closed " + connection);
              activeConnections.remove(connection);
            }
          }
);
        }
      }
    }
);
  }
  @AfterClass public static void after(){
    undertow.stop();
  }
  @Test public void shouldReduceConnectionPool() throws Exception {
    ExecutorService executorService=Executors.newFixedThreadPool(10);
    PoolingClientConnectionManager conman=new PoolingClientConnectionManager();
    conman.setDefaultMaxPerRoute(20);
    final TestHttpClient client=new TestHttpClient(conman);
    int requests=20;
    final CountDownLatch latch=new CountDownLatch(requests);
    long ttlStartExpire=TTL + System.currentTimeMillis();
    try {
      for (int i=0; i < requests; ++i) {
        executorService.submit(new Runnable(){
          @Override public void run(){
            HttpGet get=new HttpGet("http://" + host + ":"+ (port + 1));
            try {
              HttpResponse response=client.execute(get);
              Assert.assertEquals(StatusCodes.OK,response.getStatusLine().getStatusCode());
              HttpClientUtils.readResponse(response);
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
 finally {
              latch.countDown();
            }
          }
        }
);
      }
      if (!latch.await(2000,TimeUnit.MILLISECONDS)) {
        Assert.fail();
      }
    }
  finally {
      client.getConnectionManager().shutdown();
      executorService.shutdown();
    }
    if (activeConnections.size() != 1) {
      if (System.currentTimeMillis() < ttlStartExpire) {
        Assert.fail("there should still be a connection");
      }
    }
    long end=System.currentTimeMillis() + (TTL * 3);
    while (!activeConnections.isEmpty() && System.currentTimeMillis() < end) {
      Thread.sleep(100);
    }
    Assert.assertEquals(0,activeConnections.size());
  }
}
