/** 
 * @author Stuart Douglas
 */
@RunWith(DefaultServer.class) @AjpIgnore public class ChunkedRequestTrailersTestCase {
  private static volatile ServerConnection connection;
  private static OptionMap existing;
  @BeforeClass public static void setup(){
    final BlockingHandler blockingHandler=new BlockingHandler();
    existing=DefaultServer.getUndertowOptions();
    DefaultServer.setUndertowOptions(OptionMap.create(UndertowOptions.ALWAYS_SET_DATE,false));
    DefaultServer.setRootHandler(blockingHandler);
    blockingHandler.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange){
        try {
          if (connection == null) {
            connection=exchange.getConnection();
          }
 else           if (!DefaultServer.isProxy() && connection != exchange.getConnection()) {
            exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);
            final OutputStream outputStream=exchange.getOutputStream();
            outputStream.write("Connection not persistent".getBytes());
            outputStream.close();
            return;
          }
          final OutputStream outputStream=exchange.getOutputStream();
          final InputStream inputStream=exchange.getInputStream();
          String m=HttpClientUtils.readResponse(inputStream);
          Assert.assertEquals("abcdefghi",m);
          HeaderMap headers=exchange.getAttachment(HttpAttachments.REQUEST_TRAILERS);
          for (          HeaderValues header : headers) {
            for (            String val : header) {
              outputStream.write(header.getHeaderName().toString().getBytes());
              outputStream.write(": ".getBytes());
              outputStream.write(val.getBytes());
              outputStream.write("\r\n".getBytes());
            }
          }
          inputStream.close();
          outputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
          throw new RuntimeException(e);
        }
      }
    }
);
  }
  @AfterClass public static void cleanup(){
    DefaultServer.setUndertowOptions(existing);
  }
  /** 
 * We send our request manually, as apache HTTP client does not support this.
 * @throws IOException
 */
  @Test public void testChunkedRequestsWithTrailers() throws IOException {
    connection=null;
    String request="POST / HTTP/1.1\r\nHost: default\r\nTrailer:foo, bar\r\nTransfer-Encoding: chunked\r\n\r\n9\r\nabcdefghi\r\n0\r\nfoo: fooVal\r\n bar: barVal\r\n\r\n";
    String response1="HTTP/1.1 200 OK\r\nConnection: keep-alive\r\nContent-Length: 26\r\n\r\nfoo: fooVal\r\nbar: barVal\r\n";
    String response2="HTTP/1.1 200 OK\r\nConnection: keep-alive\r\nContent-Length: 26\r\n\r\nfoo: fooVal\r\nbar: barVal\r\n";
    Socket s=new Socket(DefaultServer.getDefaultServerAddress().getAddress(),DefaultServer.getDefaultServerAddress().getPort());
    try {
      s.getOutputStream().write(request.getBytes());
      StringBuilder sb=new StringBuilder();
      int read=0;
      byte[] buf=new byte[300];
      while (read < response1.length()) {
        int r=s.getInputStream().read(buf);
        if (r <= 0)         break;
        if (r > 0) {
          read+=r;
          sb.append(new String(buf,0,r));
        }
      }
      String actual=sb.toString();
      actual=actual.replaceAll("\r\nDate:.*","");
      actual=actual.replaceAll("content-length","Content-Length");
      try {
        Assert.assertEquals(response1,actual);
      }
 catch (      AssertionError e) {
        Assert.assertEquals(response2,actual);
      }
      s.getOutputStream().write(request.getBytes());
      sb=new StringBuilder();
      read=0;
      while (read < response1.length()) {
        int r=s.getInputStream().read(buf);
        if (r <= 0)         break;
        if (r > 0) {
          read+=r;
          sb.append(new String(buf,0,r));
        }
      }
      actual=sb.toString();
      actual=actual.replaceAll("\r\nDate:.*","");
      actual=actual.replaceAll("content-length","Content-Length");
      try {
        Assert.assertEquals(response1,actual);
      }
 catch (      AssertionError e) {
        Assert.assertEquals(response2,actual);
      }
    }
  finally {
      s.close();
    }
  }
}
