/** 
 * @author Emanuel Muckenhuber
 */
@RunWith(DefaultServer.class) @HttpOneOnly public class Http2ClientTestCase {
  private static final String message="Hello World!";
  public static final String MESSAGE="/message";
  public static final String POST="/post";
  private static XnioWorker worker;
  private static Undertow server;
  private static final OptionMap DEFAULT_OPTIONS;
  private static URI ADDRESS;
  private static final AttachmentKey<String> RESPONSE_BODY=AttachmentKey.create(String.class);
static {
    final OptionMap.Builder builder=OptionMap.builder().set(Options.WORKER_IO_THREADS,8).set(Options.TCP_NODELAY,true).set(Options.KEEP_ALIVE,true).set(Options.WORKER_NAME,"Client");
    DEFAULT_OPTIONS=builder.getMap();
  }
  static void sendMessage(  final HttpServerExchange exchange){
    exchange.setStatusCode(StatusCodes.OK);
    final Sender sender=exchange.getResponseSender();
    sender.send(message);
  }
  @BeforeClass public static void beforeClass() throws IOException {
    int port=DefaultServer.getHostPort("default");
    final PathHandler path=new PathHandler().addExactPath(MESSAGE,new HttpHandler(){
      @Override public void handleRequest(      HttpServerExchange exchange) throws Exception {
        sendMessage(exchange);
      }
    }
).addExactPath(POST,new HttpHandler(){
      @Override public void handleRequest(      HttpServerExchange exchange) throws Exception {
        exchange.getRequestReceiver().receiveFullString(new Receiver.FullStringCallback(){
          @Override public void handle(          HttpServerExchange exchange,          String message){
            exchange.getResponseSender().send(message);
          }
        }
);
      }
    }
);
    server=Undertow.builder().addHttpsListener(port + 1,DefaultServer.getHostAddress("default"),DefaultServer.getServerSslContext()).setServerOption(UndertowOptions.ENABLE_HTTP2,true).setSocketOption(Options.REUSE_ADDRESSES,true).setHandler(new HttpHandler(){
      @Override public void handleRequest(      HttpServerExchange exchange) throws Exception {
        if (!exchange.getProtocol().equals(Protocols.HTTP_2_0)) {
          throw new RuntimeException("Not HTTP/2");
        }
        path.handleRequest(exchange);
      }
    }
).build();
    server.start();
    try {
      ADDRESS=new URI("https://" + DefaultServer.getHostAddress() + ":"+ (port + 1));
    }
 catch (    URISyntaxException e) {
      throw new RuntimeException(e);
    }
    final Xnio xnio=Xnio.getInstance();
    final XnioWorker xnioWorker=xnio.createWorker(null,DEFAULT_OPTIONS);
    worker=xnioWorker;
  }
  @AfterClass public static void afterClass(){
    server.stop();
    worker.shutdown();
  }
  static UndertowClient createClient(){
    return createClient(OptionMap.EMPTY);
  }
  static UndertowClient createClient(  final OptionMap options){
    return UndertowClient.getInstance();
  }
  @Test public void testSimpleBasic() throws Exception {
    final UndertowClient client=createClient();
    final List<ClientResponse> responses=new CopyOnWriteArrayList<>();
    final CountDownLatch latch=new CountDownLatch(10);
    final ClientConnection connection=client.connect(ADDRESS,worker,new UndertowXnioSsl(worker.getXnio(),OptionMap.EMPTY,DefaultServer.getClientSSLContext()),DefaultServer.getBufferPool(),OptionMap.create(UndertowOptions.ENABLE_HTTP2,true)).get();
    try {
      connection.getIoThread().execute(new Runnable(){
        @Override public void run(){
          for (int i=0; i < 10; i++) {
            final ClientRequest request=new ClientRequest().setMethod(Methods.GET).setPath(MESSAGE);
            request.getRequestHeaders().put(Headers.HOST,DefaultServer.getHostAddress());
            connection.sendRequest(request,createClientCallback(responses,latch));
          }
        }
      }
);
      latch.await(10,TimeUnit.SECONDS);
      Assert.assertEquals(10,responses.size());
      for (      final ClientResponse response : responses) {
        Assert.assertEquals(message,response.getAttachment(RESPONSE_BODY));
      }
    }
  finally {
      IoUtils.safeClose(connection);
    }
  }
  @Test public void testHeadRequest() throws Exception {
    final UndertowClient client=createClient();
    final List<ClientResponse> responses=new CopyOnWriteArrayList<>();
    final CountDownLatch latch=new CountDownLatch(10);
    final ClientConnection connection=client.connect(ADDRESS,worker,new UndertowXnioSsl(worker.getXnio(),OptionMap.EMPTY,DefaultServer.getClientSSLContext()),DefaultServer.getBufferPool(),OptionMap.create(UndertowOptions.ENABLE_HTTP2,true)).get();
    try {
      connection.getIoThread().execute(new Runnable(){
        @Override public void run(){
          for (int i=0; i < 10; i++) {
            final ClientRequest request=new ClientRequest().setMethod(Methods.HEAD).setPath(MESSAGE);
            request.getRequestHeaders().put(Headers.HOST,DefaultServer.getHostAddress());
            connection.sendRequest(request,createClientCallback(responses,latch));
          }
        }
      }
);
      latch.await(10,TimeUnit.SECONDS);
      Assert.assertEquals(10,responses.size());
      for (      final ClientResponse response : responses) {
        Assert.assertEquals("",response.getAttachment(RESPONSE_BODY));
      }
    }
  finally {
      IoUtils.safeClose(connection);
    }
  }
  @Test public void testPostRequest() throws Exception {
    final UndertowClient client=createClient();
    final String postMessage="This is a post request";
    final List<String> responses=new CopyOnWriteArrayList<>();
    final CountDownLatch latch=new CountDownLatch(10);
    final ClientConnection connection=client.connect(ADDRESS,worker,new UndertowXnioSsl(worker.getXnio(),OptionMap.EMPTY,DefaultServer.getClientSSLContext()),DefaultServer.getBufferPool(),OptionMap.create(UndertowOptions.ENABLE_HTTP2,true)).get();
    try {
      connection.getIoThread().execute(new Runnable(){
        @Override public void run(){
          for (int i=0; i < 10; i++) {
            final ClientRequest request=new ClientRequest().setMethod(Methods.POST).setPath(POST);
            request.getRequestHeaders().put(Headers.HOST,DefaultServer.getHostAddress());
            request.getRequestHeaders().put(Headers.TRANSFER_ENCODING,"chunked");
            connection.sendRequest(request,new ClientCallback<ClientExchange>(){
              @Override public void completed(              ClientExchange result){
                new StringWriteChannelListener(postMessage).setup(result.getRequestChannel());
                result.setResponseListener(new ClientCallback<ClientExchange>(){
                  @Override public void completed(                  ClientExchange result){
                    new StringReadChannelListener(DefaultServer.getBufferPool()){
                      @Override protected void stringDone(                      String string){
                        responses.add(string);
                        latch.countDown();
                      }
                      @Override protected void error(                      IOException e){
                        e.printStackTrace();
                        latch.countDown();
                      }
                    }
.setup(result.getResponseChannel());
                  }
                  @Override public void failed(                  IOException e){
                    e.printStackTrace();
                    latch.countDown();
                  }
                }
);
              }
              @Override public void failed(              IOException e){
                e.printStackTrace();
                latch.countDown();
              }
            }
);
          }
        }
      }
);
      latch.await(10,TimeUnit.SECONDS);
      Assert.assertEquals(10,responses.size());
      for (      final String response : responses) {
        Assert.assertEquals(postMessage,response);
      }
    }
  finally {
      IoUtils.safeClose(connection);
    }
  }
  private ClientCallback<ClientExchange> createClientCallback(  final List<ClientResponse> responses,  final CountDownLatch latch){
    return new ClientCallback<ClientExchange>(){
      @Override public void completed(      ClientExchange result){
        result.setResponseListener(new ClientCallback<ClientExchange>(){
          @Override public void completed(          final ClientExchange result){
            responses.add(result.getResponse());
            new StringReadChannelListener(result.getConnection().getBufferPool()){
              @Override protected void stringDone(              String string){
                result.getResponse().putAttachment(RESPONSE_BODY,string);
                latch.countDown();
              }
              @Override protected void error(              IOException e){
                e.printStackTrace();
                latch.countDown();
              }
            }
.setup(result.getResponseChannel());
          }
          @Override public void failed(          IOException e){
            e.printStackTrace();
            latch.countDown();
          }
        }
);
        try {
          result.getRequestChannel().shutdownWrites();
          if (!result.getRequestChannel().flush()) {
            result.getRequestChannel().getWriteSetter().set(ChannelListeners.<StreamSinkChannel>flushingChannelListener(null,null));
            result.getRequestChannel().resumeWrites();
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
          latch.countDown();
        }
      }
      @Override public void failed(      IOException e){
        e.printStackTrace();
        latch.countDown();
      }
    }
;
  }
}
