/** 
 * Test that uses a fake channel that returns 0 a lot, to make sure that resume writes works correclty
 * @author Stuart Douglas
 */
@RunWith(DefaultServer.class) public class ResumeWritesTestCase {
  public static final String HELLO_WORLD="Hello World";
  @Test public void testResumeWritesFixedLength() throws IOException {
    DefaultServer.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        exchange.addResponseWrapper(new ReturnZeroWrapper());
        exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH,HELLO_WORLD.length());
        exchange.getResponseSender().send(HELLO_WORLD);
      }
    }
);
    TestHttpClient client=new TestHttpClient();
    try {
      HttpGet get=new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
      HttpResponse result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
      result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
      result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
    }
  finally {
      client.getConnectionManager().shutdown();
    }
  }
  @Test public void testResumeWritesChunked() throws IOException {
    DefaultServer.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        exchange.addResponseWrapper(new ReturnZeroWrapper());
        exchange.getResponseSender().send(HELLO_WORLD);
      }
    }
);
    TestHttpClient client=new TestHttpClient();
    try {
      HttpGet get=new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
      HttpResponse result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
      result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
      result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
    }
  finally {
      client.getConnectionManager().shutdown();
    }
  }
  @Test public void testResumeWritesHttp10() throws IOException {
    DefaultServer.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        exchange.addResponseWrapper(new ReturnZeroWrapper());
        exchange.getResponseSender().send(HELLO_WORLD);
      }
    }
);
    TestHttpClient client=new TestHttpClient();
    try {
      HttpGet get=new HttpGet(DefaultServer.getDefaultServerURL() + "/path");
      get.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION,HttpVersion.HTTP_1_0);
      HttpResponse result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
      result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
      result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Assert.assertEquals(HELLO_WORLD,HttpClientUtils.readResponse(result));
    }
  finally {
      client.getConnectionManager().shutdown();
    }
  }
private static class ReturnZeroWrapper implements ConduitWrapper<StreamSinkConduit> {
    @Override public StreamSinkConduit wrap(    final ConduitFactory<StreamSinkConduit> factory,    final HttpServerExchange exchange){
      return new AbstractStreamSinkConduit<StreamSinkConduit>(factory.create()){
        int c=0;
        @Override public long transferFrom(        final FileChannel src,        final long position,        final long count) throws IOException {
          if (c++ % 100 != 90)           return 0;
          return super.transferFrom(src,position,count);
        }
        @Override public long transferFrom(        final StreamSourceChannel source,        final long count,        final ByteBuffer throughBuffer) throws IOException {
          if (c++ % 100 != 90)           return 0;
          return super.transferFrom(source,count,throughBuffer);
        }
        @Override public int write(        final ByteBuffer src) throws IOException {
          if (c++ % 100 != 90)           return 0;
          return super.write(src);
        }
        @Override public long write(        final ByteBuffer[] srcs,        final int offs,        final int len) throws IOException {
          if (c++ % 100 != 90)           return 0;
          return super.write(srcs,offs,len);
        }
        @Override public boolean flush() throws IOException {
          if (c++ % 100 != 90)           return false;
          return super.flush();
        }
      }
;
    }
  }
}
