/** 
 * @author Stuart Douglas
 */
@RunWith(DefaultServer.class) public class SimpleSSLTestCase {
  @Test public void simpleSSLTestCase() throws IOException, GeneralSecurityException {
    DefaultServer.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        exchange.getResponseHeaders().put(HttpString.tryFromString("scheme"),exchange.getRequestScheme());
        exchange.endExchange();
      }
    }
);
    DefaultServer.startSSLServer();
    TestHttpClient client=new TestHttpClient();
    client.setSSLContext(DefaultServer.getClientSSLContext());
    try {
      HttpGet get=new HttpGet(DefaultServer.getDefaultServerSSLAddress());
      HttpResponse result=client.execute(get);
      Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
      Header[] header=result.getHeaders("scheme");
      Assert.assertEquals("https",header[0].getValue());
    }
  finally {
      client.getConnectionManager().shutdown();
      DefaultServer.stopSSLServer();
    }
  }
  @Test public void testNonPersistentConnections() throws IOException, GeneralSecurityException {
    DefaultServer.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        exchange.getResponseHeaders().put(HttpString.tryFromString("scheme"),exchange.getRequestScheme());
        exchange.getResponseHeaders().put(Headers.CONNECTION,"close");
        exchange.endExchange();
      }
    }
);
    DefaultServer.startSSLServer();
    TestHttpClient client=new TestHttpClient();
    client.setSSLContext(DefaultServer.getClientSSLContext());
    try {
      for (int i=0; i < 5; ++i) {
        HttpGet get=new HttpGet(DefaultServer.getDefaultServerSSLAddress());
        HttpResponse result=client.execute(get);
        Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
        Header[] header=result.getHeaders("scheme");
        Assert.assertEquals("https",header[0].getValue());
        HttpClientUtils.readResponse(result);
      }
    }
  finally {
      client.getConnectionManager().shutdown();
      DefaultServer.stopSSLServer();
    }
  }
  @Test public void parallel() throws Exception {
    runTest(32,new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        exchange.getResponseHeaders().put(HttpString.tryFromString("scheme"),exchange.getRequestScheme());
        exchange.endExchange();
      }
    }
);
  }
  @Test public void parallelWithDispatch() throws Exception {
    runTest(32,new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        exchange.dispatch(() -> {
          exchange.getResponseHeaders().put(HttpString.tryFromString("scheme"),exchange.getRequestScheme());
          exchange.endExchange();
        }
);
      }
    }
);
  }
  @Test public void parallelWithBlockingDispatch() throws Exception {
    runTest(32,new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange) throws Exception {
        if (exchange.isInIoThread()) {
          exchange.dispatch(this);
          return;
        }
        exchange.startBlocking();
        exchange.getResponseHeaders().put(HttpString.tryFromString("scheme"),exchange.getRequestScheme());
        exchange.endExchange();
      }
    }
);
  }
  private void runTest(  int concurrency,  HttpHandler handler) throws IOException, InterruptedException {
    DefaultServer.setRootHandler(handler);
    DefaultServer.startSSLServer();
    try (CloseableHttpClient client=HttpClients.custom().disableConnectionState().setSSLContext(DefaultServer.getClientSSLContext()).setDefaultSocketConfig(SocketConfig.custom().setSoTimeout(5000).build()).setMaxConnPerRoute(1000).build()){
      ExecutorService executorService=Executors.newFixedThreadPool(concurrency);
      AtomicBoolean failed=new AtomicBoolean();
      Runnable task=new Runnable(){
        @Override public void run(){
          if (failed.get()) {
            return;
          }
          try (CloseableHttpResponse result=client.execute(new HttpGet(DefaultServer.getDefaultServerSSLAddress()))){
            Assert.assertEquals(StatusCodes.OK,result.getStatusLine().getStatusCode());
            Header[] header=result.getHeaders("scheme");
            Assert.assertEquals("https",header[0].getValue());
            EntityUtils.consumeQuietly(result.getEntity());
          }
 catch (          Throwable t) {
            if (failed.compareAndSet(false,true)) {
              t.printStackTrace();
              executorService.shutdownNow();
            }
          }
        }
      }
;
      for (int i=0; i < concurrency * 300; i++) {
        executorService.submit(task);
      }
      executorService.shutdown();
      Assert.assertTrue(executorService.awaitTermination(70,TimeUnit.SECONDS));
      Assert.assertFalse(failed.get());
    }
  finally {
      DefaultServer.stopSSLServer();
    }
  }
}
