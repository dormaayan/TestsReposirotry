static class HttpResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {
  private SortedMap<Integer,ChannelPromise> streamidPromiseMap;
  HttpResponseHandler(){
    streamidPromiseMap=new TreeMap<Integer,ChannelPromise>();
  }
  /** 
 * Create an association between an anticipated response stream id and a  {@link io.netty.channel.ChannelPromise}
 * @param streamId The stream for which a response is expected
 * @param promise The promise object that will be used to wait/notify events
 * @return The previous object associated with {@code streamId}
 * @see HttpResponseHandler#awaitResponses(long,java.util.concurrent.TimeUnit)
 */
  public ChannelPromise put(  int streamId,  ChannelPromise promise){
    return streamidPromiseMap.put(streamId,promise);
  }
  /** 
 * Wait (sequentially) for a time duration for each anticipated response
 * @param timeout Value of time to wait for each response
 * @param unit Units associated with {@code timeout}
 * @see HttpResponseHandler#put(int,io.netty.channel.ChannelPromise)
 */
  public void awaitResponses(  long timeout,  TimeUnit unit){
    Iterator<Entry<Integer,ChannelPromise>> itr=streamidPromiseMap.entrySet().iterator();
    while (itr.hasNext()) {
      Entry<Integer,ChannelPromise> entry=itr.next();
      ChannelPromise promise=entry.getValue();
      if (!promise.awaitUninterruptibly(timeout,unit)) {
        throw new IllegalStateException("Timed out waiting for response on stream id " + entry.getKey());
      }
      if (!promise.isSuccess()) {
        throw new RuntimeException(promise.cause());
      }
      System.out.println("---Stream id: " + entry.getKey() + " received---");
      itr.remove();
    }
  }
  @Override protected void channelRead0(  ChannelHandlerContext ctx,  FullHttpResponse msg) throws Exception {
    Integer streamId=msg.headers().getInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text());
    if (streamId == null) {
      System.err.println("HttpResponseHandler unexpected message received: " + msg);
      return;
    }
    ChannelPromise promise=streamidPromiseMap.get(streamId);
    if (promise == null) {
      System.err.println("Message received for unknown stream id " + streamId);
    }
 else {
      ByteBuf content=msg.content();
      if (content.isReadable()) {
        int contentLength=content.readableBytes();
        byte[] arr=new byte[contentLength];
        content.readBytes(arr);
        messages.add(new String(arr,StandardCharsets.UTF_8));
      }
      promise.setSuccess();
    }
  }
}
