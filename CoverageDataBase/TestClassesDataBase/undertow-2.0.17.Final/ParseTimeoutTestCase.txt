@RunWith(DefaultServer.class) @ProxyIgnore @HttpOneOnly public class ParseTimeoutTestCase {
  private Socket client;
  private OutputStream clientOutputStream;
  private InputStream clientInputStream;
  @Before public void before() throws Exception {
    client=new Socket();
    client.connect(DefaultServer.getDefaultServerAddress());
    clientOutputStream=client.getOutputStream();
    clientInputStream=client.getInputStream();
  }
  public void after() throws Exception {
    IoUtils.safeClose(client);
    DefaultServer.setUndertowOptions(OptionMap.EMPTY);
  }
  @BeforeClass public static void beforeClass() throws Exception {
    DefaultServer.setUndertowOptions(OptionMap.create(UndertowOptions.REQUEST_PARSE_TIMEOUT,10));
  }
  @AfterClass public static void afterClass() throws Exception {
    DefaultServer.setUndertowOptions(OptionMap.EMPTY);
  }
  @Test(timeout=10000) public void testClosingConnectionWhenParsingHeadersForTooLong() throws Exception {
    DefaultServer.setRootHandler(new HttpHandler(){
      @Override public void handleRequest(      final HttpServerExchange exchange){
        fail("Parser should never end its job, since we are streaming headers.");
      }
    }
);
    String request="GET / HTTP/1.1\r\nHost:localhost";
    clientOutputStream.write(request.getBytes());
    clientOutputStream.flush();
    Thread.sleep(100);
    assertEquals(-1,clientInputStream.read());
  }
}
