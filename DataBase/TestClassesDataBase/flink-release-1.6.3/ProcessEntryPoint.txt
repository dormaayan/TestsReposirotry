public static final class ProcessEntryPoint {
  public static void main(  String[] args) throws Exception {
    System.err.println("creating task");
    try {
      final Configuration taskManagerConfig=new Configuration();
      taskManagerConfig.setBoolean(TaskManagerOptions.KILL_ON_OUT_OF_MEMORY,true);
      final JobID jid=new JobID();
      final AllocationID allocationID=new AllocationID();
      final JobVertexID jobVertexId=new JobVertexID();
      final ExecutionAttemptID executionAttemptID=new ExecutionAttemptID();
      final AllocationID slotAllocationId=new AllocationID();
      final SerializedValue<ExecutionConfig> execConfig=new SerializedValue<>(new ExecutionConfig());
      final JobInformation jobInformation=new JobInformation(jid,"Test Job",execConfig,new Configuration(),Collections.emptyList(),Collections.emptyList());
      final TaskInformation taskInformation=new TaskInformation(jobVertexId,"Test Task",1,1,OomInvokable.class.getName(),new Configuration());
      final MemoryManager memoryManager=new MemoryManager(1024 * 1024,1);
      final IOManager ioManager=new IOManagerAsync();
      final NetworkEnvironment networkEnvironment=mock(NetworkEnvironment.class);
      when(networkEnvironment.createKvStateTaskRegistry(jid,jobVertexId)).thenReturn(mock(TaskKvStateRegistry.class));
      TaskEventDispatcher taskEventDispatcher=mock(TaskEventDispatcher.class);
      when(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher);
      final TaskManagerRuntimeInfo tmInfo=TaskManagerConfiguration.fromConfiguration(taskManagerConfig);
      final Executor executor=Executors.newCachedThreadPool();
      BlobCacheService blobService=new BlobCacheService(mock(PermanentBlobCache.class),mock(TransientBlobCache.class));
      final TaskLocalStateStore localStateStore=new TaskLocalStateStoreImpl(jid,allocationID,jobVertexId,0,TestLocalRecoveryConfig.disabled(),executor);
      final TaskStateManager slotStateManager=new TaskStateManagerImpl(jid,executionAttemptID,localStateStore,null,mock(CheckpointResponder.class));
      Task task=new Task(jobInformation,taskInformation,executionAttemptID,slotAllocationId,0,0,Collections.<ResultPartitionDeploymentDescriptor>emptyList(),Collections.<InputGateDeploymentDescriptor>emptyList(),0,memoryManager,ioManager,networkEnvironment,new BroadcastVariableManager(),slotStateManager,new NoOpTaskManagerActions(),new NoOpInputSplitProvider(),new NoOpCheckpointResponder(),blobService,new BlobLibraryCacheManager(blobService.getPermanentBlobService(),FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST,new String[0]),new FileCache(tmInfo.getTmpDirectories(),blobService.getPermanentBlobService()),tmInfo,UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),new NoOpResultPartitionConsumableNotifier(),new NoOpPartitionProducerStateChecker(),executor);
      System.err.println("starting task thread");
      task.startTaskThread();
    }
 catch (    Throwable t) {
      System.err.println("ERROR STARTING TASK");
      t.printStackTrace();
    }
    System.err.println("parking the main thread");
    CommonTestUtils.blockForeverNonInterruptibly();
  }
public static final class OomInvokable extends AbstractInvokable {
    public OomInvokable(    Environment environment){
      super(environment);
    }
    @Override public void invoke() throws Exception {
      throw new OutOfMemoryError();
    }
  }
private static final class NoOpTaskManagerActions implements TaskManagerActions {
    @Override public void notifyFinalState(    ExecutionAttemptID executionAttemptID){
    }
    @Override public void notifyFatalError(    String message,    Throwable cause){
    }
    @Override public void failTask(    ExecutionAttemptID executionAttemptID,    Throwable cause){
    }
    @Override public void updateTaskExecutionState(    TaskExecutionState taskExecutionState){
    }
  }
private static final class NoOpInputSplitProvider implements InputSplitProvider {
    @Override public InputSplit getNextInputSplit(    ClassLoader userCodeClassLoader){
      return null;
    }
  }
private static final class NoOpCheckpointResponder implements CheckpointResponder {
    @Override public void acknowledgeCheckpoint(    JobID j,    ExecutionAttemptID e,    long i,    CheckpointMetrics c,    TaskStateSnapshot s){
    }
    @Override public void declineCheckpoint(    JobID j,    ExecutionAttemptID e,    long l,    Throwable t){
    }
  }
private static final class NoOpPartitionProducerStateChecker implements PartitionProducerStateChecker {
    @Override public CompletableFuture<ExecutionState> requestPartitionProducerState(    JobID jobId,    IntermediateDataSetID intermediateDataSetId,    ResultPartitionID r){
      return null;
    }
  }
}
