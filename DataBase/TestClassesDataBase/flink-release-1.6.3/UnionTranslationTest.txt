/** 
 * Tests for translation of union operation.
 */
@SuppressWarnings("serial") public class UnionTranslationTest {
  @Test public void translateUnion2Group(){
    try {
      final int parallelism=4;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> dataset1=getSourceDataSet(env,3);
      DataSet<Tuple3<Double,StringValue,LongValue>> dataset2=getSourceDataSet(env,2);
      dataset1.union(dataset2).groupBy((KeySelector<Tuple3<Double,StringValue,LongValue>,String>)value -> "").reduceGroup((GroupReduceFunction<Tuple3<Double,StringValue,LongValue>,String>)(values,out) -> {
      }
).returns(String.class).output(new DiscardingOutputFormat<>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      Union unionOperator=(Union)((SingleInputOperator)sink.getInput()).getInput();
      assertTrue(unionOperator.getFirstInput() instanceof MapOperatorBase<?,?,?>);
      assertTrue(unionOperator.getSecondInput() instanceof MapOperatorBase<?,?,?>);
      assertEquals(unionOperator.getFirstInput().getParallelism(),3);
      assertEquals(unionOperator.getSecondInput().getParallelism(),2);
      assertEquals(unionOperator.getParallelism(),ExecutionConfig.PARALLELISM_DEFAULT);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @Test public void translateUnion3SortedGroup(){
    try {
      final int parallelism=4;
      ExecutionEnvironment env=ExecutionEnvironment.createLocalEnvironment(parallelism);
      DataSet<Tuple3<Double,StringValue,LongValue>> dataset1=getSourceDataSet(env,2);
      DataSet<Tuple3<Double,StringValue,LongValue>> dataset2=getSourceDataSet(env,3);
      DataSet<Tuple3<Double,StringValue,LongValue>> dataset3=getSourceDataSet(env,-1);
      dataset1.union(dataset2).union(dataset3).groupBy((KeySelector<Tuple3<Double,StringValue,LongValue>,String>)value -> "").sortGroup((KeySelector<Tuple3<Double,StringValue,LongValue>,String>)value -> "",Order.ASCENDING).reduceGroup((GroupReduceFunction<Tuple3<Double,StringValue,LongValue>,String>)(values,out) -> {
      }
).returns(String.class).output(new DiscardingOutputFormat<>());
      Plan p=env.createProgramPlan();
      GenericDataSinkBase<?> sink=p.getDataSinks().iterator().next();
      Union secondUnionOperator=(Union)((SingleInputOperator)sink.getInput()).getInput();
      Union firstUnionOperator=(Union)secondUnionOperator.getFirstInput();
      assertTrue(secondUnionOperator.getSecondInput() instanceof MapOperatorBase<?,?,?>);
      assertTrue(firstUnionOperator.getFirstInput() instanceof MapOperatorBase<?,?,?>);
      assertTrue(firstUnionOperator.getSecondInput() instanceof MapOperatorBase<?,?,?>);
      assertEquals(firstUnionOperator.getFirstInput().getParallelism(),2);
      assertEquals(firstUnionOperator.getSecondInput().getParallelism(),3);
      assertEquals(secondUnionOperator.getSecondInput().getParallelism(),-1);
      assertEquals(secondUnionOperator.getParallelism(),ExecutionConfig.PARALLELISM_DEFAULT);
      assertEquals(firstUnionOperator.getParallelism(),ExecutionConfig.PARALLELISM_DEFAULT);
    }
 catch (    Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      fail("Test caused an error: " + e.getMessage());
    }
  }
  @SuppressWarnings("unchecked") private static DataSet<Tuple3<Double,StringValue,LongValue>> getSourceDataSet(  ExecutionEnvironment env,  int parallelism){
    return env.fromElements(new Tuple3<>(0.0,new StringValue(""),new LongValue(1L))).setParallelism(parallelism);
  }
}
