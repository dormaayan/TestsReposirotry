/** 
 * Tests for  {@link PartitionRequestClient}.
 */
public class PartitionRequestClientTest {
  @Test public void testRetriggerPartitionRequest() throws Exception {
    final long deadline=System.currentTimeMillis() + 30_000L;
    final PartitionRequestClientHandler handler=new PartitionRequestClientHandler();
    final EmbeddedChannel channel=new EmbeddedChannel(handler);
    final PartitionRequestClient client=new PartitionRequestClient(channel,handler,mock(ConnectionID.class),mock(PartitionRequestClientFactory.class));
    final NetworkBufferPool networkBufferPool=new NetworkBufferPool(10,32);
    final SingleInputGate inputGate=createSingleInputGate();
    final RemoteInputChannel inputChannel=createRemoteInputChannel(inputGate,client,1,2);
    try {
      final BufferPool bufferPool=networkBufferPool.createBufferPool(6,6);
      inputGate.setBufferPool(bufferPool);
      final int numExclusiveBuffers=2;
      inputGate.assignExclusiveSegments(networkBufferPool,numExclusiveBuffers);
      inputChannel.requestSubpartition(0);
      assertTrue(channel.isWritable());
      Object readFromOutbound=channel.readOutbound();
      assertThat(readFromOutbound,instanceOf(PartitionRequest.class));
      assertEquals(inputChannel.getInputChannelId(),((PartitionRequest)readFromOutbound).receiverId);
      assertEquals(numExclusiveBuffers,((PartitionRequest)readFromOutbound).credit);
      inputGate.retriggerPartitionRequest(inputChannel.getPartitionId().getPartitionId());
      runAllScheduledPendingTasks(channel,deadline);
      readFromOutbound=channel.readOutbound();
      assertThat(readFromOutbound,instanceOf(PartitionRequest.class));
      assertEquals(inputChannel.getInputChannelId(),((PartitionRequest)readFromOutbound).receiverId);
      assertEquals(numExclusiveBuffers,((PartitionRequest)readFromOutbound).credit);
      inputGate.retriggerPartitionRequest(inputChannel.getPartitionId().getPartitionId());
      runAllScheduledPendingTasks(channel,deadline);
      readFromOutbound=channel.readOutbound();
      assertThat(readFromOutbound,instanceOf(PartitionRequest.class));
      assertEquals(inputChannel.getInputChannelId(),((PartitionRequest)readFromOutbound).receiverId);
      assertEquals(numExclusiveBuffers,((PartitionRequest)readFromOutbound).credit);
      assertNull(channel.readOutbound());
    }
  finally {
      inputGate.releaseAllResources();
      networkBufferPool.destroyAllBufferPools();
      networkBufferPool.destroy();
    }
  }
  @Test public void testDoublePartitionRequest() throws Exception {
    final PartitionRequestClientHandler handler=new PartitionRequestClientHandler();
    final EmbeddedChannel channel=new EmbeddedChannel(handler);
    final PartitionRequestClient client=new PartitionRequestClient(channel,handler,mock(ConnectionID.class),mock(PartitionRequestClientFactory.class));
    final NetworkBufferPool networkBufferPool=new NetworkBufferPool(10,32);
    final SingleInputGate inputGate=createSingleInputGate();
    final RemoteInputChannel inputChannel=createRemoteInputChannel(inputGate,client);
    try {
      final BufferPool bufferPool=networkBufferPool.createBufferPool(6,6);
      inputGate.setBufferPool(bufferPool);
      final int numExclusiveBuffers=2;
      inputGate.assignExclusiveSegments(networkBufferPool,numExclusiveBuffers);
      inputChannel.requestSubpartition(0);
      assertTrue(channel.isWritable());
      Object readFromOutbound=channel.readOutbound();
      assertThat(readFromOutbound,instanceOf(PartitionRequest.class));
      assertEquals(inputChannel.getInputChannelId(),((PartitionRequest)readFromOutbound).receiverId);
      assertEquals(numExclusiveBuffers,((PartitionRequest)readFromOutbound).credit);
      assertNull(channel.readOutbound());
    }
  finally {
      inputGate.releaseAllResources();
      networkBufferPool.destroyAllBufferPools();
      networkBufferPool.destroy();
    }
  }
  /** 
 * Run all pending scheduled tasks (waits until all tasks have been run or the deadline has passed.
 * @param channel  the channel to execute tasks for
 * @param deadline maximum timestamp in ms to stop waiting further
 * @throws InterruptedException
 */
  void runAllScheduledPendingTasks(  EmbeddedChannel channel,  long deadline) throws InterruptedException {
    while (channel.runScheduledPendingTasks() != -1 && System.currentTimeMillis() < deadline) {
      Thread.sleep(1);
    }
  }
}
