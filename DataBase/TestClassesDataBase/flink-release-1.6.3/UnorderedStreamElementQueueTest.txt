/** 
 * {@link UnorderedStreamElementQueue} specific tests.
 */
public class UnorderedStreamElementQueueTest extends TestLogger {
  private static final long timeout=10000L;
  private static ExecutorService executor;
  @BeforeClass public static void setup(){
    executor=Executors.newFixedThreadPool(3);
  }
  @AfterClass public static void shutdown(){
    executor.shutdown();
    try {
      if (!executor.awaitTermination(timeout,TimeUnit.MILLISECONDS)) {
        executor.shutdownNow();
      }
    }
 catch (    InterruptedException interrupted) {
      executor.shutdownNow();
      Thread.currentThread().interrupt();
    }
  }
  /** 
 * Tests that only elements before the oldest watermark are returned if they are completed.
 */
  @Test public void testCompletionOrder() throws Exception {
    OperatorActions operatorActions=mock(OperatorActions.class);
    final UnorderedStreamElementQueue queue=new UnorderedStreamElementQueue(8,executor,operatorActions);
    StreamRecordQueueEntry<Integer> record1=new StreamRecordQueueEntry<>(new StreamRecord<>(1,0L));
    StreamRecordQueueEntry<Integer> record2=new StreamRecordQueueEntry<>(new StreamRecord<>(2,1L));
    WatermarkQueueEntry watermark1=new WatermarkQueueEntry(new Watermark(2L));
    StreamRecordQueueEntry<Integer> record3=new StreamRecordQueueEntry<>(new StreamRecord<>(3,3L));
    StreamRecordQueueEntry<Integer> record4=new StreamRecordQueueEntry<>(new StreamRecord<>(4,4L));
    WatermarkQueueEntry watermark2=new WatermarkQueueEntry(new Watermark(5L));
    StreamRecordQueueEntry<Integer> record5=new StreamRecordQueueEntry<>(new StreamRecord<>(5,6L));
    StreamRecordQueueEntry<Integer> record6=new StreamRecordQueueEntry<>(new StreamRecord<>(6,7L));
    List<StreamElementQueueEntry<?>> entries=Arrays.asList(record1,record2,watermark1,record3,record4,watermark2,record5,record6);
    for (    StreamElementQueueEntry<?> entry : entries) {
      queue.put(entry);
    }
    Assert.assertTrue(8 == queue.size());
    CompletableFuture<AsyncResult> firstPoll=CompletableFuture.supplyAsync(() -> {
      try {
        return queue.poll();
      }
 catch (      InterruptedException e) {
        throw new CompletionException(e);
      }
    }
,executor);
    record3.complete(Collections.<Integer>emptyList());
    Thread.sleep(10L);
    Assert.assertFalse(firstPoll.isDone());
    record2.complete(Collections.<Integer>emptyList());
    Assert.assertEquals(record2,firstPoll.get());
    CompletableFuture<AsyncResult> secondPoll=CompletableFuture.supplyAsync(() -> {
      try {
        return queue.poll();
      }
 catch (      InterruptedException e) {
        throw new CompletionException(e);
      }
    }
,executor);
    record6.complete(Collections.<Integer>emptyList());
    record4.complete(Collections.<Integer>emptyList());
    Thread.sleep(10L);
    Assert.assertFalse(secondPoll.isDone());
    record1.complete(Collections.<Integer>emptyList());
    Assert.assertEquals(record1,secondPoll.get());
    Assert.assertEquals(watermark1,queue.poll());
    Set<AsyncResult> expected=new HashSet<>(2);
    expected.add(record3);
    expected.add(record4);
    Set<AsyncResult> actual=new HashSet<>(2);
    actual.add(queue.poll());
    actual.add(queue.poll());
    Assert.assertEquals(expected,actual);
    Assert.assertEquals(watermark2,queue.poll());
    Assert.assertEquals(record6,queue.poll());
    Assert.assertTrue(1 == queue.size());
    CompletableFuture<AsyncResult> thirdPoll=CompletableFuture.supplyAsync(() -> {
      try {
        return queue.poll();
      }
 catch (      InterruptedException e) {
        throw new CompletionException(e);
      }
    }
,executor);
    Thread.sleep(10L);
    Assert.assertFalse(thirdPoll.isDone());
    record5.complete(Collections.<Integer>emptyList());
    Assert.assertEquals(record5,thirdPoll.get());
    Assert.assertTrue(queue.isEmpty());
    verify(operatorActions,never()).failOperator(any(Exception.class));
  }
}
