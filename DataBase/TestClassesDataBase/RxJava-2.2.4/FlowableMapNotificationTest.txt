public class FlowableMapNotificationTest {
  @Test public void testJust(){
    TestSubscriber<Object> ts=new TestSubscriber<Object>();
    Flowable.just(1).flatMap(new Function<Integer,Flowable<Object>>(){
      @Override public Flowable<Object> apply(      Integer item){
        return Flowable.just((Object)(item + 1));
      }
    }
,new Function<Throwable,Flowable<Object>>(){
      @Override public Flowable<Object> apply(      Throwable e){
        return Flowable.error(e);
      }
    }
,new Callable<Flowable<Object>>(){
      @Override public Flowable<Object> call(){
        return Flowable.never();
      }
    }
).subscribe(ts);
    ts.assertNoErrors();
    ts.assertNotComplete();
    ts.assertValue(2);
  }
  @Test public void backpressure(){
    TestSubscriber<Object> ts=TestSubscriber.create(0L);
    new FlowableMapNotification<Integer,Integer>(Flowable.range(1,3),new Function<Integer,Integer>(){
      @Override public Integer apply(      Integer item){
        return item + 1;
      }
    }
,new Function<Throwable,Integer>(){
      @Override public Integer apply(      Throwable e){
        return 0;
      }
    }
,new Callable<Integer>(){
      @Override public Integer call(){
        return 5;
      }
    }
).subscribe(ts);
    ts.assertNoValues();
    ts.assertNoErrors();
    ts.assertNotComplete();
    ts.request(3);
    ts.assertValues(2,3,4);
    ts.assertNoErrors();
    ts.assertNotComplete();
    ts.request(1);
    ts.assertValues(2,3,4,5);
    ts.assertNoErrors();
    ts.assertComplete();
  }
  @Test public void noBackpressure(){
    TestSubscriber<Object> ts=TestSubscriber.create(0L);
    PublishProcessor<Integer> pp=PublishProcessor.create();
    new FlowableMapNotification<Integer,Integer>(pp,new Function<Integer,Integer>(){
      @Override public Integer apply(      Integer item){
        return item + 1;
      }
    }
,new Function<Throwable,Integer>(){
      @Override public Integer apply(      Throwable e){
        return 0;
      }
    }
,new Callable<Integer>(){
      @Override public Integer call(){
        return 5;
      }
    }
).subscribe(ts);
    ts.assertNoValues();
    ts.assertNoErrors();
    ts.assertNotComplete();
    pp.onNext(1);
    pp.onNext(2);
    pp.onNext(3);
    pp.onComplete();
    ts.assertNoValues();
    ts.assertNoErrors();
    ts.assertNotComplete();
    ts.request(1);
    ts.assertValue(0);
    ts.assertNoErrors();
    ts.assertComplete();
  }
  @Test public void dispose(){
    TestHelper.checkDisposed(new Flowable<Integer>(){
      @SuppressWarnings({"rawtypes","unchecked"}) @Override protected void subscribeActual(      Subscriber<? super Integer> subscriber){
        MapNotificationSubscriber mn=new MapNotificationSubscriber(subscriber,Functions.justFunction(Flowable.just(1)),Functions.justFunction(Flowable.just(2)),Functions.justCallable(Flowable.just(3)));
        mn.onSubscribe(new BooleanSubscription());
      }
    }
);
  }
  @Test public void doubleOnSubscribe(){
    TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>,Flowable<Integer>>(){
      @Override public Flowable<Integer> apply(      Flowable<Object> f) throws Exception {
        return f.flatMap(Functions.justFunction(Flowable.just(1)),Functions.justFunction(Flowable.just(2)),Functions.justCallable(Flowable.just(3)));
      }
    }
);
  }
  @Test public void onErrorCrash(){
    TestSubscriber<Integer> ts=Flowable.<Integer>error(new TestException("Outer")).flatMap(Functions.justFunction(Flowable.just(1)),new Function<Throwable,Publisher<Integer>>(){
      @Override public Publisher<Integer> apply(      Throwable t) throws Exception {
        throw new TestException("Inner");
      }
    }
,Functions.justCallable(Flowable.just(3))).test().assertFailure(CompositeException.class);
    TestHelper.assertError(ts,0,TestException.class,"Outer");
    TestHelper.assertError(ts,1,TestException.class,"Inner");
  }
}
