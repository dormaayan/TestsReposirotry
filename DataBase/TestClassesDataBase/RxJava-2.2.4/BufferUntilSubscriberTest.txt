public class BufferUntilSubscriberTest {
  @Test public void testIssue1677() throws InterruptedException {
    final AtomicLong counter=new AtomicLong();
    final Integer[] numbers=new Integer[5000];
    for (int i=0; i < numbers.length; i++) {
      numbers[i]=i + 1;
    }
    final int NITERS=250;
    final CountDownLatch latch=new CountDownLatch(NITERS);
    for (int iters=0; iters < NITERS; iters++) {
      final CountDownLatch innerLatch=new CountDownLatch(1);
      final PublishProcessor<Void> s=PublishProcessor.create();
      final AtomicBoolean completed=new AtomicBoolean();
      Flowable.fromArray(numbers).takeUntil(s).window(50).flatMap(new Function<Flowable<Integer>,Publisher<Object>>(){
        @Override public Publisher<Object> apply(        Flowable<Integer> integerObservable){
          return integerObservable.subscribeOn(Schedulers.computation()).map(new Function<Integer,Object>(){
            @Override public Object apply(            Integer integer){
              if (integer >= 5 && completed.compareAndSet(false,true)) {
                s.onComplete();
              }
              Math.pow(Math.random(),Math.random());
              return integer * 2;
            }
          }
);
        }
      }
).toList().doOnSuccess(new Consumer<List<Object>>(){
        @Override public void accept(        List<Object> integers){
          counter.incrementAndGet();
          latch.countDown();
          innerLatch.countDown();
        }
      }
).subscribe();
      if (!innerLatch.await(30,TimeUnit.SECONDS)) {
        Assert.fail("Failed inner latch wait, iteration " + iters);
      }
    }
    if (!latch.await(30,TimeUnit.SECONDS)) {
      Assert.fail("Incomplete! Went through " + latch.getCount() + " iterations");
    }
 else {
      Assert.assertEquals(NITERS,counter.get());
    }
  }
}
