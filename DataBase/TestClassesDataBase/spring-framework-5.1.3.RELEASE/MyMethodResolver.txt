static class MyMethodResolver implements MethodResolver {
static class HasRoleExecutor implements MethodExecutor {
    TypeConverter tc;
    public HasRoleExecutor(    TypeConverter typeConverter){
      this.tc=typeConverter;
    }
    @Override public TypedValue execute(    EvaluationContext context,    Object target,    Object... arguments) throws AccessException {
      try {
        Method m=HasRoleExecutor.class.getMethod("hasRole",String[].class);
        Object[] args=arguments;
        if (args != null) {
          ReflectionHelper.convertAllArguments(tc,args,m);
        }
        if (m.isVarArgs()) {
          args=ReflectionHelper.setupArgumentsForVarargsInvocation(m.getParameterTypes(),args);
        }
        return new TypedValue(m.invoke(null,args),new TypeDescriptor(new MethodParameter(m,-1)));
      }
 catch (      Exception ex) {
        throw new AccessException("Problem invoking hasRole",ex);
      }
    }
    public static boolean hasRole(    String... strings){
      return true;
    }
  }
  @Override public MethodExecutor resolve(  EvaluationContext context,  Object targetObject,  String name,  List<TypeDescriptor> arguments) throws AccessException {
    if (name.equals("hasRole")) {
      return new HasRoleExecutor(context.getTypeConverter());
    }
    return null;
  }
}
