public class StubbingWarningsMultiThreadingTest {
  private SimpleMockitoLogger logger=new SimpleMockitoLogger();
  @Rule public SafeJUnitRule rule=new SafeJUnitRule(new JUnitRule(logger,Strictness.WARN));
  @Mock IMethods mock;
  @Test public void using_stubbing_from_different_thread() throws Throwable {
    rule.expectSuccess(new Runnable(){
      public void run(){
        assertTrue(logger.getLoggedInfo().isEmpty());
      }
    }
);
    when(mock.simpleMethod()).thenReturn("1");
    ConcurrentTesting.inThread(new Runnable(){
      public void run(){
        mock.simpleMethod();
      }
    }
);
  }
  @Test public void unused_stub_from_different_thread() throws Throwable {
    rule.expectSuccess(new Runnable(){
      public void run(){
        assertEquals("[MockitoHint] StubbingWarningsMultiThreadingTest.unused_stub_from_different_thread (see javadoc for MockitoHint):\n" + "[MockitoHint] 1. Unused -> at org.mockitousage.junitrule.StubbingWarningsMultiThreadingTest.unused_stub_from_different_thread(StubbingWarningsMultiThreadingTest.java:0)\n",filterLineNo(logger.getLoggedInfo()));
      }
    }
);
    when(mock.simpleMethod(1)).thenReturn("1");
    when(mock.simpleMethod(2)).thenReturn("2");
    ConcurrentTesting.inThread(new Runnable(){
      public void run(){
        mock.simpleMethod(1);
      }
    }
);
  }
}
