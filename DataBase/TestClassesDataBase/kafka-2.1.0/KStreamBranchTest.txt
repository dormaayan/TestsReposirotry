public class KStreamBranchTest {
  private final String topicName="topic";
  private final ConsumerRecordFactory<Integer,String> recordFactory=new ConsumerRecordFactory<>(new IntegerSerializer(),new StringSerializer());
  private final Properties props=StreamsTestUtils.getStreamsConfig(Serdes.String(),Serdes.String());
  @SuppressWarnings("unchecked") @Test public void testKStreamBranch(){
    final StreamsBuilder builder=new StreamsBuilder();
    final Predicate<Integer,String> isEven=new Predicate<Integer,String>(){
      @Override public boolean test(      final Integer key,      final String value){
        return (key % 2) == 0;
      }
    }
;
    final Predicate<Integer,String> isMultipleOfThree=new Predicate<Integer,String>(){
      @Override public boolean test(      final Integer key,      final String value){
        return (key % 3) == 0;
      }
    }
;
    final Predicate<Integer,String> isOdd=new Predicate<Integer,String>(){
      @Override public boolean test(      final Integer key,      final String value){
        return (key % 2) != 0;
      }
    }
;
    final int[] expectedKeys=new int[]{1,2,3,4,5,6};
    final KStream<Integer,String> stream;
    final KStream<Integer,String>[] branches;
    stream=builder.stream(topicName,Consumed.with(Serdes.Integer(),Serdes.String()));
    branches=stream.branch(isEven,isMultipleOfThree,isOdd);
    assertEquals(3,branches.length);
    final MockProcessorSupplier<Integer,String> supplier=new MockProcessorSupplier<>();
    for (int i=0; i < branches.length; i++) {
      branches[i].process(supplier);
    }
    try (final TopologyTestDriver driver=new TopologyTestDriver(builder.build(),props)){
      for (      final int expectedKey : expectedKeys) {
        driver.pipeInput(recordFactory.create(topicName,expectedKey,"V" + expectedKey));
      }
    }
     final List<MockProcessor<Integer,String>> processors=supplier.capturedProcessors(3);
    assertEquals(3,processors.get(0).processed.size());
    assertEquals(1,processors.get(1).processed.size());
    assertEquals(2,processors.get(2).processed.size());
  }
  @Test public void testTypeVariance(){
    final Predicate<Number,Object> positive=new Predicate<Number,Object>(){
      @Override public boolean test(      final Number key,      final Object value){
        return key.doubleValue() > 0;
      }
    }
;
    final Predicate<Number,Object> negative=new Predicate<Number,Object>(){
      @Override public boolean test(      final Number key,      final Object value){
        return key.doubleValue() < 0;
      }
    }
;
    @SuppressWarnings("unchecked") final KStream<Integer,String>[] branches=new StreamsBuilder().<Integer,String>stream("empty").branch(positive,negative);
  }
}
