public class StreamThreadStateStoreProviderTest {
  private StreamTask taskOne;
  private StreamThreadStateStoreProvider provider;
  private StateDirectory stateDirectory;
  private File stateDir;
  private final String topicName="topic";
  private StreamThread threadMock;
  private Map<TaskId,StreamTask> tasks;
  @Before public void before(){
    final TopologyWrapper topology=new TopologyWrapper();
    topology.addSource("the-source",topicName);
    topology.addProcessor("the-processor",new MockProcessorSupplier(),"the-source");
    topology.addStateStore(Stores.keyValueStoreBuilder(Stores.inMemoryKeyValueStore("kv-store"),Serdes.String(),Serdes.String()),"the-processor");
    topology.addStateStore(Stores.windowStoreBuilder(Stores.persistentWindowStore("window-store",Duration.ofMillis(10L),Duration.ofMillis(2L),false),Serdes.String(),Serdes.String()),"the-processor");
    final Properties properties=new Properties();
    final String applicationId="applicationId";
    properties.put(StreamsConfig.APPLICATION_ID_CONFIG,applicationId);
    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"localhost:9092");
    stateDir=TestUtils.tempDirectory();
    properties.put(StreamsConfig.STATE_DIR_CONFIG,stateDir.getPath());
    final StreamsConfig streamsConfig=new StreamsConfig(properties);
    final MockClientSupplier clientSupplier=new MockClientSupplier();
    configureRestoreConsumer(clientSupplier,"applicationId-kv-store-changelog");
    configureRestoreConsumer(clientSupplier,"applicationId-window-store-changelog");
    final ProcessorTopology processorTopology=topology.getInternalBuilder(applicationId).build();
    tasks=new HashMap<>();
    stateDirectory=new StateDirectory(streamsConfig,new MockTime());
    taskOne=createStreamsTask(streamsConfig,clientSupplier,processorTopology,new TaskId(0,0));
    taskOne.initializeStateStores();
    tasks.put(new TaskId(0,0),taskOne);
    final StreamTask taskTwo=createStreamsTask(streamsConfig,clientSupplier,processorTopology,new TaskId(0,1));
    taskTwo.initializeStateStores();
    tasks.put(new TaskId(0,1),taskTwo);
    threadMock=EasyMock.createNiceMock(StreamThread.class);
    provider=new StreamThreadStateStoreProvider(threadMock);
  }
  @After public void cleanUp() throws IOException {
    Utils.delete(stateDir);
  }
  @Test public void shouldFindKeyValueStores(){
    mockThread(true);
    final List<ReadOnlyKeyValueStore<String,String>> kvStores=provider.stores("kv-store",QueryableStoreTypes.keyValueStore());
    assertEquals(2,kvStores.size());
  }
  @Test public void shouldFindWindowStores(){
    mockThread(true);
    final List<ReadOnlyWindowStore<Object,Object>> windowStores=provider.stores("window-store",windowStore());
    assertEquals(2,windowStores.size());
  }
  @Test(expected=InvalidStateStoreException.class) public void shouldThrowInvalidStoreExceptionIfWindowStoreClosed(){
    mockThread(true);
    taskOne.getStore("window-store").close();
    provider.stores("window-store",QueryableStoreTypes.windowStore());
  }
  @Test(expected=InvalidStateStoreException.class) public void shouldThrowInvalidStoreExceptionIfKVStoreClosed(){
    mockThread(true);
    taskOne.getStore("kv-store").close();
    provider.stores("kv-store",QueryableStoreTypes.keyValueStore());
  }
  @Test public void shouldReturnEmptyListIfNoStoresFoundWithName(){
    mockThread(true);
    assertEquals(Collections.emptyList(),provider.stores("not-a-store",QueryableStoreTypes.keyValueStore()));
  }
  @Test public void shouldReturnEmptyListIfStoreExistsButIsNotOfTypeValueStore(){
    mockThread(true);
    assertEquals(Collections.emptyList(),provider.stores("window-store",QueryableStoreTypes.keyValueStore()));
  }
  @Test(expected=InvalidStateStoreException.class) public void shouldThrowInvalidStoreExceptionIfNotAllStoresAvailable(){
    mockThread(false);
    provider.stores("kv-store",QueryableStoreTypes.keyValueStore());
  }
  private StreamTask createStreamsTask(  final StreamsConfig streamsConfig,  final MockClientSupplier clientSupplier,  final ProcessorTopology topology,  final TaskId taskId){
    final Metrics metrics=new Metrics();
    return new StreamTask(taskId,Collections.singletonList(new TopicPartition(topicName,taskId.partition)),topology,clientSupplier.consumer,new StoreChangelogReader(clientSupplier.restoreConsumer,Duration.ZERO,new MockStateRestoreListener(),new LogContext("test-stream-task ")),streamsConfig,new MockStreamsMetrics(metrics),stateDirectory,null,new MockTime(),() -> clientSupplier.getProducer(new HashMap<>()),metrics.sensor("dummy")){
      @Override protected void updateOffsetLimits(){
      }
    }
;
  }
  private void mockThread(  final boolean initialized){
    EasyMock.expect(threadMock.isRunningAndNotRebalancing()).andReturn(initialized);
    EasyMock.expect(threadMock.tasks()).andStubReturn(tasks);
    EasyMock.replay(threadMock);
  }
  private void configureRestoreConsumer(  final MockClientSupplier clientSupplier,  final String topic){
    final List<PartitionInfo> partitions=Arrays.asList(new PartitionInfo(topic,0,null,null,null),new PartitionInfo(topic,1,null,null,null));
    clientSupplier.restoreConsumer.updatePartitions(topic,partitions);
    final TopicPartition tp1=new TopicPartition(topic,0);
    final TopicPartition tp2=new TopicPartition(topic,1);
    clientSupplier.restoreConsumer.assign(Arrays.asList(tp1,tp2));
    final Map<TopicPartition,Long> offsets=new HashMap<>();
    offsets.put(tp1,0L);
    offsets.put(tp2,0L);
    clientSupplier.restoreConsumer.updateBeginningOffsets(offsets);
    clientSupplier.restoreConsumer.updateEndOffsets(offsets);
  }
}
