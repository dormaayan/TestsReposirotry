public class MultiRecordsSendTest {
  @Test public void testSendsFreedAfterWriting() throws IOException {
    String dest="1";
    int numChunks=4;
    int chunkSize=32;
    int totalSize=numChunks * chunkSize;
    Queue<Send> sends=new LinkedList<>();
    ByteBuffer[] chunks=new ByteBuffer[numChunks];
    for (int i=0; i < numChunks; i++) {
      ByteBuffer buffer=ByteBuffer.wrap(TestUtils.randomBytes(chunkSize));
      chunks[i]=buffer;
      sends.add(new ByteBufferSend(dest,buffer));
    }
    MultiRecordsSend send=new MultiRecordsSend(dest,sends);
    assertEquals(totalSize,send.size());
    for (int i=0; i < numChunks; i++) {
      assertEquals(numChunks - i,send.numResidentSends());
      NonOverflowingByteBufferChannel out=new NonOverflowingByteBufferChannel(chunkSize);
      send.writeTo(out);
      out.close();
      assertEquals(chunks[i],out.buffer());
    }
    assertEquals(0,send.numResidentSends());
    assertTrue(send.completed());
  }
private static class NonOverflowingByteBufferChannel extends org.apache.kafka.common.requests.ByteBufferChannel {
    private NonOverflowingByteBufferChannel(    long size){
      super(size);
    }
    @Override public long write(    ByteBuffer[] srcs) throws IOException {
      if (!buffer().hasRemaining())       return 0;
      return super.write(srcs);
    }
  }
}
