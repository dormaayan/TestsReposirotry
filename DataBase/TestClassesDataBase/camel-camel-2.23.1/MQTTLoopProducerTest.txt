public class MQTTLoopProducerTest extends MQTTBaseTest {
  @Test public void testProduce() throws Exception {
    MQTT mqtt=new MQTT();
    mqtt.setHost(MQTTTestSupport.getHostForMQTTEndpoint());
    final BlockingConnection subscribeConnection=mqtt.blockingConnection();
    subscribeConnection.connect();
    Topic topic=new Topic(TEST_TOPIC,QoS.AT_MOST_ONCE);
    Topic[] topics={topic};
    subscribeConnection.subscribe(topics);
    final CountDownLatch latch=new CountDownLatch(numberOfMessages * 2);
    Thread thread=new Thread(new Runnable(){
      public void run(){
        for (int i=0; i < numberOfMessages * 2; i++) {
          try {
            Message message=subscribeConnection.receive();
            message.ack();
            latch.countDown();
          }
 catch (          Exception e) {
            e.printStackTrace();
            break;
          }
        }
      }
    }
);
    thread.start();
    Producer producer=context.getEndpoint("direct:foo").createProducer();
    for (int i=0; i < numberOfMessages; i++) {
      Exchange exchange=producer.createExchange();
      exchange.getIn().setBody("test message " + i);
      producer.process(exchange);
    }
    latch.await(10,TimeUnit.SECONDS);
    assertTrue("Messages not consumed = " + latch.getCount(),latch.getCount() == 0);
  }
  protected RouteBuilder createRouteBuilder(){
    return new RouteBuilder(){
      public void configure(){
        from("direct:foo").setHeader(MQTTConfiguration.MQTT_PUBLISH_TOPIC,constant(TEST_TOPIC)).to("mqtt:boo1?host=" + MQTTTestSupport.getHostForMQTTEndpoint() + "&qualityOfService=AtMostOnce").setHeader(MQTTConfiguration.MQTT_PUBLISH_TOPIC,constant(TEST_TOPIC)).to("mqtt:boo2?host=" + MQTTTestSupport.getHostForMQTTEndpoint() + "&qualityOfService=AtMostOnce");
      }
    }
;
  }
}
