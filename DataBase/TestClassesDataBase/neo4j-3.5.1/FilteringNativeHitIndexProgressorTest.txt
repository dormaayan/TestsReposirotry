public class FilteringNativeHitIndexProgressorTest {
  @Rule public final RandomRule random=new RandomRule();
  @Test public void shouldFilterResults(){
    List<String> keys=new ArrayList<>();
    for (int i=0; i < 100; i++) {
      keys.add(random.nextString());
    }
    RawCursor<Hit<StringIndexKey,NativeIndexValue>,IOException> cursor=new ResultCursor(keys.iterator());
    NodeValueIterator valueClient=new NodeValueIterator(){
      @Override public boolean needsValues(){
        return true;
      }
    }
;
    IndexQuery[] predicates=new IndexQuery[]{mock(IndexQuery.class)};
    Predicate<String> filter=string -> string.contains("a");
    when(predicates[0].acceptsValue(any(Value.class))).then(invocation -> filter.test(((TextValue)invocation.getArgument(0)).stringValue()));
    FilteringNativeHitIndexProgressor<StringIndexKey,NativeIndexValue> progressor=new FilteringNativeHitIndexProgressor<>(cursor,valueClient,new ArrayList<>(),predicates);
    valueClient.initialize(TestIndexDescriptorFactory.forLabel(0,0),progressor,predicates,IndexOrder.NONE,valueClient.needsValues());
    List<Long> result=new ArrayList<>();
    while (valueClient.hasNext()) {
      result.add(valueClient.next());
    }
    for (int i=0; i < keys.size(); i++) {
      if (filter.test(keys.get(i))) {
        assertTrue(result.remove((long)i));
      }
    }
    assertTrue(result.isEmpty());
  }
}
