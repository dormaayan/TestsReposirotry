/** 
 * Here we are verifying that even if we get an exception from the storage layer during commit, we should still be able to recover to a consistent state.
 */
public class PartialTransactionFailureIT {
  @Rule public final TestDirectory dir=TestDirectory.testDirectory();
  @Test public void concurrentlyCommittingTransactionsMustNotRotateOutLoggedCommandsOfFailingTransaction() throws Exception {
    final ClassGuardedAdversary adversary=new ClassGuardedAdversary(new CountingAdversary(1,false),Command.RelationshipCommand.class);
    adversary.disable();
    File storeDir=dir.storeDir();
    final Map<String,String> params=stringMap(GraphDatabaseSettings.pagecache_memory.name(),"8m");
    final EmbeddedGraphDatabase db=new TestEmbeddedGraphDatabase(storeDir,params){
      @Override protected void create(      File storeDir,      Map<String,String> params,      GraphDatabaseFacadeFactory.Dependencies dependencies){
        new GraphDatabaseFacadeFactory(DatabaseInfo.COMMUNITY,CommunityEditionModule::new){
          @Override protected PlatformModule createPlatform(          File storeDir,          Config config,          Dependencies dependencies){
            return new PlatformModule(storeDir,config,databaseInfo,dependencies){
              @Override protected FileSystemAbstraction createFileSystemAbstraction(){
                return new AdversarialFileSystemAbstraction(adversary);
              }
            }
;
          }
        }
.initFacade(storeDir,params,dependencies,this);
      }
    }
;
    Node a;
    Node b;
    Node c;
    Node d;
    try (Transaction tx=db.beginTx()){
      a=db.createNode();
      b=db.createNode();
      c=db.createNode();
      d=db.createNode();
      tx.success();
    }
     adversary.enable();
    CountDownLatch latch=new CountDownLatch(1);
    Thread t1=new Thread(createRelationship(db,a,b,latch),"T1");
    Thread t2=new Thread(createRelationship(db,c,d,latch),"T2");
    t1.start();
    t2.start();
    t1.join(10);
    t2.join(10);
    latch.countDown();
    t1.join(25000);
    t2.join(25000);
    db.shutdown();
    EmbeddedGraphDatabase db2=new TestEmbeddedGraphDatabase(storeDir,params);
    try (Transaction tx=db2.beginTx()){
      Node x=db2.getNodeById(a.getId());
      Node y=db2.getNodeById(b.getId());
      Node z=db2.getNodeById(c.getId());
      Node w=db2.getNodeById(d.getId());
      Iterator<Relationship> itrRelX=x.getRelationships().iterator();
      Iterator<Relationship> itrRelY=y.getRelationships().iterator();
      Iterator<Relationship> itrRelZ=z.getRelationships().iterator();
      Iterator<Relationship> itrRelW=w.getRelationships().iterator();
      if (itrRelX.hasNext() != itrRelY.hasNext()) {
        fail("Node x and y have inconsistent relationship counts");
      }
 else       if (itrRelX.hasNext()) {
        Relationship rel=itrRelX.next();
        assertEquals(rel,itrRelY.next());
        assertFalse(itrRelX.hasNext());
        assertFalse(itrRelY.hasNext());
      }
      if (itrRelZ.hasNext() != itrRelW.hasNext()) {
        fail("Node z and w have inconsistent relationship counts");
      }
 else       if (itrRelZ.hasNext()) {
        Relationship rel=itrRelZ.next();
        assertEquals(rel,itrRelW.next());
        assertFalse(itrRelZ.hasNext());
        assertFalse(itrRelW.hasNext());
      }
    }
  finally {
      db2.shutdown();
    }
  }
  private Runnable createRelationship(  final EmbeddedGraphDatabase db,  final Node x,  final Node y,  final CountDownLatch latch){
    return () -> {
      try (Transaction tx=db.beginTx()){
        x.createRelationshipTo(y,RelationshipType.withName("r"));
        tx.success();
        latch.await();
        db.getDependencyResolver().resolveDependency(LogRotation.class).rotateLogFile();
        db.getDependencyResolver().resolveDependency(CheckPointer.class).forceCheckPoint(new SimpleTriggerInfo("test"));
      }
 catch (      Exception ignore) {
      }
    }
;
  }
private static class TestEmbeddedGraphDatabase extends EmbeddedGraphDatabase {
    TestEmbeddedGraphDatabase(    File storeDir,    Map<String,String> params){
      super(storeDir,params,dependencies());
    }
    private static GraphDatabaseFacadeFactory.Dependencies dependencies(){
      GraphDatabaseFactoryState state=new GraphDatabaseFactoryState();
      return state.databaseDependencies();
    }
  }
}
