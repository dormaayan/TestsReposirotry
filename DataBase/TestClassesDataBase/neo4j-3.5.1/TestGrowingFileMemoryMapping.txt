public class TestGrowingFileMemoryMapping {
  private final ConfigurablePageCacheRule pageCacheRule=new ConfigurablePageCacheRule();
  private final TestDirectory testDirectory=TestDirectory.testDirectory();
  private final DefaultFileSystemRule fileSystemRule=new DefaultFileSystemRule();
  @Rule public RuleChain ruleChain=RuleChain.outerRule(testDirectory).around(fileSystemRule).around(pageCacheRule);
  @Test public void shouldGrowAFileWhileContinuingToMemoryMapNewRegions(){
    assumeTrue(!SystemUtils.IS_OS_WINDOWS);
    final int NUMBER_OF_RECORDS=1000000;
    Config config=Config.defaults(pagecache_memory,mmapSize(NUMBER_OF_RECORDS,NodeRecordFormat.RECORD_SIZE));
    FileSystemAbstraction fileSystemAbstraction=fileSystemRule.get();
    DefaultIdGeneratorFactory idGeneratorFactory=new DefaultIdGeneratorFactory(fileSystemAbstraction);
    PageCache pageCache=pageCacheRule.getPageCache(fileSystemAbstraction,config);
    StoreFactory storeFactory=new StoreFactory(testDirectory.databaseLayout(),config,idGeneratorFactory,pageCache,fileSystemAbstraction,NullLogProvider.getInstance(),EmptyVersionContextSupplier.EMPTY);
    NeoStores neoStores=storeFactory.openAllNeoStores(true);
    NodeStore nodeStore=neoStores.getNodeStore();
    int iterations=2 * NUMBER_OF_RECORDS;
    long startingId=nodeStore.nextId();
    long nodeId=startingId;
    for (int i=0; i < iterations; i++) {
      NodeRecord record=new NodeRecord(nodeId,false,i,0);
      record.setInUse(true);
      nodeStore.updateRecord(record);
      nodeId=nodeStore.nextId();
    }
    NodeRecord record=new NodeRecord(0,false,0,0);
    for (int i=0; i < iterations; i++) {
      record.setId(startingId + i);
      nodeStore.getRecord(i,record,NORMAL);
      assertTrue("record[" + i + "] should be in use",record.inUse());
      assertThat("record[" + i + "] should have nextRelId of "+ i,record.getNextRel(),is((long)i));
    }
    neoStores.close();
  }
  private static String mmapSize(  int numberOfRecords,  int recordSize){
    int bytes=numberOfRecords * recordSize;
    long mebiByte=ByteUnit.mebiBytes(1);
    if (bytes < mebiByte) {
      throw new IllegalArgumentException("too few records: " + numberOfRecords);
    }
    return bytes / mebiByte + "M";
  }
}
