/** 
 * This is the test suite that tested the original (from 2007) lock manager. It has been ported to test  {@link org.neo4j.kernel.impl.locking.Locks}to ensure implementors of that API don't fall in any of the traps this test suite sets for them.
 */
@Ignore("Not a test. This is a compatibility suite, run from LockingCompatibilityTestSuite.") public class RWLockCompatibility extends LockingCompatibilityTestSuite.Compatibility {
  public RWLockCompatibility(  LockingCompatibilityTestSuite suite){
    super(suite);
  }
  @Test public void testSingleThread(){
    try {
      clientA.releaseExclusive(NODE,1L);
      fail("Invalid release should throw exception");
    }
 catch (    Exception e) {
    }
    try {
      clientA.releaseShared(NODE,1L);
      fail("Invalid release should throw exception");
    }
 catch (    Exception e) {
    }
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    try {
      clientA.releaseExclusive(NODE,1L);
      fail("Invalid release should throw exception");
    }
 catch (    Exception e) {
    }
    clientA.releaseShared(NODE,1L);
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    try {
      clientA.releaseShared(NODE,1L);
      fail("Invalid release should throw exception");
    }
 catch (    Exception e) {
    }
    clientA.releaseExclusive(NODE,1L);
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    clientA.releaseExclusive(NODE,1L);
    clientA.releaseShared(NODE,1L);
    clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
    clientA.acquireShared(LockTracer.NONE,NODE,1L);
    clientA.releaseShared(NODE,1L);
    clientA.releaseExclusive(NODE,1L);
    for (int i=0; i < 10; i++) {
      if ((i % 2) == 0) {
        clientA.acquireExclusive(LockTracer.NONE,NODE,1L);
      }
 else {
        clientA.acquireShared(LockTracer.NONE,NODE,1L);
      }
    }
    for (int i=9; i >= 0; i--) {
      if ((i % 2) == 0) {
        clientA.releaseExclusive(NODE,1L);
      }
 else {
        clientA.releaseShared(NODE,1L);
      }
    }
  }
  @Test public void testMultipleThreads() throws Exception {
    LockWorker t1=new LockWorker("T1",locks);
    LockWorker t2=new LockWorker("T2",locks);
    LockWorker t3=new LockWorker("T3",locks);
    LockWorker t4=new LockWorker("T4",locks);
    long r1=1L;
    try {
      t1.getReadLock(r1,true);
      t2.getReadLock(r1,true);
      t3.getReadLock(r1,true);
      Future<Void> t4Wait=t4.getWriteLock(r1,false);
      t3.releaseReadLock(r1);
      t2.releaseReadLock(r1);
      assertTrue(!t4Wait.isDone());
      t1.releaseReadLock(r1);
      t4.awaitFuture(t4Wait);
      t4.getReadLock(r1,true);
      t4.getReadLock(r1,true);
      Future<Void> t1Wait=t1.getReadLock(r1,false);
      t4.getReadLock(r1,true);
      t4.releaseReadLock(r1);
      t4.getWriteLock(r1,true);
      t4.releaseWriteLock(r1);
      assertTrue(!t1Wait.isDone());
      t4.releaseWriteLock(r1);
      t1.awaitFuture(t1Wait);
      t4.releaseReadLock(r1);
      t4Wait=t4.getWriteLock(r1,false);
      t1.releaseReadLock(r1);
      t4.awaitFuture(t4Wait);
      t4.releaseReadLock(r1);
      t4.releaseWriteLock(r1);
      t4.getWriteLock(r1,true);
      t1Wait=t1.getReadLock(r1,false);
      Future<Void> t2Wait=t2.getReadLock(r1,false);
      Future<Void> t3Wait=t3.getReadLock(r1,false);
      t4.getReadLock(r1,true);
      t4.releaseWriteLock(r1);
      t1.awaitFuture(t1Wait);
      t2.awaitFuture(t2Wait);
      t3.awaitFuture(t3Wait);
      t1Wait=t1.getWriteLock(r1,false);
      t2.releaseReadLock(r1);
      t4.releaseReadLock(r1);
      t3.releaseReadLock(r1);
      t1.awaitFuture(t1Wait);
      t1.releaseWriteLock(r1);
      t2.getReadLock(r1,true);
      t1.releaseReadLock(r1);
      t2.getWriteLock(r1,true);
      t2.releaseWriteLock(r1);
      t2.releaseReadLock(r1);
    }
 catch (    Exception e) {
      LockWorkFailureDump dumper=new LockWorkFailureDump(testDir.file(getClass().getSimpleName()));
      File file=dumper.dumpState(locks,t1,t2,t3,t4);
      throw new RuntimeException("Failed, forensics information dumped to " + file.getAbsolutePath(),e);
    }
 finally {
      t1.close();
      t2.close();
      t3.close();
      t4.close();
    }
  }
public class StressThread extends Thread {
    private final Random rand=new Random(currentTimeMillis());
    private final Object READ=new Object();
    private final Object WRITE=new Object();
    private final String name;
    private final int numberOfIterations;
    private final int depthCount;
    private final float readWriteRatio;
    private final CountDownLatch startSignal;
    private final Locks.Client client;
    private final long nodeId;
    private Exception error;
    StressThread(    String name,    int numberOfIterations,    int depthCount,    float readWriteRatio,    long nodeId,    CountDownLatch startSignal){
      super();
      this.nodeId=nodeId;
      this.client=locks.newClient();
      this.name=name;
      this.numberOfIterations=numberOfIterations;
      this.depthCount=depthCount;
      this.readWriteRatio=readWriteRatio;
      this.startSignal=startSignal;
    }
    @Override public void run(){
      try {
        startSignal.await();
        java.util.Stack<Object> lockStack=new java.util.Stack<>();
        for (int i=0; i < numberOfIterations; i++) {
          try {
            int depth=depthCount;
            do {
              float f=rand.nextFloat();
              if (f < readWriteRatio) {
                client.acquireShared(LockTracer.NONE,NODE,nodeId);
                lockStack.push(READ);
              }
 else {
                client.acquireExclusive(LockTracer.NONE,NODE,nodeId);
                lockStack.push(WRITE);
              }
            }
 while (--depth > 0);
            while (!lockStack.isEmpty()) {
              if (lockStack.pop() == READ) {
                client.releaseShared(NODE,nodeId);
              }
 else {
                client.releaseExclusive(NODE,nodeId);
              }
            }
          }
 catch (          DeadlockDetectedException ignored) {
          }
 finally {
            while (!lockStack.isEmpty()) {
              if (lockStack.pop() == READ) {
                client.releaseShared(NODE,nodeId);
              }
 else {
                client.releaseExclusive(NODE,nodeId);
              }
            }
          }
        }
      }
 catch (      Exception e) {
        error=e;
      }
    }
    @Override public String toString(){
      return this.name;
    }
  }
  @Test public void testStressMultipleThreads() throws Exception {
    long r1=1L;
    StressThread[] stressThreads=new StressThread[100];
    CountDownLatch startSignal=new CountDownLatch(1);
    for (int i=0; i < 100; i++) {
      stressThreads[i]=new StressThread("Thread" + i,100,9,0.50f,r1,startSignal);
    }
    for (int i=0; i < 100; i++) {
      stressThreads[i].start();
    }
    startSignal.countDown();
    long end=currentTimeMillis() + SECONDS.toMillis(2000);
    boolean anyAlive;
    while ((anyAlive=anyAliveAndAllWell(stressThreads)) && currentTimeMillis() < end) {
      sleepALittle();
    }
    for (    StressThread stressThread : stressThreads) {
      if (stressThread.error != null) {
        throw stressThread.error;
      }
 else       if (stressThread.isAlive()) {
        for (        StackTraceElement stackTraceElement : stressThread.getStackTrace()) {
          System.out.println(stackTraceElement);
        }
      }
    }
    if (anyAlive) {
      throw new RuntimeException("Expected all threads to complete.");
    }
  }
  private void sleepALittle(){
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
    }
  }
  private boolean anyAliveAndAllWell(  StressThread[] stressThreads){
    for (    StressThread stressThread : stressThreads) {
      if (stressThread.error != null) {
        return false;
      }
      if (stressThread.isAlive()) {
        return true;
      }
    }
    return false;
  }
}
