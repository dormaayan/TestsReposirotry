private static class LlapTaskSchedulerServiceForTestControlled extends LlapTaskSchedulerServiceForTest {
  private DelayedTaskSchedulerCallableControlled controlledTSCallable;
  public LlapTaskSchedulerServiceForTestControlled(  TaskSchedulerContext appClient,  Clock clock){
    super(appClient,clock);
  }
  @Override LlapTaskSchedulerService.DelayedTaskSchedulerCallable createDelayedTaskSchedulerCallable(){
    controlledTSCallable=new DelayedTaskSchedulerCallableControlled();
    return controlledTSCallable;
  }
class DelayedTaskSchedulerCallableControlled extends DelayedTaskSchedulerCallable {
    private final ReentrantLock lock=new ReentrantLock();
    private final Condition triggerRunCondition=lock.newCondition();
    private boolean shouldRun=false;
    private final Condition runCompleteCondition=lock.newCondition();
    private boolean runComplete=false;
    static final int STATE_NOT_RUN=0;
    static final int STATE_NULL_FOUND=1;
    static final int STATE_TIMEOUT_NOT_EXPIRED=2;
    static final int STATE_RETURNED_TASK=3;
    volatile int lastState=STATE_NOT_RUN;
    volatile boolean lastShouldScheduleTaskResult=false;
    volatile boolean shouldScheduleTaskTriggered=false;
    @Override public void processEvictedTask(    TaskInfo taskInfo){
      super.processEvictedTask(taskInfo);
      signalRunComplete();
    }
    @Override public TaskInfo getNextTask() throws InterruptedException {
      while (true) {
        lock.lock();
        try {
          while (!shouldRun) {
            triggerRunCondition.await();
          }
          shouldRun=false;
        }
  finally {
          lock.unlock();
        }
        TaskInfo taskInfo=delayedTaskQueue.peek();
        if (taskInfo == null) {
          LOG.info("Triggered getTask but the queue is empty");
          lastState=STATE_NULL_FOUND;
          signalRunComplete();
          continue;
        }
        if (taskInfo.shouldDelayForLocality(LlapTaskSchedulerServiceForTestControlled.this.clock.getTime())) {
          LOG.info("Triggered getTask but the first element is not ready to execute");
          lastState=STATE_TIMEOUT_NOT_EXPIRED;
          signalRunComplete();
          continue;
        }
 else {
          delayedTaskQueue.poll();
          lastState=STATE_RETURNED_TASK;
          return taskInfo;
        }
      }
    }
    @Override public boolean shouldScheduleTask(    TaskInfo taskInfo){
      shouldScheduleTaskTriggered=true;
      lastShouldScheduleTaskResult=super.shouldScheduleTask(taskInfo);
      return lastShouldScheduleTaskResult;
    }
    void resetShouldScheduleInformation(){
      shouldScheduleTaskTriggered=false;
      lastShouldScheduleTaskResult=false;
    }
    private void signalRunComplete(){
      lock.lock();
      try {
        runComplete=true;
        runCompleteCondition.signal();
      }
  finally {
        lock.unlock();
      }
    }
    void triggerGetNextTask(){
      lock.lock();
      try {
        shouldRun=true;
        triggerRunCondition.signal();
      }
  finally {
        lock.unlock();
      }
    }
    void awaitGetNextTaskProcessing() throws InterruptedException {
      lock.lock();
      try {
        while (!runComplete) {
          runCompleteCondition.await();
        }
        runComplete=false;
      }
  finally {
        lock.unlock();
      }
    }
  }
}
