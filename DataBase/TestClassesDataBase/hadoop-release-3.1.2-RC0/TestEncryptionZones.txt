public class TestEncryptionZones {
  static final Logger LOG=Logger.getLogger(TestEncryptionZones.class);
  protected Configuration conf;
  private FileSystemTestHelper fsHelper;
  protected MiniDFSCluster cluster;
  protected HdfsAdmin dfsAdmin;
  protected DistributedFileSystem fs;
  private File testRootDir;
  protected final String TEST_KEY="test_key";
  private static final String NS_METRICS="FSNamesystem";
  private static final String AUTHORIZATION_EXCEPTION_MESSAGE="User [root] is not authorized to perform [READ] on key " + "with ACL name [key2]!!";
  protected FileSystemTestWrapper fsWrapper;
  protected FileContextTestWrapper fcWrapper;
  protected static final EnumSet<CreateEncryptionZoneFlag> NO_TRASH=EnumSet.of(CreateEncryptionZoneFlag.NO_TRASH);
  protected String getKeyProviderURI(){
    return JavaKeyStoreProvider.SCHEME_NAME + "://file" + new Path(testRootDir.toString(),"test.jks").toUri();
  }
  @Rule public Timeout globalTimeout=new Timeout(120 * 1000);
  @Before public void setup() throws Exception {
    conf=new HdfsConfiguration();
    fsHelper=new FileSystemTestHelper();
    String testRoot=fsHelper.getTestRootDir();
    testRootDir=new File(testRoot).getAbsoluteFile();
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,getKeyProviderURI());
    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,true);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_LIST_ENCRYPTION_ZONES_NUM_RESPONSES,2);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    Logger.getLogger(EncryptionZoneManager.class).setLevel(Level.TRACE);
    fs=cluster.getFileSystem();
    fsWrapper=new FileSystemTestWrapper(fs);
    fcWrapper=new FileContextTestWrapper(FileContext.getFileContext(cluster.getURI(),conf));
    dfsAdmin=new HdfsAdmin(cluster.getURI(),conf);
    setProvider();
    DFSTestUtil.createKey(TEST_KEY,cluster,conf);
  }
  protected void setProvider(){
    fs.getClient().setKeyProvider(cluster.getNameNode().getNamesystem().getProvider());
  }
  @After public void teardown(){
    if (cluster != null) {
      cluster.shutdown();
      cluster=null;
    }
    EncryptionFaultInjector.instance=new EncryptionFaultInjector();
  }
  public void assertNumZones(  final int numZones) throws IOException {
    RemoteIterator<EncryptionZone> it=dfsAdmin.listEncryptionZones();
    int count=0;
    while (it.hasNext()) {
      count++;
      it.next();
    }
    assertEquals("Unexpected number of encryption zones!",numZones,count);
  }
  /** 
 * Checks that an encryption zone with the specified keyName and path (if not null) is present.
 * @throws IOException if a matching zone could not be found
 */
  public void assertZonePresent(  String keyName,  String path) throws IOException {
    final RemoteIterator<EncryptionZone> it=dfsAdmin.listEncryptionZones();
    boolean match=false;
    while (it.hasNext()) {
      EncryptionZone zone=it.next();
      boolean matchKey=(keyName == null);
      boolean matchPath=(path == null);
      if (keyName != null && zone.getKeyName().equals(keyName)) {
        matchKey=true;
      }
      if (path != null && zone.getPath().equals(path)) {
        matchPath=true;
      }
      if (matchKey && matchPath) {
        match=true;
        break;
      }
    }
    assertTrue("Did not find expected encryption zone with keyName " + keyName + " path "+ path,match);
  }
  /** 
 * Make sure hdfs crypto -createZone command creates a trash directory with sticky bits.
 * @throws Exception
 */
  @Test public void testTrashStickyBit() throws Exception {
    final Path zoneParent=new Path("/zones");
    final Path zone1=new Path(zoneParent,"zone1");
    CryptoAdmin cryptoAdmin=new CryptoAdmin(conf);
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    fsWrapper.setPermission(zone1,new FsPermission(FsAction.ALL,FsAction.ALL,FsAction.ALL));
    String[] cryptoArgv=new String[]{"-createZone","-keyName",TEST_KEY,"-path",zone1.toUri().getPath()};
    cryptoAdmin.run(cryptoArgv);
    final Path ezfile1=new Path(zone1,"file1");
    final int len=8192;
    DFSTestUtil.createFile(fs,ezfile1,len,(short)1,0xFEED);
    Configuration clientConf=new Configuration(conf);
    clientConf.setLong(FS_TRASH_INTERVAL_KEY,1);
    final FsShell shell=new FsShell(clientConf);
    String[] argv=new String[]{"-rm",ezfile1.toString()};
    int res=ToolRunner.run(shell,argv);
    assertEquals("Can't remove a file in EZ as superuser",0,res);
    final Path trashDir=new Path(zone1,FileSystem.TRASH_PREFIX);
    assertTrue(fsWrapper.exists(trashDir));
    FileStatus trashFileStatus=fsWrapper.getFileStatus(trashDir);
    assertTrue(trashFileStatus.getPermission().getStickyBit());
    final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
    user.doAs(new PrivilegedExceptionAction<Object>(){
      @Override public Object run() throws Exception {
        final Path ezfile2=new Path(zone1,"file2");
        final int len=8192;
        FileSystem fs2=FileSystem.get(cluster.getConfiguration(0));
        DFSTestUtil.createFile(fs2,ezfile2,len,(short)1,0xFEED);
        String[] argv=new String[]{"-rm",ezfile2.toString()};
        int res=ToolRunner.run(shell,argv);
        assertEquals("Can't remove a file in EZ as user:mygroup",0,res);
        return null;
      }
    }
);
  }
  /** 
 * Make sure hdfs crypto -provisionTrash command creates a trash directory with sticky bits.
 * @throws Exception
 */
  @Test public void testProvisionTrash() throws Exception {
    final Path zoneParent=new Path("/zones");
    final Path zone1=new Path(zoneParent,"zone1");
    CryptoAdmin cryptoAdmin=new CryptoAdmin(conf);
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    String[] cryptoArgv=new String[]{"-createZone","-keyName",TEST_KEY,"-path",zone1.toUri().getPath()};
    cryptoAdmin.run(cryptoArgv);
    Configuration clientConf=new Configuration(conf);
    clientConf.setLong(FS_TRASH_INTERVAL_KEY,1);
    final FsShell shell=new FsShell(clientConf);
    final Path trashDir=new Path(zone1,FileSystem.TRASH_PREFIX);
    String[] argv=new String[]{"-rmdir",trashDir.toUri().getPath()};
    int res=ToolRunner.run(shell,argv);
    assertEquals("Unable to delete trash directory.",0,res);
    assertFalse(fsWrapper.exists(trashDir));
    String[] provisionTrashArgv=new String[]{"-provisionTrash","-path",zone1.toUri().getPath()};
    cryptoAdmin.run(provisionTrashArgv);
    assertTrue(fsWrapper.exists(trashDir));
    FileStatus trashFileStatus=fsWrapper.getFileStatus(trashDir);
    assertTrue(trashFileStatus.getPermission().getStickyBit());
  }
  @Test public void testBasicOperations() throws Exception {
    assertNotNull("key provider is not present",dfsAdmin.getKeyProvider());
    int numZones=0;
    assertEquals("Unexpected number of encryption zones!",numZones,cluster.getNamesystem().getNumEncryptionZones());
    final Path zoneParent=new Path("/zones");
    final Path zone1=new Path(zoneParent,"zone1");
    try {
      dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
      fail("expected /test doesn't exist");
    }
 catch (    IOException e) {
      assertExceptionContains("cannot find",e);
    }
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
    assertNumZones(++numZones);
    assertZonePresent(null,zone1.toString());
    try {
      dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
    }
 catch (    IOException e) {
      assertExceptionContains("is already an encryption zone",e);
    }
    try {
      dfsAdmin.createEncryptionZone(zoneParent,TEST_KEY,NO_TRASH);
      fail("EZ over an EZ");
    }
 catch (    IOException e) {
      assertExceptionContains("encryption zone for a non-empty directory",e);
    }
    final Path notEmpty=new Path("/notEmpty");
    final Path notEmptyChild=new Path(notEmpty,"child");
    fsWrapper.mkdir(notEmptyChild,FsPermission.getDirDefault(),true);
    try {
      dfsAdmin.createEncryptionZone(notEmpty,TEST_KEY,NO_TRASH);
      fail("Created EZ on an non-empty directory with folder");
    }
 catch (    IOException e) {
      assertExceptionContains("create an encryption zone",e);
    }
    fsWrapper.delete(notEmptyChild,false);
    fsWrapper.createFile(notEmptyChild);
    try {
      dfsAdmin.createEncryptionZone(notEmpty,TEST_KEY,NO_TRASH);
      fail("Created EZ on an non-empty directory with file");
    }
 catch (    IOException e) {
      assertExceptionContains("create an encryption zone",e);
    }
    try {
      dfsAdmin.createEncryptionZone(notEmptyChild,TEST_KEY,NO_TRASH);
      fail("Created EZ on a file");
    }
 catch (    IOException e) {
      assertExceptionContains("create an encryption zone for a file.",e);
    }
    final Path zone2=new Path("/zone2");
    fsWrapper.mkdir(zone2,FsPermission.getDirDefault(),false);
    final String myKeyName="mykeyname";
    try {
      dfsAdmin.createEncryptionZone(zone2,myKeyName,NO_TRASH);
      fail("expected key doesn't exist");
    }
 catch (    IOException e) {
      assertExceptionContains("doesn't exist.",e);
    }
    try {
      dfsAdmin.createEncryptionZone(zone2,"",NO_TRASH);
      fail("created a zone with empty key name");
    }
 catch (    IOException e) {
      assertExceptionContains("Must specify a key name when creating",e);
    }
    try {
      dfsAdmin.createEncryptionZone(zone2,null,NO_TRASH);
      fail("created a zone with null key name");
    }
 catch (    IOException e) {
      assertExceptionContains("Must specify a key name when creating",e);
    }
    assertNumZones(1);
    DFSTestUtil.createKey(myKeyName,cluster,conf);
    dfsAdmin.createEncryptionZone(zone2,myKeyName,NO_TRASH);
    assertNumZones(++numZones);
    assertZonePresent(myKeyName,zone2.toString());
    final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
    final Path nonSuper=new Path("/nonSuper");
    fsWrapper.mkdir(nonSuper,FsPermission.getDirDefault(),false);
    user.doAs(new PrivilegedExceptionAction<Object>(){
      @Override public Object run() throws Exception {
        final HdfsAdmin userAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
        try {
          userAdmin.createEncryptionZone(nonSuper,TEST_KEY,NO_TRASH);
          fail("createEncryptionZone is superuser-only operation");
        }
 catch (        AccessControlException e) {
          assertExceptionContains("Superuser privilege is required",e);
        }
        return null;
      }
    }
);
    Path deepZone=new Path("/d/e/e/p/zone");
    fsWrapper.mkdir(deepZone,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(deepZone,TEST_KEY,NO_TRASH);
    assertNumZones(++numZones);
    assertZonePresent(null,deepZone.toString());
    for (int i=1; i < 6; i++) {
      final Path zonePath=new Path("/listZone" + i);
      fsWrapper.mkdir(zonePath,FsPermission.getDirDefault(),false);
      dfsAdmin.createEncryptionZone(zonePath,TEST_KEY,NO_TRASH);
      numZones++;
      assertNumZones(numZones);
      assertZonePresent(null,zonePath.toString());
    }
    fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
    fs.saveNamespace();
    fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
    cluster.restartNameNode(true);
    assertNumZones(numZones);
    assertEquals("Unexpected number of encryption zones!",numZones,cluster.getNamesystem().getNumEncryptionZones());
    assertGauge("NumEncryptionZones",numZones,getMetrics(NS_METRICS));
    assertZonePresent(null,zone1.toString());
    Path nonpersistZone=new Path("/nonpersistZone");
    fsWrapper.mkdir(nonpersistZone,FsPermission.getDirDefault(),false);
    dfsAdmin.createEncryptionZone(nonpersistZone,TEST_KEY,NO_TRASH);
    numZones++;
    cluster.restartNameNode(true);
    assertNumZones(numZones);
    assertZonePresent(null,nonpersistZone.toString());
  }
  @Test public void testBasicOperationsRootDir() throws Exception {
    int numZones=0;
    final Path rootDir=new Path("/");
    final Path zone1=new Path(rootDir,"zone1");
    dfsAdmin.createEncryptionZone(rootDir,TEST_KEY,NO_TRASH);
    assertNumZones(++numZones);
    assertZonePresent(null,rootDir.toString());
    fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
    fs.saveNamespace();
    fs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
    cluster.restartNameNode(true);
    assertNumZones(numZones);
    assertZonePresent(null,rootDir.toString());
  }
  @Test public void testEZwithFullyQualifiedPath() throws Exception {
    final Path zoneParent=new Path("/zones");
    final Path zone1=new Path(zoneParent,"zone1");
    final Path zone1FQP=new Path(cluster.getURI().toString(),zone1);
    final Path zone2=new Path(zoneParent,"zone2");
    final Path zone2FQP=new Path(cluster.getURI().toString(),zone2);
    int numZones=0;
    EnumSet<CreateEncryptionZoneFlag> withTrash=EnumSet.of(CreateEncryptionZoneFlag.PROVISION_TRASH);
    fsWrapper.mkdir(zone1FQP,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(zone1FQP,TEST_KEY,withTrash);
    assertNumZones(++numZones);
    assertZonePresent(TEST_KEY,zone1.toString());
    final Path zone1Trash=new Path(zone1,fs.TRASH_PREFIX);
    assertTrue("CreateEncryptionZone with trash enabled should create a " + ".Trash directory in the EZ",fs.exists(zone1Trash));
    EncryptionZone ezForZone1=dfsAdmin.getEncryptionZoneForPath(zone1FQP);
    assertTrue("getEncryptionZoneForPath for fully qualified path should " + "return the path component",ezForZone1.getPath().equals(zone1.toString()));
    fsWrapper.mkdir(zone2FQP,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(zone2FQP,TEST_KEY,NO_TRASH);
    assertNumZones(++numZones);
    assertZonePresent(TEST_KEY,zone2.toString());
    dfsAdmin.provisionEncryptionZoneTrash(zone2FQP);
    EncryptionZone ezForZone2=dfsAdmin.getEncryptionZoneForPath(zone2FQP);
    Path ezTrashForZone2=new Path(ezForZone2.getPath(),FileSystem.TRASH_PREFIX);
    assertTrue("provisionEZTrash with fully qualified path should create " + "trash directory ",fsWrapper.exists(ezTrashForZone2));
  }
  /** 
 * Test listing encryption zones as a non super user.
 */
  @Test public void testListEncryptionZonesAsNonSuperUser() throws Exception {
    final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
    final Path testRoot=new Path("/tmp/TestEncryptionZones");
    final Path superPath=new Path(testRoot,"superuseronly");
    final Path allPath=new Path(testRoot,"accessall");
    fsWrapper.mkdir(superPath,new FsPermission((short)0700),true);
    dfsAdmin.createEncryptionZone(superPath,TEST_KEY,NO_TRASH);
    fsWrapper.mkdir(allPath,new FsPermission((short)0707),true);
    dfsAdmin.createEncryptionZone(allPath,TEST_KEY,NO_TRASH);
    user.doAs(new PrivilegedExceptionAction<Object>(){
      @Override public Object run() throws Exception {
        final HdfsAdmin userAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
        try {
          userAdmin.listEncryptionZones();
        }
 catch (        AccessControlException e) {
          assertExceptionContains("Superuser privilege is required",e);
        }
        return null;
      }
    }
);
  }
  /** 
 * Test getEncryptionZoneForPath as a non super user.
 */
  @Test public void testGetEZAsNonSuperUser() throws Exception {
    final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
    final Path testRoot=new Path("/tmp/TestEncryptionZones");
    final Path superPath=new Path(testRoot,"superuseronly");
    final Path superPathFile=new Path(superPath,"file1");
    final Path allPath=new Path(testRoot,"accessall");
    final Path allPathFile=new Path(allPath,"file1");
    final Path nonEZDir=new Path(testRoot,"nonEZDir");
    final Path nonEZFile=new Path(nonEZDir,"file1");
    final Path nonexistent=new Path("/nonexistent");
    final int len=8192;
    fsWrapper.mkdir(testRoot,new FsPermission((short)0777),true);
    fsWrapper.mkdir(superPath,new FsPermission((short)0700),false);
    fsWrapper.mkdir(allPath,new FsPermission((short)0777),false);
    fsWrapper.mkdir(nonEZDir,new FsPermission((short)0777),false);
    dfsAdmin.createEncryptionZone(superPath,TEST_KEY,NO_TRASH);
    dfsAdmin.createEncryptionZone(allPath,TEST_KEY,NO_TRASH);
    dfsAdmin.allowSnapshot(new Path("/"));
    final Path newSnap=fs.createSnapshot(new Path("/"));
    DFSTestUtil.createFile(fs,superPathFile,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,allPathFile,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,nonEZFile,len,(short)1,0xFEED);
    user.doAs(new PrivilegedExceptionAction<Object>(){
      @Override public Object run() throws Exception {
        final HdfsAdmin userAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
        try {
          userAdmin.getEncryptionZoneForPath(null);
          fail("should have thrown NPE");
        }
 catch (        NullPointerException e) {
        }
        assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(allPath).getPath().toString());
        assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(allPathFile).getPath().toString());
        try {
          userAdmin.getEncryptionZoneForPath(superPathFile);
          fail("expected AccessControlException");
        }
 catch (        AccessControlException e) {
          assertExceptionContains("Permission denied:",e);
        }
        assertNull("expected null for nonexistent path",userAdmin.getEncryptionZoneForPath(nonexistent));
        assertNull("expected null for non-ez path",userAdmin.getEncryptionZoneForPath(nonEZDir));
        assertNull("expected null for non-ez path",userAdmin.getEncryptionZoneForPath(nonEZFile));
        String snapshottedAllPath=newSnap.toString() + allPath.toString();
        assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(new Path(snapshottedAllPath)).getPath().toString());
        fs.delete(allPathFile,false);
        assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(new Path(snapshottedAllPath)).getPath().toString());
        fs.delete(allPath,true);
        assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(new Path(snapshottedAllPath)).getPath().toString());
        assertNull("expected null for deleted file path",userAdmin.getEncryptionZoneForPath(allPathFile));
        assertNull("expected null for deleted directory path",userAdmin.getEncryptionZoneForPath(allPath));
        return null;
      }
    }
);
  }
  /** 
 * Test success of Rename EZ on a directory which is already an EZ.
 */
  private void doRenameEncryptionZone(  FSTestWrapper wrapper) throws Exception {
    final Path testRoot=new Path("/tmp/TestEncryptionZones");
    final Path pathFoo=new Path(testRoot,"foo");
    final Path pathFooBaz=new Path(pathFoo,"baz");
    final Path pathFooBazFile=new Path(pathFooBaz,"file");
    final Path pathFooBar=new Path(pathFoo,"bar");
    final Path pathFooBarFile=new Path(pathFooBar,"file");
    final int len=8192;
    wrapper.mkdir(pathFoo,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(pathFoo,TEST_KEY,NO_TRASH);
    wrapper.mkdir(pathFooBaz,FsPermission.getDirDefault(),true);
    DFSTestUtil.createFile(fs,pathFooBazFile,len,(short)1,0xFEED);
    String contents=DFSTestUtil.readFile(fs,pathFooBazFile);
    try {
      wrapper.rename(pathFooBaz,testRoot);
    }
 catch (    IOException e) {
      assertExceptionContains(pathFooBaz.toString() + " can't be moved from" + " an encryption zone.",e);
    }
    assertTrue(fs.rename(pathFooBaz,pathFooBar));
    assertTrue("Rename of dir and file within ez failed",!wrapper.exists(pathFooBaz) && wrapper.exists(pathFooBar));
    assertEquals("Renamed file contents not the same",contents,DFSTestUtil.readFile(fs,pathFooBarFile));
    final Path newFoo=new Path(testRoot,"newfoo");
    assertTrue("Rename of EZ root",fs.rename(pathFoo,newFoo));
    assertTrue("Rename of EZ root failed",!wrapper.exists(pathFoo) && wrapper.exists(newFoo));
    try {
      wrapper.rename(newFoo,newFoo);
    }
 catch (    IOException e) {
      assertExceptionContains("are the same",e);
    }
  }
  @Test public void testRenameFileSystem() throws Exception {
    doRenameEncryptionZone(fsWrapper);
  }
  @Test public void testRenameFileContext() throws Exception {
    doRenameEncryptionZone(fcWrapper);
  }
  private FileEncryptionInfo getFileEncryptionInfo(  Path path) throws Exception {
    LocatedBlocks blocks=fs.getClient().getLocatedBlocks(path.toString(),0);
    return blocks.getFileEncryptionInfo();
  }
  @Test public void testReadWrite() throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    final Path baseFile=new Path("/base");
    final int len=8192;
    DFSTestUtil.createFile(fs,baseFile,len,(short)1,0xFEED);
    final Path zone=new Path("/zone");
    fs.mkdirs(zone);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    final Path encFile1=new Path(zone,"myfile");
    DFSTestUtil.createFile(fs,encFile1,len,(short)1,0xFEED);
    verifyFilesEqual(fs,baseFile,encFile1,len);
    assertNumZones(1);
    String keyName=dfsAdmin.listEncryptionZones().next().getKeyName();
    cluster.getNamesystem().getProvider().rollNewVersion(keyName);
    cluster.getNamesystem().getProvider().invalidateCache(keyName);
    verifyFilesEqual(fs,baseFile,encFile1,len);
    final Path encFile2=new Path(zone,"myfile2");
    DFSTestUtil.createFile(fs,encFile2,len,(short)1,0xFEED);
    FileEncryptionInfo feInfo1=getFileEncryptionInfo(encFile1);
    FileEncryptionInfo feInfo2=getFileEncryptionInfo(encFile2);
    assertFalse("EDEKs should be different",Arrays.equals(feInfo1.getEncryptedDataEncryptionKey(),feInfo2.getEncryptedDataEncryptionKey()));
    assertNotEquals("Key was rolled, versions should be different",feInfo1.getEzKeyVersionName(),feInfo2.getEzKeyVersionName());
    verifyFilesEqual(fs,encFile1,encFile2,len);
  }
  @Test public void testReadWriteUsingWebHdfs() throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    final FileSystem webHdfsFs=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsConstants.WEBHDFS_SCHEME);
    final Path zone=new Path("/zone");
    fs.mkdirs(zone);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    final Path unencFile=new Path("/unenc");
    final int len=8192;
    DFSTestUtil.createFile(webHdfsFs,unencFile,len,(short)1,0xFEED);
    final Path encFile1=new Path(zone,"myfile");
    DFSTestUtil.createFile(webHdfsFs,encFile1,len,(short)1,0xFEED);
    verifyFilesEqual(webHdfsFs,unencFile,encFile1,len);
    verifyFilesEqual(fs,unencFile,encFile1,len);
    final Path encFile2=new Path(zone,"myfile2");
    DFSTestUtil.createFile(fs,encFile2,len,(short)1,0xFEED);
    verifyFilesEqual(webHdfsFs,unencFile,encFile2,len);
    verifyFilesEqual(fs,unencFile,encFile2,len);
    appendOneByte(fs,unencFile);
    appendOneByte(webHdfsFs,encFile1);
    appendOneByte(fs,encFile2);
    verifyFilesEqual(webHdfsFs,unencFile,encFile1,len);
    verifyFilesEqual(fs,unencFile,encFile1,len);
    verifyFilesEqual(webHdfsFs,unencFile,encFile2,len);
    verifyFilesEqual(fs,unencFile,encFile2,len);
  }
  private void appendOneByte(  FileSystem fs,  Path p) throws IOException {
    final FSDataOutputStream out=fs.append(p);
    out.write((byte)0x123);
    out.close();
  }
  @Test public void testVersionAndSuiteNegotiation() throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    final Path zone=new Path("/zone");
    fs.mkdirs(zone);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,new Path(zone,"success1"),0,(short)1,0xFEED);
    DFSOutputStream.SUPPORTED_CRYPTO_VERSIONS=new CryptoProtocolVersion[]{};
    try {
      DFSTestUtil.createFile(fs,new Path(zone,"fail"),0,(short)1,0xFEED);
      fail("Created a file without specifying a crypto protocol version");
    }
 catch (    UnknownCryptoProtocolVersionException e) {
      assertExceptionContains("No crypto protocol versions",e);
    }
    DFSOutputStream.SUPPORTED_CRYPTO_VERSIONS=new CryptoProtocolVersion[]{CryptoProtocolVersion.UNKNOWN,CryptoProtocolVersion.UNKNOWN};
    try {
      DFSTestUtil.createFile(fs,new Path(zone,"fail"),0,(short)1,0xFEED);
      fail("Created a file without specifying a known crypto protocol version");
    }
 catch (    UnknownCryptoProtocolVersionException e) {
      assertExceptionContains("No crypto protocol versions",e);
    }
    DFSOutputStream.SUPPORTED_CRYPTO_VERSIONS=new CryptoProtocolVersion[]{CryptoProtocolVersion.UNKNOWN,CryptoProtocolVersion.UNKNOWN,CryptoProtocolVersion.ENCRYPTION_ZONES};
    DFSTestUtil.createFile(fs,new Path(zone,"success2"),0,(short)1,0xFEED);
    DFSOutputStream.SUPPORTED_CRYPTO_VERSIONS=new CryptoProtocolVersion[]{CryptoProtocolVersion.ENCRYPTION_ZONES,CryptoProtocolVersion.UNKNOWN,CryptoProtocolVersion.UNKNOWN};
    DFSTestUtil.createFile(fs,new Path(zone,"success3"),4096,(short)1,0xFEED);
    cluster.getNamesystem().getProvider().flush();
    KeyProvider provider=KeyProviderFactory.get(new URI(conf.getTrimmed(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH)),conf);
    List<String> keys=provider.getKeys();
    assertEquals("Expected NN to have created one key per zone",1,keys.size());
    List<KeyProvider.KeyVersion> allVersions=Lists.newArrayList();
    for (    String key : keys) {
      List<KeyProvider.KeyVersion> versions=provider.getKeyVersions(key);
      assertEquals("Should only have one key version per key",1,versions.size());
      allVersions.addAll(versions);
    }
    for (int i=2; i <= 3; i++) {
      FileEncryptionInfo feInfo=getFileEncryptionInfo(new Path(zone.toString() + "/success" + i));
      assertEquals(feInfo.getCipherSuite(),CipherSuite.AES_CTR_NOPADDING);
    }
    DFSClient old=fs.dfs;
    try {
      testCipherSuiteNegotiation(fs,conf);
    }
  finally {
      fs.dfs=old;
    }
  }
  @SuppressWarnings("unchecked") private static void mockCreate(  ClientProtocol mcp,  CipherSuite suite,  CryptoProtocolVersion version) throws Exception {
    Mockito.doReturn(new HdfsFileStatus.Builder().replication(1).blocksize(1024).perm(new FsPermission((short)777)).owner("owner").group("group").symlink(new byte[0]).path(new byte[0]).fileId(1010).feInfo(new FileEncryptionInfo(suite,version,new byte[suite.getAlgorithmBlockSize()],new byte[suite.getAlgorithmBlockSize()],"fakeKey","fakeVersion")).build()).when(mcp).create(anyString(),(FsPermission)anyObject(),anyString(),(EnumSetWritable<CreateFlag>)anyObject(),anyBoolean(),anyShort(),anyLong(),(CryptoProtocolVersion[])anyObject(),anyObject());
  }
  private static void testCipherSuiteNegotiation(  DistributedFileSystem fs,  Configuration conf) throws Exception {
    final ClientProtocol mcp=Mockito.mock(ClientProtocol.class);
    final Configuration noCodecConf=new Configuration(conf);
    final CipherSuite suite=CipherSuite.AES_CTR_NOPADDING;
    final String confKey=CommonConfigurationKeysPublic.HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX + suite.getConfigSuffix();
    noCodecConf.set(confKey,"");
    fs.dfs=new DFSClient(null,mcp,noCodecConf,null);
    mockCreate(mcp,suite,CryptoProtocolVersion.ENCRYPTION_ZONES);
    try {
      fs.create(new Path("/mock"));
      fail("Created with no configured codecs!");
    }
 catch (    UnknownCipherSuiteException e) {
      assertExceptionContains("No configuration found for the cipher",e);
    }
    fs.dfs=new DFSClient(null,mcp,conf,null);
    CipherSuite unknown=CipherSuite.UNKNOWN;
    unknown.setUnknownValue(989);
    mockCreate(mcp,unknown,CryptoProtocolVersion.ENCRYPTION_ZONES);
    try {
      fs.create(new Path("/mock"));
      fail("Created with unknown cipher!");
    }
 catch (    IOException e) {
      assertExceptionContains("unknown CipherSuite with ID 989",e);
    }
  }
  @Test public void testCreateEZWithNoProvider() throws Exception {
    final Configuration clusterConf=cluster.getConfiguration(0);
    clusterConf.unset(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH);
    cluster.restartNameNode(true);
    final Path zone1=new Path("/zone1");
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    try {
      dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
      fail("expected exception");
    }
 catch (    IOException e) {
      assertExceptionContains("since no key provider is available",e);
    }
    final Path jksPath=new Path(testRootDir.toString(),"test.jks");
    clusterConf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,JavaKeyStoreProvider.SCHEME_NAME + "://file" + jksPath.toUri());
    assertNumZones(0);
  }
  @Test public void testIsEncryptedMethod() throws Exception {
    doTestIsEncryptedMethod(new Path("/"));
    doTestIsEncryptedMethod(new Path("/.reserved/raw"));
  }
  private void doTestIsEncryptedMethod(  Path prefix) throws Exception {
    try {
      dTIEM(prefix);
    }
  finally {
      for (      FileStatus s : fsWrapper.listStatus(prefix)) {
        fsWrapper.delete(s.getPath(),true);
      }
    }
  }
  private void dTIEM(  Path prefix) throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    final Path baseFile=new Path(prefix,"base");
    fsWrapper.createFile(baseFile);
    FileStatus stat=fsWrapper.getFileStatus(baseFile);
    assertFalse("Expected isEncrypted to return false for " + baseFile,stat.isEncrypted());
    final Path zone=new Path(prefix,"zone");
    fsWrapper.mkdir(zone,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    final Path encFile=new Path(zone,"encfile");
    fsWrapper.createFile(encFile);
    stat=fsWrapper.getFileStatus(encFile);
    assertTrue("Expected isEncrypted to return true for enc file" + encFile,stat.isEncrypted());
    stat=fsWrapper.getFileStatus(zone);
    assertTrue("Expected isEncrypted to return true for ezroot",stat.isEncrypted());
    final Path zoneSubdir=new Path(zone,"subdir");
    fsWrapper.mkdir(zoneSubdir,FsPermission.getDirDefault(),true);
    stat=fsWrapper.getFileStatus(zoneSubdir);
    assertTrue("Expected isEncrypted to return true for ez subdir " + zoneSubdir,stat.isEncrypted());
    final Path nonEzDirPath=new Path(prefix,"nonzone");
    fsWrapper.mkdir(nonEzDirPath,FsPermission.getDirDefault(),true);
    stat=fsWrapper.getFileStatus(nonEzDirPath);
    assertFalse("Expected isEncrypted to return false for directory " + nonEzDirPath,stat.isEncrypted());
    FileStatus[] statuses=fsWrapper.listStatus(zone);
    for (    FileStatus s : statuses) {
      assertTrue("Expected isEncrypted to return true for ez stat " + zone,s.isEncrypted());
    }
    statuses=fsWrapper.listStatus(encFile);
    for (    FileStatus s : statuses) {
      assertTrue("Expected isEncrypted to return true for ez file stat " + encFile,s.isEncrypted());
    }
    statuses=fsWrapper.listStatus(nonEzDirPath);
    for (    FileStatus s : statuses) {
      assertFalse("Expected isEncrypted to return false for nonez stat " + nonEzDirPath,s.isEncrypted());
    }
    statuses=fsWrapper.listStatus(baseFile);
    for (    FileStatus s : statuses) {
      assertFalse("Expected isEncrypted to return false for non ez stat " + baseFile,s.isEncrypted());
    }
  }
private class AuthorizationExceptionInjector extends EncryptionFaultInjector {
    @Override public void ensureKeyIsInitialized() throws IOException {
      throw new AuthorizationException(AUTHORIZATION_EXCEPTION_MESSAGE);
    }
  }
  @Test public void testExceptionInformationReturn(){
    final Path zone1=new Path("/zone1");
    EncryptionFaultInjector.instance=new AuthorizationExceptionInjector();
    try {
      dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
      fail("exception information can be returned when creating " + "transparent encryption zone");
    }
 catch (    IOException e) {
      assertTrue(e instanceof RemoteException);
      assertTrue(((RemoteException)e).unwrapRemoteException() instanceof AuthorizationException);
      assertExceptionContains(AUTHORIZATION_EXCEPTION_MESSAGE,e);
    }
  }
private class MyInjector extends EncryptionFaultInjector {
    volatile int generateCount;
    CountDownLatch ready;
    CountDownLatch wait;
    public MyInjector(){
      this.ready=new CountDownLatch(1);
      this.wait=new CountDownLatch(1);
    }
    @Override public void startFileNoKey() throws IOException {
      generateCount=-1;
      syncWithLatches();
    }
    @Override public void startFileBeforeGenerateKey() throws IOException {
      syncWithLatches();
    }
    private void syncWithLatches() throws IOException {
      ready.countDown();
      try {
        wait.await();
      }
 catch (      InterruptedException e) {
        throw new IOException(e);
      }
    }
    @Override public void startFileAfterGenerateKey() throws IOException {
      generateCount++;
    }
  }
private class CreateFileTask implements Callable<Void> {
    private FileSystemTestWrapper fsWrapper;
    private Path name;
    CreateFileTask(    FileSystemTestWrapper fsWrapper,    Path name){
      this.fsWrapper=fsWrapper;
      this.name=name;
    }
    @Override public Void call() throws Exception {
      fsWrapper.createFile(name);
      return null;
    }
  }
private class InjectFaultTask implements Callable<Void> {
    final Path zone1=new Path("/zone1");
    final Path file=new Path(zone1,"file1");
    final ExecutorService executor=Executors.newSingleThreadExecutor();
    MyInjector injector;
    @Override public Void call() throws Exception {
      injector=new MyInjector();
      EncryptionFaultInjector.instance=injector;
      Future<Void> future=executor.submit(new CreateFileTask(fsWrapper,file));
      injector.ready.await();
      try {
        doFault();
      }
  finally {
        injector.wait.countDown();
      }
      future.get();
      doCleanup();
      return null;
    }
    public void doFault() throws Exception {
    }
    public void doCleanup() throws Exception {
    }
  }
  /** 
 * Tests the retry logic in startFile. We release the lock while generating an EDEK, so tricky things can happen in the intervening time.
 */
  @Test public void testStartFileRetry() throws Exception {
    final Path zone1=new Path("/zone1");
    final Path file=new Path(zone1,"file1");
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    ExecutorService executor=Executors.newSingleThreadExecutor();
    executor.submit(new InjectFaultTask(){
      @Override public void doCleanup() throws Exception {
        assertEquals("Expected no startFile key generation",-1,injector.generateCount);
        fsWrapper.delete(file,false);
      }
    }
).get();
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
    executor.submit(new InjectFaultTask(){
      @Override public void doFault() throws Exception {
        fsWrapper.delete(zone1,true);
      }
      @Override public void doCleanup() throws Exception {
        assertEquals("Expected no startFile retries",1,injector.generateCount);
        fsWrapper.delete(file,false);
      }
    }
).get();
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    final String otherKey="other_key";
    DFSTestUtil.createKey(otherKey,cluster,conf);
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
    executor.submit(new InjectFaultTask(){
      @Override public void doFault() throws Exception {
        fsWrapper.delete(zone1,true);
        fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
        dfsAdmin.createEncryptionZone(zone1,otherKey,NO_TRASH);
      }
      @Override public void doCleanup() throws Exception {
        assertEquals("Expected a startFile retry",2,injector.generateCount);
        fsWrapper.delete(zone1,true);
      }
    }
).get();
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    final String anotherKey="another_key";
    DFSTestUtil.createKey(anotherKey,cluster,conf);
    dfsAdmin.createEncryptionZone(zone1,anotherKey,NO_TRASH);
    String keyToUse=otherKey;
    MyInjector injector=new MyInjector();
    EncryptionFaultInjector.instance=injector;
    Future<?> future=executor.submit(new CreateFileTask(fsWrapper,file));
    for (int i=0; i < DFSOutputStream.CREATE_RETRY_COUNT + 1; i++) {
      injector.ready.await();
      fsWrapper.delete(zone1,true);
      fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
      dfsAdmin.createEncryptionZone(zone1,keyToUse,NO_TRASH);
      if (keyToUse == otherKey) {
        keyToUse=anotherKey;
      }
 else {
        keyToUse=otherKey;
      }
      injector.wait.countDown();
      injector=new MyInjector();
      EncryptionFaultInjector.instance=injector;
    }
    try {
      future.get();
      fail("Expected exception from too many retries");
    }
 catch (    ExecutionException e) {
      assertExceptionContains("Too many retries because of encryption zone operations",e.getCause());
    }
  }
  /** 
 * Tests obtaining delegation token from stored key
 */
  @Test public void testDelegationToken() throws Exception {
    UserGroupInformation.createRemoteUser("JobTracker");
    DistributedFileSystem dfs=cluster.getFileSystem();
    KeyProvider keyProvider=Mockito.mock(KeyProvider.class,withSettings().extraInterfaces(DelegationTokenExtension.class,CryptoExtension.class));
    Mockito.when(keyProvider.getConf()).thenReturn(conf);
    byte[] testIdentifier="Test identifier for delegation token".getBytes();
    @SuppressWarnings("rawtypes") Token testToken=new Token(testIdentifier,new byte[0],new Text(),new Text());
    Mockito.when(((DelegationTokenIssuer)keyProvider).getCanonicalServiceName()).thenReturn("service");
    Mockito.when(((DelegationTokenIssuer)keyProvider).getDelegationToken(anyString())).thenReturn(testToken);
    dfs.getClient().setKeyProvider(keyProvider);
    Credentials creds=new Credentials();
    final Token<?> tokens[]=dfs.addDelegationTokens("JobTracker",creds);
    DistributedFileSystem.LOG.debug("Delegation tokens: " + Arrays.asList(tokens));
    Assert.assertEquals(2,tokens.length);
    Assert.assertEquals(tokens[1],testToken);
    Assert.assertEquals(2,creds.numberOfTokens());
  }
  /** 
 * Test running fsck on a system with encryption zones.
 */
  @Test public void testFsckOnEncryptionZones() throws Exception {
    final int len=8196;
    final Path zoneParent=new Path("/zones");
    final Path zone1=new Path(zoneParent,"zone1");
    final Path zone1File=new Path(zone1,"file");
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,zone1File,len,(short)1,0xFEED);
    ByteArrayOutputStream bStream=new ByteArrayOutputStream();
    PrintStream out=new PrintStream(bStream,true);
    int errCode=ToolRunner.run(new DFSck(conf,out),new String[]{"/"});
    assertEquals("Fsck ran with non-zero error code",0,errCode);
    String result=bStream.toString();
    assertTrue("Fsck did not return HEALTHY status",result.contains(NamenodeFsck.HEALTHY_STATUS));
    errCode=ToolRunner.run(new DFSck(conf,out),new String[]{zoneParent.toString()});
    assertEquals("Fsck ran with non-zero error code",0,errCode);
    result=bStream.toString();
    assertTrue("Fsck did not return HEALTHY status",result.contains(NamenodeFsck.HEALTHY_STATUS));
  }
  /** 
 * Test correctness of successive snapshot creation and deletion on a system with encryption zones.
 */
  @Test public void testSnapshotsOnEncryptionZones() throws Exception {
    final String TEST_KEY2="testkey2";
    DFSTestUtil.createKey(TEST_KEY2,cluster,conf);
    final int len=8196;
    final Path zoneParent=new Path("/zones");
    final Path zone=new Path(zoneParent,"zone");
    final Path zoneFile=new Path(zone,"zoneFile");
    fsWrapper.mkdir(zone,FsPermission.getDirDefault(),true);
    dfsAdmin.allowSnapshot(zoneParent);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,zoneFile,len,(short)1,0xFEED);
    String contents=DFSTestUtil.readFile(fs,zoneFile);
    final Path snap1=fs.createSnapshot(zoneParent,"snap1");
    final Path snap1Zone=new Path(snap1,zone.getName());
    assertEquals("Got unexpected ez path",zone.toString(),dfsAdmin.getEncryptionZoneForPath(snap1Zone).getPath().toString());
    fsWrapper.delete(zone,true);
    fsWrapper.mkdir(zone,FsPermission.getDirDefault(),true);
    final Path snap2=fs.createSnapshot(zoneParent,"snap2");
    final Path snap2Zone=new Path(snap2,zone.getName());
    assertEquals("Got unexpected ez path",zone.toString(),dfsAdmin.getEncryptionZoneForPath(snap1Zone).getPath().toString());
    assertNull("Expected null ez path",dfsAdmin.getEncryptionZoneForPath(snap2Zone));
    dfsAdmin.createEncryptionZone(zone,TEST_KEY2,NO_TRASH);
    EncryptionZone ezSnap1=dfsAdmin.getEncryptionZoneForPath(snap1Zone);
    assertEquals("Got unexpected ez path",zone.toString(),ezSnap1.getPath().toString());
    assertEquals("Unexpected ez key",TEST_KEY,ezSnap1.getKeyName());
    assertNull("Expected null ez path",dfsAdmin.getEncryptionZoneForPath(snap2Zone));
    final Path snap3=fs.createSnapshot(zoneParent,"snap3");
    final Path snap3Zone=new Path(snap3,zone.getName());
    EncryptionZone ezSnap3=dfsAdmin.getEncryptionZoneForPath(snap3Zone);
    assertEquals("Got unexpected ez path",zone.toString(),ezSnap3.getPath().toString());
    assertEquals("Unexpected ez key",TEST_KEY2,ezSnap3.getKeyName());
    ezSnap1=dfsAdmin.getEncryptionZoneForPath(snap1Zone);
    assertEquals("Got unexpected ez path",zone.toString(),ezSnap1.getPath().toString());
    assertEquals("Unexpected ez key",TEST_KEY,ezSnap1.getKeyName());
    assertNull("Expected null ez path",dfsAdmin.getEncryptionZoneForPath(snap2Zone));
    ArrayList<EncryptionZone> listZones=Lists.newArrayList();
    RemoteIterator<EncryptionZone> it=dfsAdmin.listEncryptionZones();
    while (it.hasNext()) {
      listZones.add(it.next());
    }
    for (    EncryptionZone z : listZones) {
      System.out.println(z);
    }
    assertEquals("Did not expect additional encryption zones!",1,listZones.size());
    EncryptionZone listZone=listZones.get(0);
    assertEquals("Got unexpected ez path",zone.toString(),listZone.getPath().toString());
    assertEquals("Unexpected ez key",TEST_KEY2,listZone.getKeyName());
    final Path snapshottedZoneFile=new Path(snap1.toString() + "/" + zone.getName()+ "/"+ zoneFile.getName());
    assertEquals("Contents of snapshotted file have changed unexpectedly",contents,DFSTestUtil.readFile(fs,snapshottedZoneFile));
    fs.deleteSnapshot(zoneParent,snap2.getName());
    assertEquals("Got unexpected ez path",zone.toString(),dfsAdmin.getEncryptionZoneForPath(snap1Zone).getPath().toString());
    assertEquals("Got unexpected ez path",zone.toString(),dfsAdmin.getEncryptionZoneForPath(snap3Zone).getPath().toString());
    fs.deleteSnapshot(zoneParent,snap1.getName());
    assertEquals("Got unexpected ez path",zone.toString(),dfsAdmin.getEncryptionZoneForPath(snap3Zone).getPath().toString());
  }
  /** 
 * Test correctness of encryption zones on a existing snapshot path. Specifically, test the file in encryption zones with no encryption info
 */
  @Test public void testSnapshotWithFile() throws Exception {
    final int len=8196;
    final Path zoneParent=new Path("/zones");
    final Path zone=new Path(zoneParent,"zone");
    final Path zoneFile=new Path(zone,"zoneFile");
    fsWrapper.mkdir(zone,FsPermission.getDirDefault(),true);
    DFSTestUtil.createFile(fs,zoneFile,len,(short)1,0xFEED);
    String contents=DFSTestUtil.readFile(fs,zoneFile);
    dfsAdmin.allowSnapshot(zoneParent);
    final Path snap1=fs.createSnapshot(zoneParent,"snap1");
    fsWrapper.delete(zoneFile,false);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    assertEquals("Got unexpected ez path",zone.toString(),dfsAdmin.getEncryptionZoneForPath(zone).getPath());
    final Path snapshottedZoneFile=new Path(snap1 + "/" + zone.getName()+ "/"+ zoneFile.getName());
    FileEncryptionInfo feInfo=getFileEncryptionInfo(snapshottedZoneFile);
    assertNull("Expected null ez info",feInfo);
    assertEquals("Contents of snapshotted file have changed unexpectedly",contents,DFSTestUtil.readFile(fs,snapshottedZoneFile));
  }
  /** 
 * Check the correctness of the diff reports.
 */
  private void verifyDiffReport(  Path dir,  String from,  String to,  DiffReportEntry... entries) throws IOException {
    DFSTestUtil.verifySnapshotDiffReport(fs,dir,from,to,entries);
  }
  /** 
 * Test correctness of snapshotDiff for encryption zone. snapshtoDiff should work when the path parameter is prefixed with /.reserved/raw for path that's both snapshottable and encryption zone.
 */
  @Test public void testSnapshotDiffOnEncryptionZones() throws Exception {
    final String TEST_KEY2="testkey2";
    DFSTestUtil.createKey(TEST_KEY2,cluster,conf);
    final int len=8196;
    final Path zone=new Path("/zone");
    final Path rawZone=new Path("/.reserved/raw/zone");
    final Path zoneFile=new Path(zone,"zoneFile");
    fsWrapper.mkdir(zone,FsPermission.getDirDefault(),true);
    dfsAdmin.allowSnapshot(zone);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,zoneFile,len,(short)1,0xFEED);
    fs.createSnapshot(zone,"snap1");
    fsWrapper.delete(zoneFile,true);
    fs.createSnapshot(zone,"snap2");
    verifyDiffReport(zone,"snap1","snap2",new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("zoneFile")));
    verifyDiffReport(rawZone,"snap1","snap2",new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("zoneFile")));
  }
  /** 
 * Verify symlinks can be created in encryption zones and that they function properly when the target is in the same or different ez.
 */
  @Test public void testEncryptionZonesWithSymlinks() throws Exception {
    final int len=8192;
    final Path parent=new Path("/parent");
    final Path linkParent=new Path(parent,"symdir1");
    final Path targetParent=new Path(parent,"symdir2");
    final Path link=new Path(linkParent,"link");
    final Path target=new Path(targetParent,"target");
    fs.mkdirs(parent);
    dfsAdmin.createEncryptionZone(parent,TEST_KEY,NO_TRASH);
    fs.mkdirs(linkParent);
    fs.mkdirs(targetParent);
    DFSTestUtil.createFile(fs,target,len,(short)1,0xFEED);
    String content=DFSTestUtil.readFile(fs,target);
    fs.createSymlink(target,link,false);
    assertEquals("Contents read from link are not the same as target",content,DFSTestUtil.readFile(fs,link));
    fs.delete(parent,true);
    fs.mkdirs(linkParent);
    fs.mkdirs(targetParent);
    dfsAdmin.createEncryptionZone(linkParent,TEST_KEY,NO_TRASH);
    dfsAdmin.createEncryptionZone(targetParent,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,target,len,(short)1,0xFEED);
    content=DFSTestUtil.readFile(fs,target);
    fs.createSymlink(target,link,false);
    assertEquals("Contents read from link are not the same as target",content,DFSTestUtil.readFile(fs,link));
    fs.delete(link,true);
    fs.delete(target,true);
  }
  @Test public void testConcatFailsInEncryptionZones() throws Exception {
    final int len=8192;
    final Path ez=new Path("/ez");
    fs.mkdirs(ez);
    dfsAdmin.createEncryptionZone(ez,TEST_KEY,NO_TRASH);
    final Path src1=new Path(ez,"src1");
    final Path src2=new Path(ez,"src2");
    final Path target=new Path(ez,"target");
    DFSTestUtil.createFile(fs,src1,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,src2,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,target,len,(short)1,0xFEED);
    try {
      fs.concat(target,new Path[]{src1,src2});
      fail("expected concat to throw en exception for files in an ez");
    }
 catch (    IOException e) {
      assertExceptionContains("concat can not be called for files in an encryption zone",e);
    }
    fs.delete(ez,true);
  }
  /** 
 * Test running the OfflineImageViewer on a system with encryption zones.
 */
  @Test public void testOfflineImageViewerOnEncryptionZones() throws Exception {
    final int len=8196;
    final Path zoneParent=new Path("/zones");
    final Path zone1=new Path(zoneParent,"zone1");
    final Path zone1File=new Path(zone1,"file");
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,zone1File,len,(short)1,0xFEED);
    fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER,false);
    fs.saveNamespace();
    File originalFsimage=FSImageTestUtil.findLatestImageFile(FSImageTestUtil.getFSImage(cluster.getNameNode()).getStorage().getStorageDir(0));
    if (originalFsimage == null) {
      throw new RuntimeException("Didn't generate or can't find fsimage");
    }
    ByteArrayOutputStream output=new ByteArrayOutputStream();
    PrintStream pw=new PrintStream(output);
    PBImageXmlWriter v=new PBImageXmlWriter(new Configuration(),pw);
    v.visit(new RandomAccessFile(originalFsimage,"r"));
    final String xml=output.toString();
    SAXParser parser=SAXParserFactory.newInstance().newSAXParser();
    parser.parse(new InputSource(new StringReader(xml)),new DefaultHandler());
  }
  /** 
 * Test creating encryption zone on the root path
 */
  @Test public void testEncryptionZonesOnRootPath() throws Exception {
    final int len=8196;
    final Path rootDir=new Path("/");
    final Path zoneFile=new Path(rootDir,"file");
    final Path rawFile=new Path("/.reserved/raw/file");
    dfsAdmin.createEncryptionZone(rootDir,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,zoneFile,len,(short)1,0xFEED);
    assertEquals("File can be created on the root encryption zone " + "with correct length",len,fs.getFileStatus(zoneFile).getLen());
    assertEquals("Root dir is encrypted",true,fs.getFileStatus(rootDir).isEncrypted());
    assertEquals("File is encrypted",true,fs.getFileStatus(zoneFile).isEncrypted());
    DFSTestUtil.verifyFilesNotEqual(fs,zoneFile,rawFile,len);
  }
  @Test public void testEncryptionZonesOnRelativePath() throws Exception {
    final int len=8196;
    final Path baseDir=new Path("/somewhere/base");
    final Path zoneDir=new Path("zone");
    final Path zoneFile=new Path("file");
    fs.setWorkingDirectory(baseDir);
    fs.mkdirs(zoneDir);
    dfsAdmin.createEncryptionZone(zoneDir,TEST_KEY,NO_TRASH);
    DFSTestUtil.createFile(fs,zoneFile,len,(short)1,0xFEED);
    assertNumZones(1);
    assertZonePresent(TEST_KEY,"/somewhere/base/zone");
    assertEquals("Got unexpected ez path","/somewhere/base/zone",dfsAdmin.getEncryptionZoneForPath(zoneDir).getPath().toString());
  }
  @Test public void testGetEncryptionZoneOnANonExistentPaths() throws Exception {
    final Path ezPath=new Path("/ez");
    fs.mkdirs(ezPath);
    dfsAdmin.createEncryptionZone(ezPath,TEST_KEY,NO_TRASH);
    Path zoneFile=new Path(ezPath,"file");
    EncryptionZone ez=fs.getEZForPath(zoneFile);
    assertNotNull("Expected EZ for non-existent path in EZ",ez);
    ez=dfsAdmin.getEncryptionZoneForPath(zoneFile);
    assertNotNull("Expected EZ for non-existent path in EZ",ez);
    ez=dfsAdmin.getEncryptionZoneForPath(new Path("/does/not/exist"));
    assertNull("Expected null for non-existent path not in EZ",ez);
  }
  @Test public void testEncryptionZoneWithTrash() throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    final Path zone1=new Path("/zone1");
    fs.mkdirs(zone1);
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY,NO_TRASH);
    final Path encFile1=new Path(zone1,"encFile1");
    final int len=8192;
    DFSTestUtil.createFile(fs,encFile1,len,(short)1,0xFEED);
    Configuration clientConf=new Configuration(conf);
    clientConf.setLong(FS_TRASH_INTERVAL_KEY,1);
    FsShell shell=new FsShell(clientConf);
    verifyShellDeleteWithTrash(shell,encFile1);
    verifyShellDeleteWithTrash(shell,zone1);
    final Path topEZ=new Path("/topEZ");
    fs.mkdirs(topEZ);
    dfsAdmin.createEncryptionZone(topEZ,TEST_KEY,NO_TRASH);
    final String NESTED_EZ_TEST_KEY="nested_ez_test_key";
    DFSTestUtil.createKey(NESTED_EZ_TEST_KEY,cluster,conf);
    final Path nestedEZ=new Path(topEZ,"nestedEZ");
    fs.mkdirs(nestedEZ);
    dfsAdmin.createEncryptionZone(nestedEZ,NESTED_EZ_TEST_KEY,NO_TRASH);
    final Path topEZFile=new Path(topEZ,"file");
    final Path nestedEZFile=new Path(nestedEZ,"file");
    DFSTestUtil.createFile(fs,topEZFile,len,(short)1,0xFEED);
    DFSTestUtil.createFile(fs,nestedEZFile,len,(short)1,0xFEED);
    verifyShellDeleteWithTrash(shell,topEZFile);
    verifyShellDeleteWithTrash(shell,nestedEZFile);
    final WebHdfsFileSystem webFS=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsConstants.WEBHDFS_SCHEME);
    final String currentUser=UserGroupInformation.getCurrentUser().getShortUserName();
    final Path expectedTopTrash=new Path(topEZ,new Path(FileSystem.TRASH_PREFIX,currentUser));
    final Path expectedNestedTrash=new Path(nestedEZ,new Path(FileSystem.TRASH_PREFIX,currentUser));
    final Path topTrash=webFS.getTrashRoot(topEZFile);
    final Path nestedTrash=webFS.getTrashRoot(nestedEZFile);
    assertEquals(expectedTopTrash.toUri().getPath(),topTrash.toUri().getPath());
    assertEquals(expectedNestedTrash.toUri().getPath(),nestedTrash.toUri().getPath());
    verifyShellDeleteWithTrash(shell,nestedEZ);
    verifyShellDeleteWithTrash(shell,topEZ);
  }
  @Test public void testRootDirEZTrash() throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    final String currentUser=UserGroupInformation.getCurrentUser().getShortUserName();
    final Path rootDir=new Path("/");
    dfsAdmin.createEncryptionZone(rootDir,TEST_KEY,NO_TRASH);
    final Path encFile=new Path("/encFile");
    final int len=8192;
    DFSTestUtil.createFile(fs,encFile,len,(short)1,0xFEED);
    Configuration clientConf=new Configuration(conf);
    clientConf.setLong(FS_TRASH_INTERVAL_KEY,1);
    FsShell shell=new FsShell(clientConf);
    verifyShellDeleteWithTrash(shell,encFile);
    Path encFileCurrentTrash=shell.getCurrentTrashDir(encFile);
    Path rootDirCurrentTrash=shell.getCurrentTrashDir(rootDir);
    assertEquals("Root trash should be equal with ezFile trash",encFileCurrentTrash,rootDirCurrentTrash);
    final WebHdfsFileSystem webFS=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsConstants.WEBHDFS_SCHEME);
    final Path expectedTrash=new Path(rootDir,new Path(FileSystem.TRASH_PREFIX,currentUser));
    Path webHDFSTrash=webFS.getTrashRoot(encFile);
    assertEquals(expectedTrash.toUri().getPath(),webHDFSTrash.toUri().getPath());
    assertEquals(encFileCurrentTrash.getParent().toUri().getPath(),webHDFSTrash.toUri().getPath());
  }
  @Test public void testGetTrashRoots() throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    Path ezRoot1=new Path("/ez1");
    fs.mkdirs(ezRoot1);
    dfsAdmin.createEncryptionZone(ezRoot1,TEST_KEY,NO_TRASH);
    Path ezRoot2=new Path("/ez2");
    fs.mkdirs(ezRoot2);
    dfsAdmin.createEncryptionZone(ezRoot2,TEST_KEY,NO_TRASH);
    Path ezRoot3=new Path("/ez3");
    fs.mkdirs(ezRoot3);
    dfsAdmin.createEncryptionZone(ezRoot3,TEST_KEY,NO_TRASH);
    Collection<FileStatus> trashRootsBegin=fs.getTrashRoots(true);
    assertEquals("Unexpected getTrashRoots result",0,trashRootsBegin.size());
    final Path encFile=new Path(ezRoot2,"encFile");
    final int len=8192;
    DFSTestUtil.createFile(fs,encFile,len,(short)1,0xFEED);
    Configuration clientConf=new Configuration(conf);
    clientConf.setLong(FS_TRASH_INTERVAL_KEY,1);
    FsShell shell=new FsShell(clientConf);
    verifyShellDeleteWithTrash(shell,encFile);
    Collection<FileStatus> trashRootsDelete1=fs.getTrashRoots(true);
    assertEquals("Unexpected getTrashRoots result",1,trashRootsDelete1.size());
    final Path nonEncFile=new Path("/nonEncFile");
    DFSTestUtil.createFile(fs,nonEncFile,len,(short)1,0xFEED);
    verifyShellDeleteWithTrash(shell,nonEncFile);
    Collection<FileStatus> trashRootsDelete2=fs.getTrashRoots(true);
    assertEquals("Unexpected getTrashRoots result",2,trashRootsDelete2.size());
  }
  private void verifyShellDeleteWithTrash(  FsShell shell,  Path path) throws Exception {
    try {
      Path trashDir=shell.getCurrentTrashDir(path);
      Path checkTrash=trashDir;
      while (!checkTrash.isRoot() && !checkTrash.getName().equals(".Trash")) {
        checkTrash=checkTrash.getParent();
      }
      assertEquals("No .Trash component found in trash dir " + trashDir,".Trash",checkTrash.getName());
      final Path trashFile=new Path(shell.getCurrentTrashDir(path) + "/" + path);
      String[] argv=new String[]{"-rm","-r",path.toString()};
      int res=ToolRunner.run(shell,argv);
      assertEquals("rm failed",0,res);
      assertTrue("File not in trash : " + trashFile,fs.exists(trashFile));
    }
 catch (    IOException ioe) {
      fail(ioe.getMessage());
    }
 finally {
      if (fs.exists(path)) {
        fs.delete(path,true);
      }
    }
  }
  /** 
 * This test tests that client will first lookup secrets map for key provider uri from  {@link Credentials} in{@link UserGroupInformation}
 * @throws Exception
 */
  @Test public void testProviderUriInCredentials() throws Exception {
    String dummyKeyProvider="dummy://foo:bar@test_provider1";
    DFSClient client=cluster.getFileSystem().getClient();
    Credentials credentials=new Credentials();
    Text lookUpKey=HdfsKMSUtil.getKeyProviderMapKey(cluster.getFileSystem().getUri());
    credentials.addSecretKey(lookUpKey,DFSUtilClient.string2Bytes(dummyKeyProvider));
    client.ugi.addCredentials(credentials);
    Assert.assertEquals("Client Key provider is different from provider in " + "credentials map",dummyKeyProvider,client.getKeyProviderUri().toString());
  }
  /** 
 * Testing the fallback behavior of keyProviderUri. This test tests first the key provider uri is used from conf and then used from serverDefaults.
 * @throws IOException
 */
  @Test public void testKeyProviderFallBackBehavior() throws IOException {
    Configuration clusterConf=cluster.getConfiguration(0);
    String dummyKeyProviderUri1="dummy://foo:bar@test_provider1";
    clusterConf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,dummyKeyProviderUri1);
    DFSClient mockClient=Mockito.spy(cluster.getFileSystem().getClient());
    FsServerDefaults serverDefaultsWithKeyProviderNull=getTestServerDefaults(null);
    Mockito.doReturn(serverDefaultsWithKeyProviderNull).when(mockClient).getServerDefaults();
    Assert.assertEquals("Key provider uri from client doesn't match with uri from conf",dummyKeyProviderUri1,mockClient.getKeyProviderUri().toString());
    Mockito.verify(mockClient,Mockito.times(1)).getServerDefaults();
    String dummyKeyProviderUri2="dummy://foo:bar@test_provider2";
    FsServerDefaults serverDefaultsWithDummyKeyProvider=getTestServerDefaults(dummyKeyProviderUri2);
    Mockito.doReturn(serverDefaultsWithDummyKeyProvider).when(mockClient).getServerDefaults();
    Assert.assertEquals("Key provider uri from client doesn't match with uri from namenode",dummyKeyProviderUri2,mockClient.getKeyProviderUri().toString());
    Mockito.verify(mockClient,Mockito.times(2)).getServerDefaults();
  }
  /** 
 * This test makes sure the client gets the key provider uri from namenode instead of its own conf. This test assumes both the namenode and client are upgraded.
 * @throws Exception
 */
  @Test public void testDifferentKMSProviderOnUpgradedNamenode() throws Exception {
    Configuration clusterConf=cluster.getConfiguration(0);
    URI namenodeKeyProviderUri=URI.create(getKeyProviderURI());
    Assert.assertEquals("Key Provider for client and namenode are different",namenodeKeyProviderUri,cluster.getFileSystem().getClient().getKeyProviderUri());
    clusterConf.unset(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH);
    Assert.assertEquals("Key Provider for client and namenode are different",namenodeKeyProviderUri,cluster.getFileSystem().getClient().getKeyProviderUri());
    clusterConf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,"dummy://foo:bar@test_provider1");
    Assert.assertEquals("Key Provider for client and namenode are different",namenodeKeyProviderUri,cluster.getFileSystem().getClient().getKeyProviderUri());
  }
  /** 
 * This test makes sure the client trusts its local conf This test assumes the client is upgraded but the namenode is not.
 * @throws Exception
 */
  @Test public void testDifferentKMSProviderOnUnUpgradedNamenode() throws Exception {
    Configuration clusterConf=cluster.getConfiguration(0);
    URI namenodeKeyProviderUri=URI.create(getKeyProviderURI());
    URI clientKeyProviderUri=cluster.getFileSystem().getClient().getKeyProviderUri();
    Assert.assertNotNull(clientKeyProviderUri);
    Assert.assertEquals("Key Provider for client and namenode are different",namenodeKeyProviderUri,clientKeyProviderUri);
    String dummyKeyProviderUri="dummy://foo:bar@test_provider";
    clusterConf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH,dummyKeyProviderUri);
    FsServerDefaults spyServerDefaults=getTestServerDefaults(null);
    DFSClient spyClient=Mockito.spy(cluster.getFileSystem().getClient());
    Mockito.doReturn(spyServerDefaults).when(spyClient).getServerDefaults();
    clientKeyProviderUri=spyClient.getKeyProviderUri();
    Assert.assertEquals("Client keyProvider should be " + dummyKeyProviderUri,dummyKeyProviderUri,clientKeyProviderUri.toString());
    Mockito.verify(spyClient,Mockito.times(1)).getServerDefaults();
  }
  private FsServerDefaults getTestServerDefaults(  String providerPath){
    FsServerDefaults serverDefaults=new FsServerDefaults(conf.getLongBytes(DFS_BLOCK_SIZE_KEY,DFS_BLOCK_SIZE_DEFAULT),conf.getInt(DFS_BYTES_PER_CHECKSUM_KEY,DFS_BYTES_PER_CHECKSUM_DEFAULT),conf.getInt(DFS_CLIENT_WRITE_PACKET_SIZE_KEY,DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT),(short)conf.getInt(DFS_REPLICATION_KEY,DFS_REPLICATION_DEFAULT),conf.getInt(IO_FILE_BUFFER_SIZE_KEY,IO_FILE_BUFFER_SIZE_DEFAULT),conf.getBoolean(DFS_ENCRYPT_DATA_TRANSFER_KEY,DFS_ENCRYPT_DATA_TRANSFER_DEFAULT),conf.getLong(FS_TRASH_INTERVAL_KEY,FS_TRASH_INTERVAL_DEFAULT),DataChecksum.Type.valueOf(DFSConfigKeys.DFS_CHECKSUM_TYPE_DEFAULT),providerPath);
    return serverDefaults;
  }
  /** 
 * This test performs encrypted read/write and picks up the key provider uri from the credentials and not the conf.
 * @throws Exception
 */
  @Test public void testEncryptedReadWriteUsingDiffKeyProvider() throws Exception {
    final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
    Configuration clusterConf=cluster.getConfiguration(0);
    clusterConf.unset(CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH);
    DFSClient client=cluster.getFileSystem().getClient();
    Credentials credentials=new Credentials();
    Text lookUpKey=HdfsKMSUtil.getKeyProviderMapKey(cluster.getFileSystem().getUri());
    credentials.addSecretKey(lookUpKey,DFSUtilClient.string2Bytes(getKeyProviderURI()));
    client.ugi.addCredentials(credentials);
    final Path baseFile=new Path("/base");
    final int len=8192;
    DFSTestUtil.createFile(fs,baseFile,len,(short)1,0xFEED);
    final Path zone=new Path("/zone");
    fs.mkdirs(zone);
    dfsAdmin.createEncryptionZone(zone,TEST_KEY,NO_TRASH);
    final Path encFile1=new Path(zone,"myfile");
    DFSTestUtil.createFile(fs,encFile1,len,(short)1,0xFEED);
    verifyFilesEqual(fs,baseFile,encFile1,len);
  }
  /** 
 * Test listing encryption zones after zones had been deleted, but still exist under snapshots. This test first moves EZs to trash folder, so that an inodereference is created for the EZ, then it removes the EZ from trash folder to emulate condition where the EZ inode will not be complete.
 */
  @Test public void testListEncryptionZonesWithSnapshots() throws Exception {
    final Path snapshottable=new Path("/zones");
    final Path zoneDirectChild=new Path(snapshottable,"zone1");
    final Path snapshottableChild=new Path(snapshottable,"child");
    final Path zoneSubChild=new Path(snapshottableChild,"zone2");
    fsWrapper.mkdir(zoneDirectChild,FsPermission.getDirDefault(),true);
    fsWrapper.mkdir(zoneSubChild,FsPermission.getDirDefault(),true);
    dfsAdmin.allowSnapshot(snapshottable);
    dfsAdmin.createEncryptionZone(zoneDirectChild,TEST_KEY,NO_TRASH);
    dfsAdmin.createEncryptionZone(zoneSubChild,TEST_KEY,NO_TRASH);
    final Path snap1=fs.createSnapshot(snapshottable,"snap1");
    Configuration clientConf=new Configuration(conf);
    clientConf.setLong(FS_TRASH_INTERVAL_KEY,1);
    FsShell shell=new FsShell(clientConf);
    verifyShellDeleteWithTrash(shell,snapshottableChild);
    fsWrapper.delete(shell.getCurrentTrashDir(snapshottableChild),true);
    final RemoteIterator<EncryptionZone> it=dfsAdmin.listEncryptionZones();
    boolean match=false;
    while (it.hasNext()) {
      EncryptionZone ez=it.next();
      assertNotEquals("EncryptionZone " + zoneSubChild.toString() + " should not be listed.",ez.getPath(),zoneSubChild.toString());
    }
    verifyShellDeleteWithTrash(shell,zoneDirectChild);
    fsWrapper.delete(shell.getCurrentTrashDir(zoneDirectChild),true);
    assertFalse("listEncryptionZones should not return anything, " + "since both EZs were deleted.",dfsAdmin.listEncryptionZones().hasNext());
  }
  /** 
 * This test returns mocked kms token when {@link WebHdfsFileSystem#addDelegationTokens(String,Credentials)} methodis called.
 * @throws Exception
 */
  @Test public void addMockKmsToken() throws Exception {
    UserGroupInformation.createRemoteUser("JobTracker");
    WebHdfsFileSystem webfs=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsConstants.WEBHDFS_SCHEME);
    KeyProvider keyProvider=Mockito.mock(KeyProvider.class,withSettings().extraInterfaces(DelegationTokenExtension.class,CryptoExtension.class));
    Mockito.when(keyProvider.getConf()).thenReturn(conf);
    byte[] testIdentifier="Test identifier for delegation token".getBytes();
    Token testToken=new Token(testIdentifier,new byte[0],new Text("kms-dt"),new Text());
    Mockito.when(((DelegationTokenIssuer)keyProvider).getCanonicalServiceName()).thenReturn("service");
    Mockito.when(((DelegationTokenIssuer)keyProvider).getDelegationToken(anyString())).thenReturn(testToken);
    webfs.setTestProvider(keyProvider);
    Credentials creds=new Credentials();
    final Token<?>[] tokens=webfs.addDelegationTokens("JobTracker",creds);
    Assert.assertEquals(2,tokens.length);
    Assert.assertEquals(tokens[1],testToken);
    Assert.assertEquals(2,creds.numberOfTokens());
  }
  /** 
 * Creates a file with stable  {@link DistributedFileSystem}. Tests the following 2 scenarios. 1. The decrypted data using  {@link WebHdfsFileSystem} should be same asinput data. 2. Gets the underlying raw encrypted stream and verifies that the encrypted data is different than input data.
 * @throws Exception
 */
  @Test public void testWebhdfsRead() throws Exception {
    Path zonePath=new Path("/TestEncryptionZone");
    fsWrapper.mkdir(zonePath,FsPermission.getDirDefault(),false);
    dfsAdmin.createEncryptionZone(zonePath,TEST_KEY,NO_TRASH);
    final Path encryptedFilePath=new Path("/TestEncryptionZone/encryptedFile.txt");
    final Path rawPath=new Path("/.reserved/raw/TestEncryptionZone/encryptedFile.txt");
    final String content="hello world";
    DFSTestUtil.writeFile(fs,encryptedFilePath,content);
    final FileSystem webhdfs=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsConstants.WEBHDFS_SCHEME);
    InputStream decryptedIputStream=webhdfs.open(encryptedFilePath);
    verifyStreamsSame(content,decryptedIputStream);
    InputStream cryptoStream=webhdfs.open(encryptedFilePath).getWrappedStream();
    Assert.assertTrue("cryptoStream should be an instance of " + "CryptoInputStream",(cryptoStream instanceof CryptoInputStream));
    InputStream encryptedStream=((CryptoInputStream)cryptoStream).getWrappedStream();
    verifyRaw(content,encryptedStream,fs.open(rawPath));
  }
  private void verifyStreamsSame(  String content,  InputStream is) throws IOException {
    byte[] streamBytes;
    try (ByteArrayOutputStream os=new ByteArrayOutputStream()){
      IOUtils.copyBytes(is,os,1024,true);
      streamBytes=os.toByteArray();
    }
     Assert.assertArrayEquals(content.getBytes(),streamBytes);
  }
  private void verifyRaw(  String content,  InputStream is,  InputStream rawIs) throws IOException {
    byte[] streamBytes, rawBytes;
    try (ByteArrayOutputStream os=new ByteArrayOutputStream()){
      IOUtils.copyBytes(is,os,1024,true);
      streamBytes=os.toByteArray();
    }
     Assert.assertFalse(Arrays.equals(content.getBytes(),streamBytes));
    try (ByteArrayOutputStream os=new ByteArrayOutputStream()){
      IOUtils.copyBytes(rawIs,os,1024,true);
      rawBytes=os.toByteArray();
    }
     Assert.assertArrayEquals(rawBytes,streamBytes);
  }
  @Test public void testWebhdfsReadOldBehavior() throws Exception {
    Path zonePath=new Path("/TestEncryptionZone");
    fsWrapper.mkdir(zonePath,FsPermission.getDirDefault(),false);
    dfsAdmin.createEncryptionZone(zonePath,TEST_KEY,NO_TRASH);
    final Path encryptedFilePath=new Path("/TestEncryptionZone/foo");
    final String content="hello world";
    DFSTestUtil.writeFile(fs,encryptedFilePath,content);
    InetSocketAddress addr=cluster.getNameNode().getHttpAddress();
    URL url=new URL("http",addr.getHostString(),addr.getPort(),WebHdfsFileSystem.PATH_PREFIX + encryptedFilePath.toString() + "?op=OPEN");
    HttpURLConnection namenodeConnection=returnConnection(url,"GET",false);
    String location=namenodeConnection.getHeaderField("Location");
    URL datanodeURL=new URL(location);
    String path=datanodeURL.getPath();
    Assert.assertEquals(WebHdfsFileSystem.PATH_PREFIX + encryptedFilePath.toString(),path);
    HttpURLConnection datanodeConnection=returnConnection(datanodeURL,"GET",false);
    InputStream in=datanodeConnection.getInputStream();
    verifyStreamsSame(content,in);
  }
  @Test public void testWebhfsEZRedirectLocation() throws Exception {
    Path zonePath=new Path("/TestEncryptionZone");
    fsWrapper.mkdir(zonePath,FsPermission.getDirDefault(),false);
    dfsAdmin.createEncryptionZone(zonePath,TEST_KEY,NO_TRASH);
    final Path encryptedFilePath=new Path("/TestEncryptionZone/foo");
    final String content="hello world";
    DFSTestUtil.writeFile(fs,encryptedFilePath,content);
    InetSocketAddress addr=cluster.getNameNode().getHttpAddress();
    URL url=new URL("http",addr.getHostString(),addr.getPort(),WebHdfsFileSystem.PATH_PREFIX + encryptedFilePath.toString() + "?op=OPEN");
    HttpURLConnection namenodeConnection=returnConnection(url,"GET",false);
    Assert.assertNotNull(namenodeConnection.getHeaderField("Location"));
    URL datanodeUrl=new URL(namenodeConnection.getHeaderField("Location"));
    Assert.assertNotNull(datanodeUrl);
    String path=datanodeUrl.getPath();
    Assert.assertEquals(WebHdfsFileSystem.PATH_PREFIX + encryptedFilePath.toString(),path);
    url=new URL("http",addr.getHostString(),addr.getPort(),WebHdfsFileSystem.PATH_PREFIX + encryptedFilePath.toString() + "?op=OPEN");
    namenodeConnection=returnConnection(url,"GET",true);
    Assert.assertNotNull(namenodeConnection.getHeaderField("Location"));
    datanodeUrl=new URL(namenodeConnection.getHeaderField("Location"));
    Assert.assertNotNull(datanodeUrl);
    path=datanodeUrl.getPath();
    Assert.assertEquals(WebHdfsFileSystem.PATH_PREFIX + "/.reserved/raw" + encryptedFilePath.toString(),path);
  }
  private static HttpURLConnection returnConnection(  URL url,  String httpRequestType,  boolean supportEZ) throws Exception {
    HttpURLConnection conn=null;
    conn=(HttpURLConnection)url.openConnection();
    conn.setRequestMethod(httpRequestType);
    conn.setDoOutput(true);
    conn.setInstanceFollowRedirects(false);
    if (supportEZ) {
      conn.setRequestProperty(WebHdfsFileSystem.EZ_HEADER,"true");
    }
    return conn;
  }
  @Test public void testPread() throws Exception {
    Path zonePath=new Path("/TestEncryptionZone");
    fsWrapper.mkdir(zonePath,FsPermission.getDirDefault(),false);
    dfsAdmin.createEncryptionZone(zonePath,TEST_KEY,NO_TRASH);
    final Path encryptedFilePath=new Path("/TestEncryptionZone/foo");
    WebHdfsFileSystem webfs=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsConstants.WEBHDFS_SCHEME);
    DFSTestUtil.createFile(webfs,encryptedFilePath,1024,(short)1,0xFEED);
    byte[] data=DFSTestUtil.readFileAsBytes(fs,encryptedFilePath);
    FSDataInputStream in=webfs.open(encryptedFilePath);
    for (int i=0; i < 1024; i++) {
      in.seek(i);
      Assert.assertEquals((data[i] & 0XFF),in.read());
    }
  }
  /** 
 * Tests that namenode doesn't generate edek if we are writing to /.reserved/raw directory.
 * @throws Exception
 */
  @Test public void testWriteToEZReservedRaw() throws Exception {
    String unEncryptedBytes="hello world";
    final Path zonePath=new Path("/zone");
    fsWrapper.mkdir(zonePath,FsPermission.getDirDefault(),false);
    dfsAdmin.createEncryptionZone(zonePath,TEST_KEY,NO_TRASH);
    Path p1=new Path(zonePath,"p1");
    Path reservedRawPath=new Path("/.reserved/raw/" + p1.toString());
    OutputStream os=fs.create(reservedRawPath);
    os.close();
    try {
      fs.getXAttr(reservedRawPath,HdfsServerConstants.CRYPTO_XATTR_FILE_ENCRYPTION_INFO);
      fail("getXAttr should have thrown an exception");
    }
 catch (    IOException ioe) {
      assertExceptionContains("At least one of the attributes provided was " + "not found.",ioe);
    }
  }
}
