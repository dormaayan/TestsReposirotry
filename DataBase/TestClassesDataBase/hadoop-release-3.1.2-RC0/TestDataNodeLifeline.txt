/** 
 * Test suite covering lifeline protocol handling in the DataNode.
 */
public class TestDataNodeLifeline {
  private static final Logger LOG=LoggerFactory.getLogger(TestDataNodeLifeline.class);
static {
    GenericTestUtils.setLogLevel(DataNode.LOG,Level.ALL);
  }
  @Rule public Timeout timeout=new Timeout(60000);
  private MiniDFSCluster cluster;
  private HdfsConfiguration conf;
  private DatanodeLifelineProtocolClientSideTranslatorPB lifelineNamenode;
  private DataNodeMetrics metrics;
  private DatanodeProtocolClientSideTranslatorPB namenode;
  private FSNamesystem namesystem;
  private DataNode dn;
  private BPServiceActor bpsa;
  @Before public void setup() throws Exception {
    conf=new HdfsConfiguration();
    conf.setInt(DFS_DATANODE_LIFELINE_INTERVAL_SECONDS_KEY,2);
    conf.setInt(DFS_HEARTBEAT_INTERVAL_KEY,1);
    conf.setInt(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1);
    conf.set(DFS_NAMENODE_LIFELINE_RPC_ADDRESS_KEY,"0.0.0.0:0");
    conf.setInt(DFS_NAMENODE_STALE_DATANODE_INTERVAL_KEY,6 * 1000);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    namesystem=cluster.getNameNode().getNamesystem();
    dn=cluster.getDataNodes().get(0);
    metrics=dn.getMetrics();
    assertNotNull(metrics);
    List<BPOfferService> allBpos=dn.getAllBpOs();
    assertNotNull(allBpos);
    assertEquals(1,allBpos.size());
    BPOfferService bpos=allBpos.get(0);
    List<BPServiceActor> allBpsa=bpos.getBPServiceActors();
    assertNotNull(allBpsa);
    assertEquals(1,allBpsa.size());
    bpsa=allBpsa.get(0);
    assertNotNull(bpsa);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        if (bpsa.getLifelineNameNodeProxy() != null) {
          lifelineNamenode=spy(bpsa.getLifelineNameNodeProxy());
          bpsa.setLifelineNameNode(lifelineNamenode);
        }
        return lifelineNamenode != null;
      }
    }
,100,10000);
    assertNotNull(bpsa.getNameNodeProxy());
    namenode=spy(bpsa.getNameNodeProxy());
    bpsa.setNameNode(namenode);
  }
  @After public void shutdown(){
    if (cluster != null) {
      cluster.shutdown();
      GenericTestUtils.assertNoThreadsMatching(".*lifeline.*");
    }
  }
  @Test public void testSendLifelineIfHeartbeatBlocked() throws Exception {
    int numLifelines=10;
    CountDownLatch lifelinesSent=new CountDownLatch(numLifelines);
    doAnswer(new LatchAwaitingAnswer<HeartbeatResponse>(lifelinesSent)).when(namenode).sendHeartbeat(any(DatanodeRegistration.class),any(StorageReport[].class),anyLong(),anyLong(),anyInt(),anyInt(),anyInt(),any(VolumeFailureSummary.class),anyBoolean(),any(SlowPeerReports.class),any(SlowDiskReports.class));
    doAnswer(new LatchCountingAnswer<Void>(lifelinesSent)).when(lifelineNamenode).sendLifeline(any(DatanodeRegistration.class),any(StorageReport[].class),anyLong(),anyLong(),anyInt(),anyInt(),anyInt(),any(VolumeFailureSummary.class));
    while (!lifelinesSent.await(1,SECONDS)) {
      assertEquals("Expect DataNode to be kept alive by lifeline.",1,namesystem.getNumLiveDataNodes());
      assertEquals("Expect DataNode not marked dead due to lifeline.",0,namesystem.getNumDeadDataNodes());
      assertEquals("Expect DataNode not marked stale due to lifeline.",0,namesystem.getNumStaleDataNodes());
      cluster.getDataNodes().get(0).reconfigurePropertyImpl(DFS_DATANODE_DATA_DIR_KEY,cluster.getDataDirectory().concat("/data-new"));
    }
    verify(lifelineNamenode,atLeastOnce()).sendLifeline(any(DatanodeRegistration.class),any(StorageReport[].class),anyLong(),anyLong(),anyInt(),anyInt(),anyInt(),any(VolumeFailureSummary.class));
    assertTrue("Expect metrics to count at least " + numLifelines + " calls.",getLongCounter("LifelinesNumOps",getMetrics(metrics.name())) >= numLifelines);
  }
  @Test public void testNoLifelineSentIfHeartbeatsOnTime() throws Exception {
    int numHeartbeats=10;
    CountDownLatch heartbeatsSent=new CountDownLatch(numHeartbeats);
    doAnswer(new LatchCountingAnswer<HeartbeatResponse>(heartbeatsSent)).when(namenode).sendHeartbeat(any(DatanodeRegistration.class),any(StorageReport[].class),anyLong(),anyLong(),anyInt(),anyInt(),anyInt(),any(VolumeFailureSummary.class),anyBoolean(),any(SlowPeerReports.class),any(SlowDiskReports.class));
    while (!heartbeatsSent.await(1,SECONDS)) {
      assertEquals("Expect DataNode to be kept alive by lifeline.",1,namesystem.getNumLiveDataNodes());
      assertEquals("Expect DataNode not marked dead due to lifeline.",0,namesystem.getNumDeadDataNodes());
      assertEquals("Expect DataNode not marked stale due to lifeline.",0,namesystem.getNumStaleDataNodes());
    }
    verify(lifelineNamenode,never()).sendLifeline(any(DatanodeRegistration.class),any(StorageReport[].class),anyLong(),anyLong(),anyInt(),anyInt(),anyInt(),any(VolumeFailureSummary.class));
    assertEquals("Expect metrics to count no lifeline calls.",0,getLongCounter("LifelinesNumOps",getMetrics(metrics.name())));
  }
  @Test public void testLifelineForDeadNode() throws Exception {
    long initialCapacity=cluster.getNamesystem(0).getCapacityTotal();
    assertTrue(initialCapacity > 0);
    dn.setHeartbeatsDisabledForTests(true);
    cluster.setDataNodesDead();
    assertEquals("Capacity should be 0 after all DNs dead",0,cluster.getNamesystem(0).getCapacityTotal());
    bpsa.sendLifelineForTests();
    assertEquals("Lifeline should be ignored for dead node",0,cluster.getNamesystem(0).getCapacityTotal());
    dn.setHeartbeatsDisabledForTests(false);
    final DatanodeDescriptor dnDesc=cluster.getNamesystem(0).getBlockManager().getDatanodeManager().getDatanodes().iterator().next();
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return dnDesc.isAlive() && dnDesc.isHeartbeatedSinceRegistration();
      }
    }
,100,5000);
    assertEquals("Capacity should include only live capacity",initialCapacity,cluster.getNamesystem(0).getCapacityTotal());
  }
  /** 
 * Waits on a  {@link CountDownLatch} before calling through to the method.
 */
private final class LatchAwaitingAnswer<T> implements Answer<T> {
    private final CountDownLatch latch;
    public LatchAwaitingAnswer(    CountDownLatch latch){
      this.latch=latch;
    }
    @Override @SuppressWarnings("unchecked") public T answer(    InvocationOnMock invocation) throws Throwable {
      LOG.info("Awaiting, remaining latch count is {}.",latch.getCount());
      latch.await();
      return (T)invocation.callRealMethod();
    }
  }
  /** 
 * Counts on a  {@link CountDownLatch} after each call through to the method.
 */
private final class LatchCountingAnswer<T> implements Answer<T> {
    private final CountDownLatch latch;
    public LatchCountingAnswer(    CountDownLatch latch){
      this.latch=latch;
    }
    @Override @SuppressWarnings("unchecked") public T answer(    InvocationOnMock invocation) throws Throwable {
      T result=(T)invocation.callRealMethod();
      latch.countDown();
      LOG.info("Countdown, remaining latch count is {}.",latch.getCount());
      return result;
    }
  }
}
