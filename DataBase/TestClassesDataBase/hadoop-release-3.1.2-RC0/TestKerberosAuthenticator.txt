/** 
 * Test class for  {@link KerberosAuthenticator}.
 */
public class TestKerberosAuthenticator extends KerberosSecurityTestcase {
  public TestKerberosAuthenticator(){
  }
  @Before public void setup() throws Exception {
    File keytabFile=new File(KerberosTestUtils.getKeytabFile());
    String clientPrincipal=KerberosTestUtils.getClientPrincipal();
    String serverPrincipal=KerberosTestUtils.getServerPrincipal();
    clientPrincipal=clientPrincipal.substring(0,clientPrincipal.lastIndexOf("@"));
    serverPrincipal=serverPrincipal.substring(0,serverPrincipal.lastIndexOf("@"));
    getKdc().createPrincipal(keytabFile,clientPrincipal,serverPrincipal);
  }
  private Properties getAuthenticationHandlerConfiguration(){
    Properties props=new Properties();
    props.setProperty(AuthenticationFilter.AUTH_TYPE,"kerberos");
    props.setProperty(KerberosAuthenticationHandler.PRINCIPAL,KerberosTestUtils.getServerPrincipal());
    props.setProperty(KerberosAuthenticationHandler.KEYTAB,KerberosTestUtils.getKeytabFile());
    props.setProperty(KerberosAuthenticationHandler.NAME_RULES,"RULE:[1:$1@$0](.*@" + KerberosTestUtils.getRealm() + ")s/@.*//\n");
    props.setProperty(KerberosAuthenticationHandler.RULE_MECHANISM,"hadoop");
    return props;
  }
  private Properties getMultiAuthHandlerConfiguration(){
    Properties props=new Properties();
    props.setProperty(AUTH_TYPE,MultiSchemeAuthenticationHandler.TYPE);
    props.setProperty(SCHEMES_PROPERTY,"negotiate");
    props.setProperty(String.format(AUTH_HANDLER_PROPERTY,"negotiate"),"kerberos");
    props.setProperty(PRINCIPAL,KerberosTestUtils.getServerPrincipal());
    props.setProperty(KEYTAB,KerberosTestUtils.getKeytabFile());
    props.setProperty(NAME_RULES,"RULE:[1:$1@$0](.*@" + KerberosTestUtils.getRealm() + ")s/@.*//\n");
    return props;
  }
  @Test(timeout=60000) public void testFallbacktoPseudoAuthenticator() throws Exception {
    AuthenticatorTestCase auth=new AuthenticatorTestCase();
    Properties props=new Properties();
    props.setProperty(AuthenticationFilter.AUTH_TYPE,"simple");
    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED,"false");
    AuthenticatorTestCase.setAuthenticationHandlerConfig(props);
    auth._testAuthentication(new KerberosAuthenticator(),false);
  }
  @Test(timeout=60000) public void testFallbacktoPseudoAuthenticatorAnonymous() throws Exception {
    AuthenticatorTestCase auth=new AuthenticatorTestCase();
    Properties props=new Properties();
    props.setProperty(AuthenticationFilter.AUTH_TYPE,"simple");
    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED,"true");
    AuthenticatorTestCase.setAuthenticationHandlerConfig(props);
    auth._testAuthentication(new KerberosAuthenticator(),false);
  }
  @Test(timeout=60000) public void testNotAuthenticated() throws Exception {
    AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());
    auth.start();
    try {
      URL url=new URL(auth.getBaseURL());
      HttpURLConnection conn=(HttpURLConnection)url.openConnection();
      conn.connect();
      Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED,conn.getResponseCode());
      Assert.assertTrue(conn.getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE) != null);
    }
  finally {
      auth.stop();
    }
  }
  @Test(timeout=60000) public void testAuthentication() throws Exception {
    final AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());
    KerberosTestUtils.doAsClient(new Callable<Void>(){
      @Override public Void call() throws Exception {
        auth._testAuthentication(new KerberosAuthenticator(),false);
        return null;
      }
    }
);
  }
  @Test(timeout=60000) public void testAuthenticationPost() throws Exception {
    final AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());
    KerberosTestUtils.doAsClient(new Callable<Void>(){
      @Override public Void call() throws Exception {
        auth._testAuthentication(new KerberosAuthenticator(),true);
        return null;
      }
    }
);
  }
  @Test(timeout=60000) public void testAuthenticationHttpClient() throws Exception {
    final AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());
    KerberosTestUtils.doAsClient(new Callable<Void>(){
      @Override public Void call() throws Exception {
        auth._testAuthenticationHttpClient(new KerberosAuthenticator(),false);
        return null;
      }
    }
);
  }
  @Test(timeout=60000) public void testAuthenticationHttpClientPost() throws Exception {
    final AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());
    KerberosTestUtils.doAsClient(new Callable<Void>(){
      @Override public Void call() throws Exception {
        auth._testAuthenticationHttpClient(new KerberosAuthenticator(),true);
        return null;
      }
    }
);
  }
  @Test(timeout=60000) public void testNotAuthenticatedWithMultiAuthHandler() throws Exception {
    AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());
    auth.start();
    try {
      URL url=new URL(auth.getBaseURL());
      HttpURLConnection conn=(HttpURLConnection)url.openConnection();
      conn.connect();
      Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED,conn.getResponseCode());
      Assert.assertTrue(conn.getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE) != null);
    }
  finally {
      auth.stop();
    }
  }
  @Test(timeout=60000) public void testAuthenticationWithMultiAuthHandler() throws Exception {
    final AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());
    KerberosTestUtils.doAsClient(new Callable<Void>(){
      @Override public Void call() throws Exception {
        auth._testAuthentication(new KerberosAuthenticator(),false);
        return null;
      }
    }
);
  }
  @Test(timeout=60000) public void testAuthenticationHttpClientPostWithMultiAuthHandler() throws Exception {
    final AuthenticatorTestCase auth=new AuthenticatorTestCase();
    AuthenticatorTestCase.setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());
    KerberosTestUtils.doAsClient(new Callable<Void>(){
      @Override public Void call() throws Exception {
        auth._testAuthenticationHttpClient(new KerberosAuthenticator(),true);
        return null;
      }
    }
);
  }
  @Test(timeout=60000) public void testWrapExceptionWithMessage(){
    IOException ex;
    ex=new IOException("Induced exception");
    ex=KerberosAuthenticator.wrapExceptionWithMessage(ex,"Error while " + "authenticating with endpoint: localhost");
    Assert.assertEquals("Induced exception",ex.getCause().getMessage());
    Assert.assertEquals("Error while authenticating with endpoint: localhost",ex.getMessage());
    ex=new AuthenticationException("Auth exception");
    ex=KerberosAuthenticator.wrapExceptionWithMessage(ex,"Error while " + "authenticating with endpoint: localhost");
    Assert.assertEquals("Auth exception",ex.getCause().getMessage());
    Assert.assertEquals("Error while authenticating with endpoint: localhost",ex.getMessage());
    ex=new CharacterCodingException();
    Exception ex2=KerberosAuthenticator.wrapExceptionWithMessage(ex,"Error while authenticating with endpoint: localhost");
    Assert.assertTrue(ex instanceof CharacterCodingException);
    Assert.assertTrue(ex.equals(ex2));
  }
}
