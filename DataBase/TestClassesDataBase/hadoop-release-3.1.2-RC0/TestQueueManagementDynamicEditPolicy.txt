public class TestQueueManagementDynamicEditPolicy extends TestCapacitySchedulerAutoCreatedQueueBase {
  private QueueManagementDynamicEditPolicy policy=new QueueManagementDynamicEditPolicy();
  @Before public void setUp() throws Exception {
    super.setUp();
    policy.init(cs.getConfiguration(),cs.getRMContext(),cs);
  }
  @Test public void testEditSchedule() throws Exception {
    try {
      policy.editSchedule();
      assertEquals(2,policy.getManagedParentQueues().size());
      CSQueue parentQueue=cs.getQueue(PARENT_QUEUE);
      GuaranteedOrZeroCapacityOverTimePolicy autoCreatedQueueManagementPolicy=(GuaranteedOrZeroCapacityOverTimePolicy)((ManagedParentQueue)parentQueue).getAutoCreatedQueueManagementPolicy();
      assertEquals(0f,autoCreatedQueueManagementPolicy.getAbsoluteActivatedChildQueueCapacity(NO_LABEL),EPSILON);
      ApplicationId user1AppId=submitApp(mockRM,parentQueue,USER1,USER1,1,1);
      Map<String,Float> expectedAbsChildQueueCapacity=populateExpectedAbsCapacityByLabelForParentQueue(1);
      validateInitialQueueEntitlement(parentQueue,USER1,expectedAbsChildQueueCapacity,accessibleNodeLabelsOnC);
      ApplicationId user2AppId=submitApp(mockRM,parentQueue,USER2,USER2,2,1);
      expectedAbsChildQueueCapacity=populateExpectedAbsCapacityByLabelForParentQueue(2);
      validateInitialQueueEntitlement(parentQueue,USER2,expectedAbsChildQueueCapacity,accessibleNodeLabelsOnC);
      assertEquals(0.2f,autoCreatedQueueManagementPolicy.getAbsoluteActivatedChildQueueCapacity(NO_LABEL),EPSILON);
      submitApp(mockRM,parentQueue,USER3,USER3,3,1);
      final CSQueue user3LeafQueue=cs.getQueue(USER3);
      validateCapacities((AutoCreatedLeafQueue)user3LeafQueue,0.0f,0.0f,1.0f,1.0f);
      assertEquals(autoCreatedQueueManagementPolicy.getAbsoluteActivatedChildQueueCapacity(NO_LABEL),0.2f,EPSILON);
      cs.killAllAppsInQueue(USER2);
      mockRM.waitForState(user2AppId,RMAppState.KILLED);
      cs.killAllAppsInQueue(USER1);
      mockRM.waitForState(user1AppId,RMAppState.KILLED);
      policy.editSchedule();
      waitForPolicyState(0.1f,autoCreatedQueueManagementPolicy,NO_LABEL,1000);
      validateCapacities((AutoCreatedLeafQueue)user3LeafQueue,0.5f,0.1f,1.0f,1.0f);
      validateCapacitiesByLabel((ManagedParentQueue)parentQueue,(AutoCreatedLeafQueue)user3LeafQueue,NODEL_LABEL_GPU);
    }
  finally {
      cleanupQueue(USER1);
      cleanupQueue(USER2);
      cleanupQueue(USER3);
    }
  }
  private void waitForPolicyState(  float expectedVal,  GuaranteedOrZeroCapacityOverTimePolicy queueManagementPolicy,  String nodeLabel,  int timesec) throws InterruptedException {
    long start=System.currentTimeMillis();
    while (System.currentTimeMillis() - start < timesec * 1000) {
      if (Float.compare(expectedVal,queueManagementPolicy.getAbsoluteActivatedChildQueueCapacity(nodeLabel)) > EPSILON) {
        Thread.sleep(100);
      }
 else {
        break;
      }
    }
  }
}
