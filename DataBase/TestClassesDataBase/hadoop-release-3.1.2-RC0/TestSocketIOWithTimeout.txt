/** 
 * This tests timout out from SocketInputStream and SocketOutputStream using pipes. Normal read and write using these streams are tested by pretty much every DFS unit test.
 */
public class TestSocketIOWithTimeout {
  static final Logger LOG=LoggerFactory.getLogger(TestSocketIOWithTimeout.class);
  private static int TIMEOUT=1 * 1000;
  private static String TEST_STRING="1234567890";
  private MultithreadedTestUtil.TestContext ctx=new TestContext();
  private static final int PAGE_SIZE=(int)NativeIO.POSIX.getCacheManipulator().getOperatingSystemPageSize();
  private void doIO(  InputStream in,  OutputStream out,  int expectedTimeout) throws IOException {
    byte buf[]=new byte[PAGE_SIZE + 19];
    while (true) {
      long start=Time.now();
      try {
        if (in != null) {
          in.read(buf);
        }
 else {
          out.write(buf);
        }
      }
 catch (      SocketTimeoutException e) {
        long diff=Time.now() - start;
        LOG.info("Got SocketTimeoutException as expected after " + diff + " millis : "+ e.getMessage());
        assertTrue(Math.abs(expectedTimeout - diff) <= TestNetUtils.TIME_FUDGE_MILLIS);
        break;
      }
    }
  }
  @Test public void testSocketIOWithTimeout() throws Exception {
    Pipe pipe=Pipe.open();
    Pipe.SourceChannel source=pipe.source();
    Pipe.SinkChannel sink=pipe.sink();
    try {
      final InputStream in=new SocketInputStream(source,TIMEOUT);
      OutputStream out=new SocketOutputStream(sink,TIMEOUT);
      byte[] writeBytes=TEST_STRING.getBytes();
      byte[] readBytes=new byte[writeBytes.length];
      byte byteWithHighBit=(byte)0x80;
      out.write(writeBytes);
      out.write(byteWithHighBit);
      doIO(null,out,TIMEOUT);
      in.read(readBytes);
      assertTrue(Arrays.equals(writeBytes,readBytes));
      assertEquals(byteWithHighBit & 0xff,in.read());
      doIO(in,null,TIMEOUT);
      ((SocketInputStream)in).setTimeout(TIMEOUT * 2);
      doIO(in,null,TIMEOUT * 2);
      ((SocketInputStream)in).setTimeout(0);
      TestingThread thread=new TestingThread(ctx){
        @Override public void doWork() throws Exception {
          try {
            in.read();
            fail("Did not fail with interrupt");
          }
 catch (          InterruptedIOException ste) {
            LOG.info("Got expection while reading as expected : " + ste.getMessage());
          }
        }
      }
;
      ctx.addThread(thread);
      ctx.startThreads();
      Thread.sleep(1000);
      thread.interrupt();
      ctx.stop();
      assertTrue(source.isOpen());
      assertTrue(sink.isOpen());
      if (!Shell.WINDOWS) {
        try {
          out.write(1);
          fail("Did not throw");
        }
 catch (        IOException ioe) {
          GenericTestUtils.assertExceptionContains("stream is closed",ioe);
        }
      }
      out.close();
      assertFalse(sink.isOpen());
      assertEquals(-1,in.read());
      in.close();
      assertFalse(source.isOpen());
    }
  finally {
      if (source != null) {
        source.close();
      }
      if (sink != null) {
        sink.close();
      }
    }
  }
}
