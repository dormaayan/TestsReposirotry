/** 
 * Test cases for  {@link OpportunisticContainerAllocatorAMService}.
 */
public class TestOpportunisticContainerAllocatorAMService {
  private static final int GB=1024;
  private MockRM rm;
  private DrainDispatcher dispatcher;
  @Before public void createAndStartRM(){
    CapacitySchedulerConfiguration csConf=new CapacitySchedulerConfiguration();
    YarnConfiguration conf=new YarnConfiguration(csConf);
    conf.setClass(YarnConfiguration.RM_SCHEDULER,CapacityScheduler.class,ResourceScheduler.class);
    conf.setBoolean(YarnConfiguration.OPPORTUNISTIC_CONTAINER_ALLOCATION_ENABLED,true);
    conf.setInt(YarnConfiguration.NM_CONTAINER_QUEUING_SORTING_NODES_INTERVAL_MS,100);
    startRM(conf);
  }
  public void createAndStartRMWithAutoUpdateContainer(){
    CapacitySchedulerConfiguration csConf=new CapacitySchedulerConfiguration();
    YarnConfiguration conf=new YarnConfiguration(csConf);
    conf.setBoolean(YarnConfiguration.RM_AUTO_UPDATE_CONTAINERS,true);
    conf.setClass(YarnConfiguration.RM_SCHEDULER,CapacityScheduler.class,ResourceScheduler.class);
    conf.setBoolean(YarnConfiguration.OPPORTUNISTIC_CONTAINER_ALLOCATION_ENABLED,true);
    conf.setInt(YarnConfiguration.NM_CONTAINER_QUEUING_SORTING_NODES_INTERVAL_MS,100);
    startRM(conf);
  }
  private void startRM(  final YarnConfiguration conf){
    dispatcher=new DrainDispatcher();
    rm=new MockRM(conf){
      @Override protected Dispatcher createDispatcher(){
        return dispatcher;
      }
    }
;
    rm.start();
  }
  @After public void stopRM(){
    if (rm != null) {
      rm.stop();
    }
  }
  @Test(timeout=600000) public void testContainerPromoteAndDemoteBeforeContainerStart() throws Exception {
    HashMap<NodeId,MockNM> nodes=new HashMap<>();
    MockNM nm1=new MockNM("h1:1234",4096,rm.getResourceTrackerService());
    nodes.put(nm1.getNodeId(),nm1);
    MockNM nm2=new MockNM("h1:4321",4096,rm.getResourceTrackerService());
    nodes.put(nm2.getNodeId(),nm2);
    MockNM nm3=new MockNM("h2:1234",4096,rm.getResourceTrackerService());
    nodes.put(nm3.getNodeId(),nm3);
    MockNM nm4=new MockNM("h2:4321",4096,rm.getResourceTrackerService());
    nodes.put(nm4.getNodeId(),nm4);
    nm1.registerNode();
    nm2.registerNode();
    nm3.registerNode();
    nm4.registerNode();
    OpportunisticContainerAllocatorAMService amservice=(OpportunisticContainerAllocatorAMService)rm.getApplicationMasterService();
    RMApp app1=rm.submitApp(1 * GB,"app","user",null,"default");
    ApplicationAttemptId attemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm,nm2);
    ResourceScheduler scheduler=rm.getResourceScheduler();
    RMNode rmNode1=rm.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm.getRMContext().getRMNodes().get(nm2.getNodeId());
    RMNode rmNode3=rm.getRMContext().getRMNodes().get(nm3.getNodeId());
    RMNode rmNode4=rm.getRMContext().getRMNodes().get(nm4.getNodeId());
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    nm3.nodeHeartbeat(true);
    nm4.nodeHeartbeat(true);
    amservice.handle(new NodeAddedSchedulerEvent(rmNode1));
    amservice.handle(new NodeAddedSchedulerEvent(rmNode2));
    amservice.handle(new NodeAddedSchedulerEvent(rmNode3));
    amservice.handle(new NodeAddedSchedulerEvent(rmNode4));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode1));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode2));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode3));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode4));
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    nm3.nodeHeartbeat(true);
    nm4.nodeHeartbeat(true);
    Thread.sleep(1000);
    QueueMetrics metrics=((CapacityScheduler)scheduler).getRootQueue().getMetrics();
    verifyMetrics(metrics,15360,15,1024,1,1);
    AllocateResponse allocateResponse=am1.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resources.createResource(1 * GB),2,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true))),null);
    List<Container> allocatedContainers=allocateResponse.getAllocatedContainers();
    Assert.assertEquals(2,allocatedContainers.size());
    Container container=allocatedContainers.get(0);
    MockNM allocNode=nodes.get(container.getNodeId());
    MockNM sameHostDiffNode=null;
    for (    NodeId n : nodes.keySet()) {
      if (n.getHost().equals(allocNode.getNodeId().getHost()) && n.getPort() != allocNode.getNodeId().getPort()) {
        sameHostDiffNode=nodes.get(n);
      }
    }
    verifyMetrics(metrics,15360,15,1024,1,1);
    am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(0,container.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED)));
    sameHostDiffNode.nodeHeartbeat(true);
    rm.drainEvents();
    allocateResponse=am1.allocate(new ArrayList<>(),new ArrayList<>());
    Assert.assertEquals(0,allocateResponse.getUpdatedContainers().size());
    dispatcher.waitForEventThreadToWait();
    rm.drainEvents();
    verifyMetrics(metrics,15360,15,1024,1,1);
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(0,container.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED)));
    Assert.assertEquals(0,allocateResponse.getUpdatedContainers().size());
    Assert.assertEquals(1,allocateResponse.getUpdateErrors().size());
    Assert.assertEquals("UPDATE_OUTSTANDING_ERROR",allocateResponse.getUpdateErrors().get(0).getReason());
    Assert.assertEquals(container.getId(),allocateResponse.getUpdateErrors().get(0).getUpdateContainerRequest().getContainerId());
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(1,container.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED)));
    Assert.assertEquals(0,allocateResponse.getUpdatedContainers().size());
    Assert.assertEquals(1,allocateResponse.getUpdateErrors().size());
    Assert.assertEquals("INCORRECT_CONTAINER_VERSION_ERROR",allocateResponse.getUpdateErrors().get(0).getReason());
    Assert.assertEquals(0,allocateResponse.getUpdateErrors().get(0).getCurrentContainerVersion());
    Assert.assertEquals(container.getId(),allocateResponse.getUpdateErrors().get(0).getUpdateContainerRequest().getContainerId());
    allocNode.nodeHeartbeat(true);
    rm.drainEvents();
    allocateResponse=am1.allocate(new ArrayList<>(),new ArrayList<>());
    Assert.assertEquals(1,allocateResponse.getUpdatedContainers().size());
    Container uc=allocateResponse.getUpdatedContainers().get(0).getContainer();
    Assert.assertEquals(ExecutionType.GUARANTEED,uc.getExecutionType());
    Assert.assertEquals(uc.getId(),container.getId());
    Assert.assertEquals(uc.getVersion(),container.getVersion() + 1);
    verifyMetrics(metrics,14336,14,2048,2,2);
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    nm3.nodeHeartbeat(true);
    nm4.nodeHeartbeat(true);
    rm.drainEvents();
    RMContainer rmContainer=((CapacityScheduler)scheduler).getApplicationAttempt(uc.getId().getApplicationAttemptId()).getRMContainer(uc.getId());
    Assert.assertEquals(RMContainerState.ACQUIRED,rmContainer.getState());
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(uc.getVersion(),uc.getId(),ContainerUpdateType.DEMOTE_EXECUTION_TYPE,null,ExecutionType.OPPORTUNISTIC)));
    Assert.assertEquals(1,allocateResponse.getUpdatedContainers().size());
    uc=allocateResponse.getUpdatedContainers().get(0).getContainer();
    Assert.assertEquals(ExecutionType.OPPORTUNISTIC,uc.getExecutionType());
    Assert.assertEquals(uc.getId(),container.getId());
    Assert.assertEquals(uc.getVersion(),container.getVersion() + 2);
    dispatcher.waitForEventThreadToWait();
    rm.drainEvents();
    verifyMetrics(metrics,15360,15,1024,1,1);
  }
  @Test(timeout=60000) public void testContainerPromoteAfterContainerStart() throws Exception {
    HashMap<NodeId,MockNM> nodes=new HashMap<>();
    MockNM nm1=new MockNM("h1:1234",4096,rm.getResourceTrackerService());
    nodes.put(nm1.getNodeId(),nm1);
    MockNM nm2=new MockNM("h2:1234",4096,rm.getResourceTrackerService());
    nodes.put(nm2.getNodeId(),nm2);
    nm1.registerNode();
    nm2.registerNode();
    OpportunisticContainerAllocatorAMService amservice=(OpportunisticContainerAllocatorAMService)rm.getApplicationMasterService();
    RMApp app1=rm.submitApp(1 * GB,"app","user",null,"default");
    ApplicationAttemptId attemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm,nm2);
    ResourceScheduler scheduler=rm.getResourceScheduler();
    RMNode rmNode1=rm.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm.getRMContext().getRMNodes().get(nm2.getNodeId());
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    ((RMNodeImpl)rmNode1).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    ((RMNodeImpl)rmNode2).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    OpportunisticContainerContext ctxt=((CapacityScheduler)scheduler).getApplicationAttempt(attemptId).getOpportunisticContainerContext();
    amservice.handle(new NodeAddedSchedulerEvent(rmNode1));
    amservice.handle(new NodeAddedSchedulerEvent(rmNode2));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode1));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode2));
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    Thread.sleep(1000);
    QueueMetrics metrics=((CapacityScheduler)scheduler).getRootQueue().getMetrics();
    verifyMetrics(metrics,7168,7,1024,1,1);
    AllocateResponse allocateResponse=am1.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resources.createResource(1 * GB),2,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true))),null);
    List<Container> allocatedContainers=allocateResponse.getAllocatedContainers();
    Assert.assertEquals(2,allocatedContainers.size());
    Container container=allocatedContainers.get(0);
    MockNM allocNode=nodes.get(container.getNodeId());
    allocNode.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.OPPORTUNISTIC,ContainerState.RUNNING,"",0)),true);
    rm.drainEvents();
    RMContainer rmContainer=((CapacityScheduler)scheduler).getApplicationAttempt(container.getId().getApplicationAttemptId()).getRMContainer(container.getId());
    Assert.assertEquals(RMContainerState.RUNNING,rmContainer.getState());
    verifyMetrics(metrics,7168,7,1024,1,1);
    am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(0,container.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED)));
    verifyMetrics(metrics,7168,7,1024,1,1);
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(0,container.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED)));
    Assert.assertEquals(0,allocateResponse.getUpdatedContainers().size());
    Assert.assertEquals(1,allocateResponse.getUpdateErrors().size());
    Assert.assertEquals("UPDATE_OUTSTANDING_ERROR",allocateResponse.getUpdateErrors().get(0).getReason());
    Assert.assertEquals(container.getId(),allocateResponse.getUpdateErrors().get(0).getUpdateContainerRequest().getContainerId());
    allocNode.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.OPPORTUNISTIC,ContainerState.RUNNING,"",0)),true);
    rm.drainEvents();
    allocateResponse=am1.allocate(new ArrayList<>(),new ArrayList<>());
    Assert.assertEquals(1,allocateResponse.getUpdatedContainers().size());
    Container uc=allocateResponse.getUpdatedContainers().get(0).getContainer();
    Assert.assertEquals(ExecutionType.GUARANTEED,uc.getExecutionType());
    Assert.assertEquals(uc.getId(),container.getId());
    Assert.assertEquals(uc.getVersion(),container.getVersion() + 1);
    rmContainer=((CapacityScheduler)scheduler).getApplicationAttempt(uc.getId().getApplicationAttemptId()).getRMContainer(uc.getId());
    Assert.assertEquals(RMContainerState.RUNNING,rmContainer.getState());
    verifyMetrics(metrics,6144,6,2048,2,2);
  }
  @Test(timeout=600000) public void testContainerPromoteAfterContainerComplete() throws Exception {
    HashMap<NodeId,MockNM> nodes=new HashMap<>();
    MockNM nm1=new MockNM("h1:1234",4096,rm.getResourceTrackerService());
    nodes.put(nm1.getNodeId(),nm1);
    MockNM nm2=new MockNM("h2:1234",4096,rm.getResourceTrackerService());
    nodes.put(nm2.getNodeId(),nm2);
    nm1.registerNode();
    nm2.registerNode();
    OpportunisticContainerAllocatorAMService amservice=(OpportunisticContainerAllocatorAMService)rm.getApplicationMasterService();
    RMApp app1=rm.submitApp(1 * GB,"app","user",null,"default");
    ApplicationAttemptId attemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm,nm2);
    ResourceScheduler scheduler=rm.getResourceScheduler();
    RMNode rmNode1=rm.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm.getRMContext().getRMNodes().get(nm2.getNodeId());
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    ((RMNodeImpl)rmNode1).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    ((RMNodeImpl)rmNode2).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    OpportunisticContainerContext ctxt=((CapacityScheduler)scheduler).getApplicationAttempt(attemptId).getOpportunisticContainerContext();
    amservice.handle(new NodeAddedSchedulerEvent(rmNode1));
    amservice.handle(new NodeAddedSchedulerEvent(rmNode2));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode1));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode2));
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    Thread.sleep(1000);
    QueueMetrics metrics=((CapacityScheduler)scheduler).getRootQueue().getMetrics();
    verifyMetrics(metrics,7168,7,1024,1,1);
    AllocateResponse allocateResponse=am1.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resources.createResource(1 * GB),2,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true))),null);
    List<Container> allocatedContainers=allocateResponse.getAllocatedContainers();
    Assert.assertEquals(2,allocatedContainers.size());
    Container container=allocatedContainers.get(0);
    MockNM allocNode=nodes.get(container.getNodeId());
    allocNode.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.OPPORTUNISTIC,ContainerState.RUNNING,"",0)),true);
    rm.drainEvents();
    RMContainer rmContainer=((CapacityScheduler)scheduler).getApplicationAttempt(container.getId().getApplicationAttemptId()).getRMContainer(container.getId());
    Assert.assertEquals(RMContainerState.RUNNING,rmContainer.getState());
    allocNode.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.OPPORTUNISTIC,ContainerState.COMPLETE,"",0)),true);
    rm.drainEvents();
    rmContainer=((CapacityScheduler)scheduler).getApplicationAttempt(container.getId().getApplicationAttemptId()).getRMContainer(container.getId());
    Assert.assertNull(rmContainer);
    verifyMetrics(metrics,7168,7,1024,1,1);
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(0,container.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED)));
    Assert.assertEquals(1,allocateResponse.getCompletedContainersStatuses().size());
    Assert.assertEquals(container.getId(),allocateResponse.getCompletedContainersStatuses().get(0).getContainerId());
    Assert.assertEquals(0,allocateResponse.getUpdatedContainers().size());
    Assert.assertEquals(1,allocateResponse.getUpdateErrors().size());
    Assert.assertEquals("INVALID_CONTAINER_ID",allocateResponse.getUpdateErrors().get(0).getReason());
    Assert.assertEquals(container.getId(),allocateResponse.getUpdateErrors().get(0).getUpdateContainerRequest().getContainerId());
    verifyMetrics(metrics,7168,7,1024,1,1);
  }
  @Test(timeout=600000) public void testContainerAutoUpdateContainer() throws Exception {
    rm.stop();
    createAndStartRMWithAutoUpdateContainer();
    MockNM nm1=new MockNM("h1:1234",4096,rm.getResourceTrackerService());
    nm1.registerNode();
    OpportunisticContainerAllocatorAMService amservice=(OpportunisticContainerAllocatorAMService)rm.getApplicationMasterService();
    RMApp app1=rm.submitApp(1 * GB,"app","user",null,"default");
    ApplicationAttemptId attemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm,nm1);
    ResourceScheduler scheduler=rm.getResourceScheduler();
    RMNode rmNode1=rm.getRMContext().getRMNodes().get(nm1.getNodeId());
    nm1.nodeHeartbeat(true);
    ((RMNodeImpl)rmNode1).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    OpportunisticContainerContext ctxt=((CapacityScheduler)scheduler).getApplicationAttempt(attemptId).getOpportunisticContainerContext();
    amservice.handle(new NodeAddedSchedulerEvent(rmNode1));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode1));
    nm1.nodeHeartbeat(true);
    Thread.sleep(1000);
    AllocateResponse allocateResponse=am1.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resources.createResource(1 * GB),2,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true))),null);
    List<Container> allocatedContainers=allocateResponse.getAllocatedContainers();
    allocatedContainers.addAll(am1.allocate(null,null).getAllocatedContainers());
    Assert.assertEquals(2,allocatedContainers.size());
    Container container=allocatedContainers.get(0);
    nm1.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.OPPORTUNISTIC,ContainerState.RUNNING,"",0)),true);
    rm.drainEvents();
    RMContainer rmContainer=((CapacityScheduler)scheduler).getApplicationAttempt(container.getId().getApplicationAttemptId()).getRMContainer(container.getId());
    Assert.assertEquals(RMContainerState.RUNNING,rmContainer.getState());
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(0,container.getId(),ContainerUpdateType.PROMOTE_EXECUTION_TYPE,null,ExecutionType.GUARANTEED)));
    nm1.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.OPPORTUNISTIC,ContainerState.RUNNING,"",0)),true);
    rm.drainEvents();
    allocateResponse=am1.allocate(new ArrayList<>(),new ArrayList<>());
    Assert.assertEquals(1,allocateResponse.getUpdatedContainers().size());
    UpdatedContainer uc=allocateResponse.getUpdatedContainers().get(0);
    Assert.assertEquals(container.getId(),uc.getContainer().getId());
    Assert.assertEquals(ExecutionType.GUARANTEED,uc.getContainer().getExecutionType());
    NodeHeartbeatResponse response=nm1.nodeHeartbeat(true);
    Assert.assertEquals(1,response.getContainersToUpdate().size());
    Container containersFromNM=response.getContainersToUpdate().get(0);
    Assert.assertEquals(container.getId(),containersFromNM.getId());
    Assert.assertEquals(ExecutionType.GUARANTEED,containersFromNM.getExecutionType());
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(1,container.getId(),ContainerUpdateType.INCREASE_RESOURCE,Resources.createResource(2 * GB,1),null)));
    response=nm1.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.GUARANTEED,ContainerState.RUNNING,"",0)),true);
    rm.drainEvents();
    if (allocateResponse.getUpdatedContainers().size() == 0) {
      allocateResponse=am1.allocate(new ArrayList<>(),new ArrayList<>());
    }
    Assert.assertEquals(1,allocateResponse.getUpdatedContainers().size());
    uc=allocateResponse.getUpdatedContainers().get(0);
    Assert.assertEquals(container.getId(),uc.getContainer().getId());
    Assert.assertEquals(Resource.newInstance(2 * GB,1),uc.getContainer().getResource());
    rm.drainEvents();
    if (response.getContainersToUpdate().size() == 0) {
      response=nm1.nodeHeartbeat(true);
    }
    Assert.assertEquals(1,response.getContainersToUpdate().size());
    Assert.assertEquals(Resource.newInstance(2 * GB,1),response.getContainersToUpdate().get(0).getResource());
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(2,container.getId(),ContainerUpdateType.DECREASE_RESOURCE,Resources.createResource(1 * GB,1),null)));
    Assert.assertEquals(1,allocateResponse.getUpdatedContainers().size());
    rm.drainEvents();
    response=nm1.nodeHeartbeat(true);
    Assert.assertEquals(1,response.getContainersToUpdate().size());
    Assert.assertEquals(Resource.newInstance(1 * GB,1),response.getContainersToUpdate().get(0).getResource());
    nm1.nodeHeartbeat(true);
    allocateResponse=am1.sendContainerUpdateRequest(Arrays.asList(UpdateContainerRequest.newInstance(3,container.getId(),ContainerUpdateType.DEMOTE_EXECUTION_TYPE,null,ExecutionType.OPPORTUNISTIC)));
    response=nm1.nodeHeartbeat(Arrays.asList(ContainerStatus.newInstance(container.getId(),ExecutionType.GUARANTEED,ContainerState.RUNNING,"",0)),true);
    rm.drainEvents();
    if (allocateResponse.getUpdatedContainers().size() == 0) {
      allocateResponse=am1.allocate(new ArrayList<>(),new ArrayList<>());
    }
    Assert.assertEquals(1,allocateResponse.getUpdatedContainers().size());
    uc=allocateResponse.getUpdatedContainers().get(0);
    Assert.assertEquals(ExecutionType.OPPORTUNISTIC,uc.getContainer().getExecutionType());
    if (response.getContainersToUpdate().size() == 0) {
      response=nm1.nodeHeartbeat(true);
    }
    Assert.assertEquals(1,response.getContainersToUpdate().size());
    Assert.assertEquals(ExecutionType.OPPORTUNISTIC,response.getContainersToUpdate().get(0).getExecutionType());
  }
  private void verifyMetrics(  QueueMetrics metrics,  long availableMB,  int availableVirtualCores,  long allocatedMB,  int allocatedVirtualCores,  int allocatedContainers){
    Assert.assertEquals(availableMB,metrics.getAvailableMB());
    Assert.assertEquals(availableVirtualCores,metrics.getAvailableVirtualCores());
    Assert.assertEquals(allocatedMB,metrics.getAllocatedMB());
    Assert.assertEquals(allocatedVirtualCores,metrics.getAllocatedVirtualCores());
    Assert.assertEquals(allocatedContainers,metrics.getAllocatedContainers());
  }
  @Test(timeout=60000) public void testNodeRemovalDuringAllocate() throws Exception {
    MockNM nm1=new MockNM("h1:1234",4096,rm.getResourceTrackerService());
    MockNM nm2=new MockNM("h2:1234",4096,rm.getResourceTrackerService());
    nm1.registerNode();
    nm2.registerNode();
    OpportunisticContainerAllocatorAMService amservice=(OpportunisticContainerAllocatorAMService)rm.getApplicationMasterService();
    RMApp app1=rm.submitApp(1 * GB,"app","user",null,"default");
    ApplicationAttemptId attemptId=app1.getCurrentAppAttempt().getAppAttemptId();
    MockAM am1=MockRM.launchAndRegisterAM(app1,rm,nm2);
    ResourceScheduler scheduler=rm.getResourceScheduler();
    RMNode rmNode1=rm.getRMContext().getRMNodes().get(nm1.getNodeId());
    RMNode rmNode2=rm.getRMContext().getRMNodes().get(nm2.getNodeId());
    nm1.nodeHeartbeat(true);
    nm2.nodeHeartbeat(true);
    ((RMNodeImpl)rmNode1).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    ((RMNodeImpl)rmNode2).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    OpportunisticContainerContext ctxt=((CapacityScheduler)scheduler).getApplicationAttempt(attemptId).getOpportunisticContainerContext();
    amservice.handle(new NodeAddedSchedulerEvent(rmNode1));
    amservice.handle(new NodeAddedSchedulerEvent(rmNode2));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode1));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode2));
    for (int i=0; i < 10; i++) {
      am1.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resources.createResource(1 * GB),2)),null);
      if (ctxt.getNodeMap().size() == 2) {
        break;
      }
      Thread.sleep(50);
    }
    Assert.assertEquals(2,ctxt.getNodeMap().size());
    scheduler.handle(new NodeRemovedSchedulerEvent(rmNode1));
    for (int i=0; i < 10; i++) {
      try {
        am1.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resources.createResource(1 * GB),2)),null);
      }
 catch (      Exception e) {
        Assert.fail("Allocate request should be handled on node removal");
      }
      if (ctxt.getNodeMap().size() == 1) {
        break;
      }
      Thread.sleep(50);
    }
    Assert.assertEquals(1,ctxt.getNodeMap().size());
  }
  @Test(timeout=60000) public void testAppAttemptRemovalAfterNodeRemoval() throws Exception {
    MockNM nm=new MockNM("h:1234",4096,rm.getResourceTrackerService());
    nm.registerNode();
    OpportunisticContainerAllocatorAMService amservice=(OpportunisticContainerAllocatorAMService)rm.getApplicationMasterService();
    RMApp app=rm.submitApp(1 * GB,"app","user",null,"default");
    ApplicationAttemptId attemptId=app.getCurrentAppAttempt().getAppAttemptId();
    MockAM am=MockRM.launchAndRegisterAM(app,rm,nm);
    ResourceScheduler scheduler=rm.getResourceScheduler();
    SchedulerApplicationAttempt schedulerAttempt=((CapacityScheduler)scheduler).getApplicationAttempt(attemptId);
    RMNode rmNode1=rm.getRMContext().getRMNodes().get(nm.getNodeId());
    nm.nodeHeartbeat(true);
    ((RMNodeImpl)rmNode1).setOpportunisticContainersStatus(getOppurtunisticStatus(-1,100));
    amservice.handle(new NodeAddedSchedulerEvent(rmNode1));
    amservice.handle(new NodeUpdateSchedulerEvent(rmNode1));
    try {
      GenericTestUtils.waitFor(new Supplier<Boolean>(){
        @Override public Boolean get(){
          return scheduler.getNumClusterNodes() == 1;
        }
      }
,10,200 * 100);
    }
 catch (    TimeoutException e) {
      fail("timed out while waiting for NM to add.");
    }
    AllocateResponse allocateResponse=am.allocate(Arrays.asList(ResourceRequest.newInstance(Priority.newInstance(1),"*",Resources.createResource(1 * GB),2,true,null,ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true))),null);
    List<Container> allocatedContainers=allocateResponse.getAllocatedContainers();
    Container container=allocatedContainers.get(0);
    scheduler.handle(new NodeRemovedSchedulerEvent(rmNode1));
    try {
      GenericTestUtils.waitFor(new Supplier<Boolean>(){
        @Override public Boolean get(){
          return scheduler.getNumClusterNodes() == 0;
        }
      }
,10,200 * 100);
    }
 catch (    TimeoutException e) {
      fail("timed out while waiting for NM to remove.");
    }
    RMContainer rmContainer=null;
    rmContainer=SchedulerUtils.createOpportunisticRmContainer(rm.getRMContext(),container,true);
    if (rmContainer == null) {
      rmContainer=new RMContainerImpl(container,SchedulerRequestKey.extractFrom(container),schedulerAttempt.getApplicationAttemptId(),container.getNodeId(),schedulerAttempt.getUser(),rm.getRMContext(),true);
    }
    assert (rmContainer != null);
    schedulerAttempt.addRMContainer(container.getId(),rmContainer);
    scheduler.handle(new AppAttemptRemovedSchedulerEvent(attemptId,RMAppAttemptState.FAILED,false));
  }
  private OpportunisticContainersStatus getOppurtunisticStatus(  int waitTime,  int queueLength){
    OpportunisticContainersStatus status1=Mockito.mock(OpportunisticContainersStatus.class);
    Mockito.when(status1.getEstimatedQueueWaitTime()).thenReturn(waitTime);
    Mockito.when(status1.getWaitQueueLength()).thenReturn(queueLength);
    return status1;
  }
  @Test public void testRPCWrapping() throws Exception {
    Configuration conf=new Configuration();
    conf.set(YarnConfiguration.IPC_RPC_IMPL,HadoopYarnProtoRPC.class.getName());
    YarnRPC rpc=YarnRPC.create(conf);
    String bindAddr="localhost:0";
    InetSocketAddress addr=NetUtils.createSocketAddr(bindAddr);
    conf.setSocketAddr(YarnConfiguration.RM_SCHEDULER_ADDRESS,addr);
    final RecordFactory factory=RecordFactoryProvider.getRecordFactory(null);
    final RMContext rmContext=new RMContextImpl(){
      @Override public AMLivelinessMonitor getAMLivelinessMonitor(){
        return null;
      }
      @Override public Configuration getYarnConfiguration(){
        return new YarnConfiguration();
      }
      @Override public RMContainerTokenSecretManager getContainerTokenSecretManager(){
        return new RMContainerTokenSecretManager(conf);
      }
      @Override public ResourceScheduler getScheduler(){
        return new FifoScheduler();
      }
    }
;
    Container c=factory.newRecordInstance(Container.class);
    c.setExecutionType(ExecutionType.OPPORTUNISTIC);
    c.setId(ContainerId.newContainerId(ApplicationAttemptId.newInstance(ApplicationId.newInstance(12345,1),2),3));
    AllocateRequest allReq=(AllocateRequestPBImpl)factory.newRecordInstance(AllocateRequest.class);
    allReq.setAskList(Arrays.asList(ResourceRequest.newInstance(Priority.UNDEFINED,"a",Resource.newInstance(1,2),1,true,"exp",ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC,true))));
    OpportunisticContainerAllocatorAMService service=createService(factory,rmContext,c);
    conf.setBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,true);
    Server server=service.getServer(rpc,conf,addr,null);
    server.start();
    RPC.setProtocolEngine(conf,ApplicationMasterProtocolPB.class,ProtobufRpcEngine.class);
    ApplicationMasterProtocolPB ampProxy=RPC.getProxy(ApplicationMasterProtocolPB.class,1,NetUtils.getConnectAddress(server),conf);
    RegisterApplicationMasterResponse regResp=new RegisterApplicationMasterResponsePBImpl(ampProxy.registerApplicationMaster(null,((RegisterApplicationMasterRequestPBImpl)factory.newRecordInstance(RegisterApplicationMasterRequest.class)).getProto()));
    Assert.assertEquals("dummyQueue",regResp.getQueue());
    FinishApplicationMasterResponse finishResp=new FinishApplicationMasterResponsePBImpl(ampProxy.finishApplicationMaster(null,((FinishApplicationMasterRequestPBImpl)factory.newRecordInstance(FinishApplicationMasterRequest.class)).getProto()));
    Assert.assertEquals(false,finishResp.getIsUnregistered());
    AllocateResponse allocResp=new AllocateResponsePBImpl(ampProxy.allocate(null,((AllocateRequestPBImpl)factory.newRecordInstance(AllocateRequest.class)).getProto()));
    List<Container> allocatedContainers=allocResp.getAllocatedContainers();
    Assert.assertEquals(1,allocatedContainers.size());
    Assert.assertEquals(ExecutionType.OPPORTUNISTIC,allocatedContainers.get(0).getExecutionType());
    Assert.assertEquals(12345,allocResp.getNumClusterNodes());
    RPC.setProtocolEngine(conf,DistributedSchedulingAMProtocolPB.class,ProtobufRpcEngine.class);
    DistributedSchedulingAMProtocolPB dsProxy=RPC.getProxy(DistributedSchedulingAMProtocolPB.class,1,NetUtils.getConnectAddress(server),conf);
    RegisterDistributedSchedulingAMResponse dsRegResp=new RegisterDistributedSchedulingAMResponsePBImpl(dsProxy.registerApplicationMasterForDistributedScheduling(null,((RegisterApplicationMasterRequestPBImpl)factory.newRecordInstance(RegisterApplicationMasterRequest.class)).getProto()));
    Assert.assertEquals(54321l,dsRegResp.getContainerIdStart());
    Assert.assertEquals(4,dsRegResp.getMaxContainerResource().getVirtualCores());
    Assert.assertEquals(1024,dsRegResp.getMinContainerResource().getMemorySize());
    Assert.assertEquals(2,dsRegResp.getIncrContainerResource().getVirtualCores());
    DistributedSchedulingAllocateRequestPBImpl distAllReq=(DistributedSchedulingAllocateRequestPBImpl)factory.newRecordInstance(DistributedSchedulingAllocateRequest.class);
    distAllReq.setAllocateRequest(allReq);
    distAllReq.setAllocatedContainers(Arrays.asList(c));
    DistributedSchedulingAllocateResponse dsAllocResp=new DistributedSchedulingAllocateResponsePBImpl(dsProxy.allocateForDistributedScheduling(null,distAllReq.getProto()));
    Assert.assertEquals("h1",dsAllocResp.getNodesForScheduling().get(0).getNodeId().getHost());
    FinishApplicationMasterResponse dsfinishResp=new FinishApplicationMasterResponsePBImpl(dsProxy.finishApplicationMaster(null,((FinishApplicationMasterRequestPBImpl)factory.newRecordInstance(FinishApplicationMasterRequest.class)).getProto()));
    Assert.assertEquals(false,dsfinishResp.getIsUnregistered());
  }
  private OpportunisticContainerAllocatorAMService createService(  final RecordFactory factory,  final RMContext rmContext,  final Container c){
    return new OpportunisticContainerAllocatorAMService(rmContext,null){
      @Override public RegisterApplicationMasterResponse registerApplicationMaster(      RegisterApplicationMasterRequest request) throws YarnException, IOException {
        RegisterApplicationMasterResponse resp=factory.newRecordInstance(RegisterApplicationMasterResponse.class);
        resp.setQueue("dummyQueue");
        return resp;
      }
      @Override public FinishApplicationMasterResponse finishApplicationMaster(      FinishApplicationMasterRequest request) throws YarnException, IOException {
        FinishApplicationMasterResponse resp=factory.newRecordInstance(FinishApplicationMasterResponse.class);
        resp.setIsUnregistered(false);
        return resp;
      }
      @Override public AllocateResponse allocate(      AllocateRequest request) throws YarnException, IOException {
        AllocateResponse response=factory.newRecordInstance(AllocateResponse.class);
        response.setNumClusterNodes(12345);
        response.setAllocatedContainers(Arrays.asList(c));
        return response;
      }
      @Override public RegisterDistributedSchedulingAMResponse registerApplicationMasterForDistributedScheduling(      RegisterApplicationMasterRequest request) throws YarnException, IOException {
        RegisterDistributedSchedulingAMResponse resp=factory.newRecordInstance(RegisterDistributedSchedulingAMResponse.class);
        resp.setContainerIdStart(54321L);
        resp.setMaxContainerResource(Resource.newInstance(4096,4));
        resp.setMinContainerResource(Resource.newInstance(1024,1));
        resp.setIncrContainerResource(Resource.newInstance(2048,2));
        return resp;
      }
      @Override public DistributedSchedulingAllocateResponse allocateForDistributedScheduling(      DistributedSchedulingAllocateRequest request) throws YarnException, IOException {
        List<ResourceRequest> askList=request.getAllocateRequest().getAskList();
        List<Container> allocatedContainers=request.getAllocatedContainers();
        Assert.assertEquals(1,allocatedContainers.size());
        Assert.assertEquals(ExecutionType.OPPORTUNISTIC,allocatedContainers.get(0).getExecutionType());
        Assert.assertEquals(1,askList.size());
        Assert.assertTrue(askList.get(0).getExecutionTypeRequest().getEnforceExecutionType());
        DistributedSchedulingAllocateResponse resp=factory.newRecordInstance(DistributedSchedulingAllocateResponse.class);
        resp.setNodesForScheduling(Arrays.asList(RemoteNode.newInstance(NodeId.newInstance("h1",1234),"http://h1:4321")));
        return resp;
      }
    }
;
  }
}
