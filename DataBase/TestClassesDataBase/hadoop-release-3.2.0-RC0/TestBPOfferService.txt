public class TestBPOfferService {
  private static final String FAKE_BPID="fake bpid";
  private static final String FAKE_CLUSTERID="fake cluster";
  protected static final Logger LOG=LoggerFactory.getLogger(TestBPOfferService.class);
  private static final ExtendedBlock FAKE_BLOCK=new ExtendedBlock(FAKE_BPID,12345L);
  private static final File TEST_BUILD_DATA=PathUtils.getTestDir(TestBPOfferService.class);
  private long firstCallTime=0;
  private long secondCallTime=0;
static {
    GenericTestUtils.setLogLevel(DataNode.LOG,Level.ALL);
  }
  private DatanodeProtocolClientSideTranslatorPB mockNN1;
  private DatanodeProtocolClientSideTranslatorPB mockNN2;
  private final NNHAStatusHeartbeat[] mockHaStatuses=new NNHAStatusHeartbeat[3];
  private final DatanodeCommand[][] datanodeCommands=new DatanodeCommand[3][0];
  private final int[] heartbeatCounts=new int[3];
  private DataNode mockDn;
  private FsDatasetSpi<?> mockFSDataset;
  @Before public void setupMocks() throws Exception {
    mockNN1=setupNNMock(0);
    mockNN2=setupNNMock(1);
    mockDn=Mockito.mock(DataNode.class);
    Mockito.doReturn(true).when(mockDn).shouldRun();
    Configuration conf=new Configuration();
    File dnDataDir=new File(new File(TEST_BUILD_DATA,"dfs"),"data");
    conf.set(DFS_DATANODE_DATA_DIR_KEY,dnDataDir.toURI().toString());
    Mockito.doReturn(conf).when(mockDn).getConf();
    Mockito.doReturn(new DNConf(mockDn)).when(mockDn).getDnConf();
    Mockito.doReturn(DataNodeMetrics.create(conf,"fake dn")).when(mockDn).getMetrics();
    mockFSDataset=Mockito.spy(new SimulatedFSDataset(null,conf));
    mockFSDataset.addBlockPool(FAKE_BPID,conf);
    Mockito.doReturn(mockFSDataset).when(mockDn).getFSDataset();
  }
  /** 
 * Set up a mock NN with the bare minimum for a DN to register to it.
 */
  private DatanodeProtocolClientSideTranslatorPB setupNNMock(  int nnIdx) throws Exception {
    DatanodeProtocolClientSideTranslatorPB mock=Mockito.mock(DatanodeProtocolClientSideTranslatorPB.class);
    Mockito.doReturn(new NamespaceInfo(1,FAKE_CLUSTERID,FAKE_BPID,0)).when(mock).versionRequest();
    Mockito.doReturn(DFSTestUtil.getLocalDatanodeRegistration()).when(mock).registerDatanode(Mockito.any(DatanodeRegistration.class));
    Mockito.doAnswer(new HeartbeatAnswer(nnIdx)).when(mock).sendHeartbeat(Mockito.any(DatanodeRegistration.class),Mockito.any(StorageReport[].class),Mockito.anyLong(),Mockito.anyLong(),Mockito.anyInt(),Mockito.anyInt(),Mockito.anyInt(),Mockito.any(VolumeFailureSummary.class),Mockito.anyBoolean(),Mockito.any(SlowPeerReports.class),Mockito.any(SlowDiskReports.class));
    mockHaStatuses[nnIdx]=new NNHAStatusHeartbeat(HAServiceState.STANDBY,0);
    datanodeCommands[nnIdx]=new DatanodeCommand[0];
    return mock;
  }
  /** 
 * Mock answer for heartbeats which returns an empty set of commands and the HA status for the chosen NN from the {@link TestBPOfferService#mockHaStatuses} array.
 */
private class HeartbeatAnswer implements Answer<HeartbeatResponse> {
    private final int nnIdx;
    public HeartbeatAnswer(    int nnIdx){
      this.nnIdx=nnIdx;
    }
    @Override public HeartbeatResponse answer(    InvocationOnMock invocation) throws Throwable {
      heartbeatCounts[nnIdx]++;
      HeartbeatResponse heartbeatResponse=new HeartbeatResponse(datanodeCommands[nnIdx],mockHaStatuses[nnIdx],null,ThreadLocalRandom.current().nextLong() | 1L);
      datanodeCommands[nnIdx]=new DatanodeCommand[0];
      return heartbeatResponse;
    }
  }
  /** 
 * Test that the BPOS can register to talk to two different NNs, sends block reports to both, etc.
 */
  @Test public void testBasicFunctionality() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForBothActors(bpos);
      Mockito.verify(mockNN1).registerDatanode(Mockito.any(DatanodeRegistration.class));
      Mockito.verify(mockNN2).registerDatanode(Mockito.any(DatanodeRegistration.class));
      waitForBlockReport(mockNN1);
      waitForBlockReport(mockNN2);
      bpos.notifyNamenodeReceivedBlock(FAKE_BLOCK,null,"",false);
      ReceivedDeletedBlockInfo[] ret=waitForBlockReceived(FAKE_BLOCK,mockNN1);
      assertEquals(1,ret.length);
      assertEquals(FAKE_BLOCK.getLocalBlock(),ret[0].getBlock());
      ret=waitForBlockReceived(FAKE_BLOCK,mockNN2);
      assertEquals(1,ret.length);
      assertEquals(FAKE_BLOCK.getLocalBlock(),ret[0].getBlock());
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  @Test public void testLocklessBlockPoolId() throws Exception {
    BPOfferService bpos=Mockito.spy(setupBPOSForNNs(mockNN1));
    assertNull(bpos.getBlockPoolId());
    Mockito.verify(bpos).readLock();
    Mockito.reset(bpos);
    NamespaceInfo nsInfo=new NamespaceInfo(1,FAKE_CLUSTERID,FAKE_BPID,0);
    assertNull(bpos.setNamespaceInfo(nsInfo));
    assertEquals(FAKE_BPID,bpos.getBlockPoolId());
    Mockito.verify(bpos,Mockito.never()).readLock();
    Mockito.reset(bpos);
    assertEquals(nsInfo,bpos.setNamespaceInfo(null));
    assertNull(bpos.getBlockPoolId());
    Mockito.verify(bpos).readLock();
    Mockito.reset(bpos);
    assertNull(bpos.setNamespaceInfo(nsInfo));
    assertEquals(FAKE_BPID,bpos.getBlockPoolId());
    Mockito.verify(bpos,Mockito.never()).readLock();
  }
  /** 
 * Test that DNA_INVALIDATE commands from the standby are ignored.
 */
  @Test public void testIgnoreDeletionsFromNonActive() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    Mockito.doReturn(new BlockCommand(DatanodeProtocol.DNA_INVALIDATE,FAKE_BPID,new Block[]{FAKE_BLOCK.getLocalBlock()})).when(mockNN2).blockReport(Mockito.<DatanodeRegistration>anyObject(),Mockito.eq(FAKE_BPID),Mockito.<StorageBlockReport[]>anyObject(),Mockito.<BlockReportContext>anyObject());
    bpos.start();
    try {
      waitForInitialization(bpos);
      waitForBlockReport(mockNN1);
      waitForBlockReport(mockNN2);
    }
  finally {
      bpos.stop();
      bpos.join();
    }
    Mockito.verify(mockFSDataset,Mockito.never()).invalidate(Mockito.eq(FAKE_BPID),(Block[])Mockito.anyObject());
  }
  /** 
 * Ensure that, if the two NNs configured for a block pool have different block pool IDs, they will refuse to both register.
 */
  @Test public void testNNsFromDifferentClusters() throws Exception {
    Mockito.doReturn(new NamespaceInfo(1,"fake foreign cluster",FAKE_BPID,0)).when(mockNN1).versionRequest();
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForOneToFail(bpos);
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  /** 
 * Test that the DataNode determines the active NameNode correctly based on the HA-related information in heartbeat responses. See HDFS-2627.
 */
  @Test public void testPickActiveNameNode() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      assertNull(bpos.getActiveNN());
      mockHaStatuses[0]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,1);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN1,bpos.getActiveNN());
      mockHaStatuses[1]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,2);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN2,bpos.getActiveNN());
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN2,bpos.getActiveNN());
      mockHaStatuses[1]=new NNHAStatusHeartbeat(HAServiceState.STANDBY,2);
      bpos.triggerHeartbeatForTests();
      assertNull(bpos.getActiveNN());
      mockHaStatuses[0]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,3);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN1,bpos.getActiveNN());
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  /** 
 * Test datanode block pool initialization error handling. Failure in initializing a block pool should not cause NPE.
 */
  @Test public void testBPInitErrorHandling() throws Exception {
    final DataNode mockDn=Mockito.mock(DataNode.class);
    Mockito.doReturn(true).when(mockDn).shouldRun();
    Configuration conf=new Configuration();
    File dnDataDir=new File(new File(TEST_BUILD_DATA,"testBPInitErrorHandling"),"data");
    conf.set(DFS_DATANODE_DATA_DIR_KEY,dnDataDir.toURI().toString());
    Mockito.doReturn(conf).when(mockDn).getConf();
    Mockito.doReturn(new DNConf(mockDn)).when(mockDn).getDnConf();
    Mockito.doReturn(DataNodeMetrics.create(conf,"fake dn")).when(mockDn).getMetrics();
    final AtomicInteger count=new AtomicInteger();
    Mockito.doAnswer(new Answer<Void>(){
      @Override public Void answer(      InvocationOnMock invocation) throws Throwable {
        if (count.getAndIncrement() == 0) {
          throw new IOException("faked initBlockPool exception");
        }
        Mockito.doReturn(mockFSDataset).when(mockDn).getFSDataset();
        return null;
      }
    }
).when(mockDn).initBlockPool(Mockito.any(BPOfferService.class));
    BPOfferService bpos=setupBPOSForNNs(mockDn,mockNN1,mockNN2);
    List<BPServiceActor> actors=bpos.getBPServiceActors();
    assertEquals(2,actors.size());
    bpos.start();
    try {
      waitForInitialization(bpos);
      waitForBlockReport(mockNN1,mockNN2);
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  private void waitForOneToFail(  final BPOfferService bpos) throws Exception {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        List<BPServiceActor> actors=bpos.getBPServiceActors();
        int failedcount=0;
        for (        BPServiceActor actor : actors) {
          if (!actor.isAlive()) {
            failedcount++;
          }
        }
        return failedcount == 1;
      }
    }
,100,10000);
  }
  /** 
 * Create a BPOfferService which registers with and heartbeats with the specified namenode proxy objects.
 * @throws IOException 
 */
  private BPOfferService setupBPOSForNNs(  DatanodeProtocolClientSideTranslatorPB... nns) throws IOException {
    return setupBPOSForNNs(mockDn,nns);
  }
  private BPOfferService setupBPOSForNNs(  DataNode mockDn,  DatanodeProtocolClientSideTranslatorPB... nns) throws IOException {
    final Map<InetSocketAddress,DatanodeProtocolClientSideTranslatorPB> nnMap=Maps.newLinkedHashMap();
    for (int port=0; port < nns.length; port++) {
      nnMap.put(new InetSocketAddress(port),nns[port]);
      Mockito.doReturn(nns[port]).when(mockDn).connectToNN(Mockito.eq(new InetSocketAddress(port)));
    }
    return new BPOfferService("test_ns",Lists.newArrayList(nnMap.keySet()),Collections.<InetSocketAddress>nCopies(nnMap.size(),null),mockDn);
  }
  private void waitForInitialization(  final BPOfferService bpos) throws Exception {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return bpos.isAlive() && bpos.isInitialized();
      }
    }
,100,10000);
  }
  private void waitForBothActors(  final BPOfferService bpos) throws Exception {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        List<BPServiceActor> actors=bpos.getBPServiceActors();
        return bpos.isAlive() && getRegisteredActors(actors) == 2;
      }
      private int getRegisteredActors(      List<BPServiceActor> actors){
        int regActors=0;
        for (        BPServiceActor actor : actors) {
          if (actor.getBpRegistration() != null) {
            regActors++;
          }
        }
        return regActors;
      }
    }
,100,10000);
  }
  private void waitForBlockReport(  final DatanodeProtocolClientSideTranslatorPB mockNN) throws Exception {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        try {
          Mockito.verify(mockNN).blockReport(Mockito.<DatanodeRegistration>anyObject(),Mockito.eq(FAKE_BPID),Mockito.<StorageBlockReport[]>anyObject(),Mockito.<BlockReportContext>anyObject());
          return true;
        }
 catch (        Throwable t) {
          LOG.info("waiting on block report: " + t.getMessage());
          return false;
        }
      }
    }
,500,10000);
  }
  private void waitForBlockReport(  final DatanodeProtocolClientSideTranslatorPB mockNN1,  final DatanodeProtocolClientSideTranslatorPB mockNN2) throws Exception {
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        return get(mockNN1) || get(mockNN2);
      }
      private Boolean get(      DatanodeProtocolClientSideTranslatorPB mockNN){
        try {
          Mockito.verify(mockNN).blockReport(Mockito.<DatanodeRegistration>anyObject(),Mockito.eq(FAKE_BPID),Mockito.<StorageBlockReport[]>anyObject(),Mockito.<BlockReportContext>anyObject());
          return true;
        }
 catch (        Throwable t) {
          LOG.info("waiting on block report: " + t.getMessage());
          return false;
        }
      }
    }
,500,10000);
  }
  private ReceivedDeletedBlockInfo[] waitForBlockReceived(  final ExtendedBlock fakeBlock,  final DatanodeProtocolClientSideTranslatorPB mockNN) throws Exception {
    final String fakeBlockPoolId=fakeBlock.getBlockPoolId();
    final ArgumentCaptor<StorageReceivedDeletedBlocks[]> captor=ArgumentCaptor.forClass(StorageReceivedDeletedBlocks[].class);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      @Override public Boolean get(){
        try {
          Mockito.verify(mockNN).blockReceivedAndDeleted(Mockito.<DatanodeRegistration>anyObject(),Mockito.eq(fakeBlockPoolId),captor.capture());
          return true;
        }
 catch (        Throwable t) {
          return false;
        }
      }
    }
,100,10000);
    return captor.getValue()[0].getBlocks();
  }
  private void setTimeForSynchronousBPOSCalls(){
    if (firstCallTime == 0) {
      firstCallTime=Time.now();
    }
 else {
      secondCallTime=Time.now();
    }
  }
private class BPOfferServiceSynchronousCallAnswer implements Answer<Void> {
    private final int nnIdx;
    public BPOfferServiceSynchronousCallAnswer(    int nnIdx){
      this.nnIdx=nnIdx;
    }
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      if (nnIdx == 0) {
        setTimeForSynchronousBPOSCalls();
      }
 else {
        Thread.sleep(5000);
      }
      return null;
    }
  }
  /** 
 * This test case test the  {@link BPOfferService#reportBadBlocks} methodsuch that if call to standby namenode times out then that should not  affect the active namenode heartbeat processing since this function  are in writeLock.
 * @throws Exception
 */
  @Test public void testReportBadBlockWhenStandbyNNTimesOut() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      assertNull(bpos.getActiveNN());
      mockHaStatuses[0]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,1);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN1,bpos.getActiveNN());
      Mockito.doAnswer(new BPOfferServiceSynchronousCallAnswer(0)).when(mockNN1).reportBadBlocks(Mockito.any(LocatedBlock[].class));
      Mockito.doAnswer(new BPOfferServiceSynchronousCallAnswer(1)).when(mockNN2).reportBadBlocks(Mockito.any(LocatedBlock[].class));
      bpos.reportBadBlocks(FAKE_BLOCK,mockFSDataset.getVolume(FAKE_BLOCK).getStorageID(),mockFSDataset.getVolume(FAKE_BLOCK).getStorageType());
      bpos.reportBadBlocks(FAKE_BLOCK,mockFSDataset.getVolume(FAKE_BLOCK).getStorageID(),mockFSDataset.getVolume(FAKE_BLOCK).getStorageType());
      Thread.sleep(10000);
      long difference=secondCallTime - firstCallTime;
      assertTrue("Active namenode reportBadBlock processing should be " + "independent of standby namenode reportBadBlock processing ",difference < 5000);
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  /** 
 * This test case test the  {@link BPOfferService#trySendErrorReport} methodsuch that if call to standby namenode times out then that should not  affect the active namenode heartbeat processing since this function  are in writeLock.
 * @throws Exception
 */
  @Test public void testTrySendErrorReportWhenStandbyNNTimesOut() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      assertNull(bpos.getActiveNN());
      mockHaStatuses[0]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,1);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN1,bpos.getActiveNN());
      Mockito.doAnswer(new BPOfferServiceSynchronousCallAnswer(0)).when(mockNN1).errorReport(Mockito.any(DatanodeRegistration.class),Mockito.anyInt(),Mockito.anyString());
      Mockito.doAnswer(new BPOfferServiceSynchronousCallAnswer(1)).when(mockNN2).errorReport(Mockito.any(DatanodeRegistration.class),Mockito.anyInt(),Mockito.anyString());
      String errorString="Can't send invalid block " + FAKE_BLOCK;
      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK,errorString);
      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK,errorString);
      Thread.sleep(10000);
      long difference=secondCallTime - firstCallTime;
      assertTrue("Active namenode trySendErrorReport processing " + "should be independent of standby namenode trySendErrorReport" + " processing ",difference < 5000);
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  /** 
 * This test case tests whether the  {@BPServiceActor #processQueueMessages}adds back the error report back to the queue when  {BPServiceActorAction#reportTo} throws an IOException
 * @throws Exception
 */
  @Test public void testTrySendErrorReportWhenNNThrowsIOException() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      assertNull(bpos.getActiveNN());
      mockHaStatuses[0]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,1);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN1,bpos.getActiveNN());
      Mockito.doAnswer(new Answer<Void>(){
        @Override public Void answer(        InvocationOnMock invocation) throws Throwable {
          if (firstCallTime == 0) {
            firstCallTime=Time.now();
            throw new IOException();
          }
 else {
            secondCallTime=Time.now();
            return null;
          }
        }
      }
).when(mockNN1).errorReport(Mockito.any(DatanodeRegistration.class),Mockito.anyInt(),Mockito.anyString());
      String errorString="Can't send invalid block " + FAKE_BLOCK;
      bpos.trySendErrorReport(DatanodeProtocol.INVALID_BLOCK,errorString);
      Thread.sleep(10000);
      assertTrue("Active namenode didn't add the report back to the queue " + "when errorReport threw IOException",secondCallTime != 0);
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  /** 
 * This test case doesn't add the reportBadBlock request to {@link BPServiceActor#bpThreadEnqueue} when the Standby namenode throws{@link StandbyException}
 * @throws Exception
 */
  @Test public void testReportBadBlocksWhenNNThrowsStandbyException() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      assertNull(bpos.getActiveNN());
      mockHaStatuses[0]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,1);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN1,bpos.getActiveNN());
      Mockito.doNothing().when(mockNN1).reportBadBlocks(Mockito.any(LocatedBlock[].class));
      RemoteException re=new RemoteException(StandbyException.class.getName(),"Operation category WRITE is not supported in state " + "standby",RpcErrorCodeProto.ERROR_APPLICATION);
      Mockito.doThrow(re).when(mockNN2).reportBadBlocks(Mockito.any(LocatedBlock[].class));
      bpos.reportBadBlocks(FAKE_BLOCK,mockFSDataset.getVolume(FAKE_BLOCK).getStorageID(),mockFSDataset.getVolume(FAKE_BLOCK).getStorageType());
      bpos.triggerHeartbeatForTests();
      Mockito.verify(mockNN2,Mockito.times(1)).reportBadBlocks(Mockito.any(LocatedBlock[].class));
      bpos.triggerHeartbeatForTests();
      Mockito.verify(mockNN2,Mockito.times(1)).reportBadBlocks(Mockito.any(LocatedBlock[].class));
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  @Test public void testIBRClearanceForStandbyOnReRegister() throws Exception {
    final BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    bpos.start();
    try {
      waitForInitialization(bpos);
      assertNull(bpos.getActiveNN());
      mockHaStatuses[0]=new NNHAStatusHeartbeat(HAServiceState.ACTIVE,1);
      bpos.triggerHeartbeatForTests();
      assertSame(mockNN1,bpos.getActiveNN());
      Mockito.doNothing().when(mockNN1).blockReceivedAndDeleted(Mockito.any(DatanodeRegistration.class),Mockito.anyString(),Mockito.any(StorageReceivedDeletedBlocks[].class));
      final IOException re=new IOException("Standby NN is currently not able to process IBR");
      final AtomicBoolean ibrReported=new AtomicBoolean(false);
      Mockito.doAnswer(new Answer<Void>(){
        @Override public Void answer(        InvocationOnMock invocation) throws Throwable {
          ibrReported.set(true);
          throw re;
        }
      }
).when(mockNN2).blockReceivedAndDeleted(Mockito.any(DatanodeRegistration.class),Mockito.anyString(),Mockito.any(StorageReceivedDeletedBlocks[].class));
      DatanodeStorage storage=Mockito.mock(DatanodeStorage.class);
      Mockito.doReturn(storage).when(mockFSDataset).getStorage("storage0");
      bpos.notifyNamenodeReceivedBlock(FAKE_BLOCK,null,"storage0",false);
      bpos.triggerHeartbeatForTests();
      GenericTestUtils.waitFor(new Supplier<Boolean>(){
        @Override public Boolean get(){
          return ibrReported.get();
        }
      }
,100,1000);
      datanodeCommands[1]=new DatanodeCommand[]{new RegisterCommand()};
      assertEquals("IBR size before reRegister should be non-0",1,getStandbyIBRSize(bpos));
      bpos.triggerHeartbeatForTests();
      GenericTestUtils.waitFor(new Supplier<Boolean>(){
        @Override public Boolean get(){
          return getStandbyIBRSize(bpos) == 0;
        }
      }
,100,1000);
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
  private int getStandbyIBRSize(  BPOfferService bpos){
    List<BPServiceActor> bpServiceActors=bpos.getBPServiceActors();
    for (    BPServiceActor bpServiceActor : bpServiceActors) {
      if (bpServiceActor.state == HAServiceState.STANDBY) {
        return bpServiceActor.getIbrManager().getPendingIBRSize();
      }
    }
    return -1;
  }
  @Test public void testNNHAStateUpdateFromVersionRequest() throws Exception {
    final BPOfferService bpos=setupBPOSForNNs(mockNN1,mockNN2);
    Mockito.doReturn(true).when(mockDn).areHeartbeatsDisabledForTests();
    BPServiceActor actor=bpos.getBPServiceActors().get(0);
    bpos.start();
    waitForInitialization(bpos);
    assertNull(bpos.getActiveNN());
    NamespaceInfo nsInfo=mockNN1.versionRequest();
    bpos.verifyAndSetNamespaceInfo(actor,nsInfo);
    assertNull(bpos.getActiveNN());
    Mockito.doReturn(new NamespaceInfo(1,FAKE_CLUSTERID,FAKE_BPID,0,HAServiceState.ACTIVE)).when(mockNN1).versionRequest();
    nsInfo=mockNN1.versionRequest();
    bpos.verifyAndSetNamespaceInfo(actor,nsInfo);
    assertNotNull(bpos.getActiveNN());
  }
  @Test public void testRefreshNameNodes() throws Exception {
    BPOfferService bpos=setupBPOSForNNs(mockDn,mockNN1,mockNN2);
    bpos.start();
    try {
      waitForBothActors(bpos);
      Mockito.verify(mockNN1).registerDatanode(Mockito.any(DatanodeRegistration.class));
      Mockito.verify(mockNN2).registerDatanode(Mockito.any(DatanodeRegistration.class));
      waitForBlockReport(mockNN1);
      waitForBlockReport(mockNN2);
      bpos.notifyNamenodeReceivedBlock(FAKE_BLOCK,null,"",false);
      ReceivedDeletedBlockInfo[] ret=waitForBlockReceived(FAKE_BLOCK,mockNN1);
      assertEquals(1,ret.length);
      assertEquals(FAKE_BLOCK.getLocalBlock(),ret[0].getBlock());
      ret=waitForBlockReceived(FAKE_BLOCK,mockNN2);
      assertEquals(1,ret.length);
      assertEquals(FAKE_BLOCK.getLocalBlock(),ret[0].getBlock());
      DatanodeProtocolClientSideTranslatorPB mockNN3=setupNNMock(2);
      Mockito.doReturn(mockNN3).when(mockDn).connectToNN(Mockito.eq(new InetSocketAddress(2)));
      ArrayList<InetSocketAddress> addrs=new ArrayList<>();
      ArrayList<InetSocketAddress> lifelineAddrs=new ArrayList<>(addrs.size());
      addrs.add(new InetSocketAddress(0));
      lifelineAddrs.add(null);
      addrs.add(new InetSocketAddress(2));
      lifelineAddrs.add(null);
      bpos.refreshNNList(addrs,lifelineAddrs);
      assertEquals(2,bpos.getBPServiceActors().size());
      Thread.sleep(1000);
      Mockito.verify(mockNN3).registerDatanode(Mockito.any(DatanodeRegistration.class));
      bpos.notifyNamenodeReceivedBlock(FAKE_BLOCK,null,"",false);
      ret=waitForBlockReceived(FAKE_BLOCK,mockNN3);
      assertEquals(1,ret.length);
      assertEquals(FAKE_BLOCK.getLocalBlock(),ret[0].getBlock());
    }
  finally {
      bpos.stop();
      bpos.join();
    }
  }
}
