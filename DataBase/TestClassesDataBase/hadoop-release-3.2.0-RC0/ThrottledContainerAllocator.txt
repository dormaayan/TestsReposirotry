class ThrottledContainerAllocator extends AbstractService implements ContainerAllocator, RMHeartbeatHandler {
  private int containerCount;
  private Thread thread;
  private BlockingQueue<ContainerAllocatorEvent> eventQueue=new LinkedBlockingQueue<ContainerAllocatorEvent>();
  public ThrottledContainerAllocator(){
    super("ThrottledContainerAllocator");
  }
  @Override public void handle(  ContainerAllocatorEvent event){
    try {
      eventQueue.put(event);
    }
 catch (    InterruptedException e) {
      throw new YarnRuntimeException(e);
    }
  }
  @Override protected void serviceStart() throws Exception {
    thread=new Thread(new Runnable(){
      @Override @SuppressWarnings("unchecked") public void run(){
        ContainerAllocatorEvent event=null;
        while (!Thread.currentThread().isInterrupted()) {
          try {
            if (concurrentRunningTasks < maxConcurrentRunningTasks) {
              event=eventQueue.take();
              ContainerId cId=ContainerId.newContainerId(getContext().getApplicationAttemptId(),containerCount++);
              Container container=recordFactory.newRecordInstance(Container.class);
              container.setId(cId);
              NodeId nodeId=NodeId.newInstance("dummy",1234);
              container.setNodeId(nodeId);
              container.setContainerToken(null);
              container.setNodeHttpAddress("localhost:8042");
              getContext().getEventHandler().handle(new TaskAttemptContainerAssignedEvent(event.getAttemptID(),container,null));
              concurrentRunningTasks++;
            }
 else {
              Thread.sleep(1000);
            }
          }
 catch (          InterruptedException e) {
            System.out.println("Returning, interrupted");
            return;
          }
        }
      }
    }
);
    thread.start();
    super.serviceStart();
  }
  @Override protected void serviceStop() throws Exception {
    if (thread != null) {
      thread.interrupt();
    }
    super.serviceStop();
  }
  @Override public long getLastHeartbeatTime(){
    return Time.now();
  }
  @Override public void runOnNextHeartbeat(  Runnable callback){
  }
}
