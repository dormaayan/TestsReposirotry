/** 
 * This test class checks basic operations with  {@link HarFileSystem} includingvarious initialization cases, getters, and modification methods. NB: to run this test from an IDE make sure the folder "hadoop-common-project/hadoop-common/src/main/resources/" is added as a source path. This will allow the system to pick up the "core-default.xml" and "META-INF/services/..." resources from the class-path in the runtime.
 */
public class TestHarFileSystemBasics {
  private static final String ROOT_PATH=GenericTestUtils.getTempPath("testharfilesystembasics");
  private static final Path rootPath;
static {
    String root=new Path(new File(ROOT_PATH).getAbsolutePath(),"localfs").toUri().getPath();
    if (Shell.WINDOWS) {
      root=root.substring(root.indexOf(':') + 1);
    }
    rootPath=new Path(root);
  }
  private static final Path harPath=new Path(rootPath,"path1/path2/my.har");
  private FileSystem localFileSystem;
  private HarFileSystem harFileSystem;
  private Configuration conf;
  private HarFileSystem createHarFileSystem(  final Configuration conf) throws Exception {
    localFileSystem=FileSystem.getLocal(conf);
    localFileSystem.initialize(new URI("file:///"),conf);
    localFileSystem.mkdirs(rootPath);
    localFileSystem.mkdirs(harPath);
    final Path indexPath=new Path(harPath,"_index");
    final Path masterIndexPath=new Path(harPath,"_masterindex");
    localFileSystem.createNewFile(indexPath);
    assertTrue(localFileSystem.exists(indexPath));
    localFileSystem.createNewFile(masterIndexPath);
    assertTrue(localFileSystem.exists(masterIndexPath));
    writeVersionToMasterIndexImpl(HarFileSystem.VERSION,masterIndexPath);
    final HarFileSystem harFileSystem=new HarFileSystem(localFileSystem);
    final URI uri=new URI("har://" + harPath.toString());
    harFileSystem.initialize(uri,conf);
    return harFileSystem;
  }
  private HarFileSystem createHarFileSystem(  final Configuration conf,  Path aHarPath) throws Exception {
    localFileSystem.mkdirs(aHarPath);
    final Path indexPath=new Path(aHarPath,"_index");
    final Path masterIndexPath=new Path(aHarPath,"_masterindex");
    localFileSystem.createNewFile(indexPath);
    assertTrue(localFileSystem.exists(indexPath));
    localFileSystem.createNewFile(masterIndexPath);
    assertTrue(localFileSystem.exists(masterIndexPath));
    writeVersionToMasterIndexImpl(HarFileSystem.VERSION,masterIndexPath);
    final HarFileSystem harFileSystem=new HarFileSystem(localFileSystem);
    final URI uri=new URI("har://" + aHarPath.toString());
    harFileSystem.initialize(uri,conf);
    return harFileSystem;
  }
  private void writeVersionToMasterIndexImpl(  int version,  Path masterIndexPath) throws IOException {
    final FSDataOutputStream fsdos=localFileSystem.create(masterIndexPath);
    try {
      String versionString=version + "\n";
      fsdos.write(versionString.getBytes("UTF-8"));
      fsdos.flush();
    }
  finally {
      fsdos.close();
    }
  }
  @Before public void before() throws Exception {
    final File rootDirIoFile=new File(rootPath.toUri().getPath());
    rootDirIoFile.mkdirs();
    if (!rootDirIoFile.exists()) {
      throw new IOException("Failed to create temp directory [" + rootDirIoFile.getAbsolutePath() + "]");
    }
    conf=new Configuration();
    harFileSystem=createHarFileSystem(conf);
  }
  @After public void after() throws Exception {
    final FileSystem harFS=harFileSystem;
    if (harFS != null) {
      harFS.close();
      harFileSystem=null;
    }
    final File rootDirIoFile=new File(rootPath.toUri().getPath());
    if (rootDirIoFile.exists()) {
      FileUtil.fullyDelete(rootDirIoFile);
    }
    if (rootDirIoFile.exists()) {
      throw new IOException("Failed to delete temp directory [" + rootDirIoFile.getAbsolutePath() + "]");
    }
  }
  @Test public void testPositiveHarFileSystemBasics() throws Exception {
    assertEquals(HarFileSystem.VERSION,harFileSystem.getHarVersion());
    final URI harUri=harFileSystem.getUri();
    assertEquals(harPath.toUri().getPath(),harUri.getPath());
    assertEquals("har",harUri.getScheme());
    final Path homePath=harFileSystem.getHomeDirectory();
    assertEquals(harPath.toUri().getPath(),homePath.toUri().getPath());
    final Path workDirPath0=harFileSystem.getWorkingDirectory();
    assertEquals(homePath,workDirPath0);
    harFileSystem.setWorkingDirectory(new Path("/foo/bar"));
    assertEquals(workDirPath0,harFileSystem.getWorkingDirectory());
  }
  @Test public void testPositiveNewHarFsOnTheSameUnderlyingFs() throws Exception {
    final HarFileSystem hfs=new HarFileSystem(localFileSystem);
    final URI uri=new URI("har://" + harPath.toString());
    hfs.initialize(uri,new Configuration());
    assertTrue(hfs.getMetadata() == harFileSystem.getMetadata());
  }
  @Test public void testPositiveLruMetadataCacheFs() throws Exception {
    HarFileSystem hfs=new HarFileSystem(localFileSystem);
    URI uri=new URI("har://" + harPath.toString());
    hfs.initialize(uri,new Configuration());
    assertTrue(hfs.getMetadata() == harFileSystem.getMetadata());
    for (int i=0; i <= hfs.METADATA_CACHE_ENTRIES_DEFAULT; i++) {
      Path p=new Path(rootPath,"path1/path2/my" + i + ".har");
      createHarFileSystem(conf,p);
    }
    hfs=new HarFileSystem(localFileSystem);
    uri=new URI("har://" + harPath.toString());
    hfs.initialize(uri,new Configuration());
    assertTrue(hfs.getMetadata() != harFileSystem.getMetadata());
  }
  @Test public void testPositiveInitWithoutUnderlyingFS() throws Exception {
    final HarFileSystem hfs=new HarFileSystem();
    final URI uri=new URI("har://" + harPath.toString());
    hfs.initialize(uri,new Configuration());
  }
  @Test public void testPositiveListFilesNotEndInColon() throws Exception {
    final URI uri=new URI("har://file-localhost" + harPath.toString());
    harFileSystem.initialize(uri,conf);
    Path p1=new Path("har://file-localhost" + harPath.toString());
    Path p2=harFileSystem.makeQualified(p1);
    assertTrue(p2.toUri().toString().startsWith("har://file-localhost/"));
  }
  @Test public void testListLocatedStatus() throws Exception {
    String testHarPath=this.getClass().getResource("/test.har").getPath();
    URI uri=new URI("har://" + testHarPath);
    HarFileSystem hfs=new HarFileSystem(localFileSystem);
    hfs.initialize(uri,new Configuration());
    Set<String> expectedFileNames=new HashSet<String>();
    expectedFileNames.add("1.txt");
    expectedFileNames.add("2.txt");
    Path path=new Path("dir1");
    RemoteIterator<LocatedFileStatus> fileList=hfs.listLocatedStatus(path);
    while (fileList.hasNext()) {
      String fileName=fileList.next().getPath().getName();
      assertTrue(fileName + " not in expected files list",expectedFileNames.contains(fileName));
      expectedFileNames.remove(fileName);
    }
    assertEquals("Didn't find all of the expected file names: " + expectedFileNames,0,expectedFileNames.size());
  }
  @Test public void testMakeQualifiedPath() throws Exception {
    String harPathWithUserinfo="har://file-user:passwd@localhost:80" + harPath.toUri().getPath().toString();
    Path path=new Path(harPathWithUserinfo);
    Path qualifiedPath=path.getFileSystem(conf).makeQualified(path);
    assertTrue(String.format("The qualified path (%s) did not match the expected path (%s).",qualifiedPath.toString(),harPathWithUserinfo),qualifiedPath.toString().equals(harPathWithUserinfo));
  }
  @Test public void testNegativeInitWithoutIndex() throws Exception {
    final Path indexPath=new Path(harPath,"_index");
    localFileSystem.delete(indexPath,false);
    final HarFileSystem hfs=new HarFileSystem(localFileSystem);
    final URI uri=new URI("har://" + harPath.toString());
    try {
      hfs.initialize(uri,new Configuration());
      Assert.fail("Exception expected.");
    }
 catch (    IOException ioe) {
    }
  }
  @Test public void testNegativeGetHarVersionOnNotInitializedFS() throws Exception {
    final HarFileSystem hfs=new HarFileSystem(localFileSystem);
    try {
      int version=hfs.getHarVersion();
      Assert.fail("Exception expected, but got a Har version " + version + ".");
    }
 catch (    IOException ioe) {
    }
  }
  @Test public void testNegativeInitWithAnUnsupportedVersion() throws Exception {
    Thread.sleep(1000);
    writeVersionToMasterIndexImpl(7777,new Path(harPath,"_masterindex"));
    final HarFileSystem hfs=new HarFileSystem(localFileSystem);
    assertFalse(hfs.getMetadata() == harFileSystem.getMetadata());
    final URI uri=new URI("har://" + harPath.toString());
    try {
      hfs.initialize(uri,new Configuration());
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
  }
  @Test public void testNegativeHarFsModifications() throws Exception {
    final Path fooPath=new Path(rootPath,"foo/bar");
    localFileSystem.createNewFile(fooPath);
    try {
      harFileSystem.create(fooPath,new FsPermission("+rwx"),true,1024,(short)88,1024,null);
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    try {
      harFileSystem.setReplication(fooPath,(short)55);
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    try {
      harFileSystem.delete(fooPath,true);
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    try {
      harFileSystem.mkdirs(fooPath,new FsPermission("+rwx"));
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    final Path indexPath=new Path(harPath,"_index");
    try {
      harFileSystem.copyFromLocalFile(false,indexPath,fooPath);
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    try {
      harFileSystem.startLocalOutput(fooPath,indexPath);
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    try {
      harFileSystem.completeLocalOutput(fooPath,indexPath);
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    try {
      harFileSystem.setOwner(fooPath,"user","group");
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
    try {
      harFileSystem.setPermission(fooPath,new FsPermission("+x"));
      Assert.fail("IOException expected.");
    }
 catch (    IOException ioe) {
    }
  }
  @Test public void testHarFsWithoutAuthority() throws Exception {
    final URI uri=harFileSystem.getUri();
    Assert.assertNull("har uri authority not null: " + uri,uri.getAuthority());
    FileContext.getFileContext(uri,conf);
  }
}
