public class TestContainersMonitor extends BaseContainerManagerTest {
  public TestContainersMonitor() throws UnsupportedFileSystemException {
    super();
  }
static {
    LOG=LoggerFactory.getLogger(TestContainersMonitor.class);
  }
  @Before public void setup() throws IOException {
    conf.setClass(YarnConfiguration.NM_MON_RESOURCE_CALCULATOR,LinuxResourceCalculatorPlugin.class,ResourceCalculatorPlugin.class);
    conf.setBoolean(YarnConfiguration.NM_VMEM_CHECK_ENABLED,true);
    conf.setBoolean(YarnConfiguration.NM_MEMORY_RESOURCE_ENFORCED,false);
    super.setup();
  }
  @Test public void testMetricsUpdate() throws Exception {
    Context spyContext=spy(context);
    ContainersMonitorImpl cm=new ContainersMonitorImpl(mock(ContainerExecutor.class),mock(AsyncDispatcher.class),spyContext);
    cm.init(getConfForCM(false,true,1024,2.1f));
    cm.start();
    Mockito.verify(spyContext,timeout(500).atLeastOnce()).getNodeManagerMetrics();
  }
  /** 
 * Test to verify the check for whether a process tree is over limit or not.
 * @throws IOException if there was a problem setting up the fake procfs directories or files.
 */
  @Test public void testProcessTreeLimits() throws IOException {
    File procfsRootDir=new File(localDir,"proc");
    String[] pids={"100","200","300","400","500","600","700"};
    try {
      TestProcfsBasedProcessTree.setupProcfsRootDir(procfsRootDir);
      TestProcfsBasedProcessTree.setupPidDirs(procfsRootDir,pids);
      TestProcfsBasedProcessTree.ProcessStatInfo[] procs=new TestProcfsBasedProcessTree.ProcessStatInfo[7];
      procs[0]=new TestProcfsBasedProcessTree.ProcessStatInfo(new String[]{"100","proc1","1","100","100","100000"});
      procs[1]=new TestProcfsBasedProcessTree.ProcessStatInfo(new String[]{"200","proc2","1","200","200","200000"});
      procs[2]=new TestProcfsBasedProcessTree.ProcessStatInfo(new String[]{"300","proc3","200","200","200","300000"});
      procs[3]=new TestProcfsBasedProcessTree.ProcessStatInfo(new String[]{"400","proc4","200","200","200","400000"});
      procs[4]=new TestProcfsBasedProcessTree.ProcessStatInfo(new String[]{"500","proc5","100","100","100","1500000"});
      procs[5]=new TestProcfsBasedProcessTree.ProcessStatInfo(new String[]{"600","proc6","1","600","600","100000"});
      procs[6]=new TestProcfsBasedProcessTree.ProcessStatInfo(new String[]{"700","proc7","600","600","600","100000"});
      TestProcfsBasedProcessTree.writeStatFiles(procfsRootDir,pids,procs,null);
      long limit=700000;
      ContainersMonitorImpl test=new ContainersMonitorImpl(null,null,null);
      ProcfsBasedProcessTree pTree=new ProcfsBasedProcessTree("100",procfsRootDir.getAbsolutePath());
      pTree.updateProcessTree();
      assertTrue("tree rooted at 100 should be over limit " + "after first iteration.",test.isProcessTreeOverLimit(pTree,"dummyId",limit));
      pTree=new ProcfsBasedProcessTree("200",procfsRootDir.getAbsolutePath());
      pTree.updateProcessTree();
      assertFalse("tree rooted at 200 shouldn't be over limit " + "after one iteration.",test.isProcessTreeOverLimit(pTree,"dummyId",limit));
      pTree.updateProcessTree();
      assertTrue("tree rooted at 200 should be over limit after 2 iterations",test.isProcessTreeOverLimit(pTree,"dummyId",limit));
      pTree=new ProcfsBasedProcessTree("600",procfsRootDir.getAbsolutePath());
      pTree.updateProcessTree();
      assertFalse("tree rooted at 600 should never be over limit.",test.isProcessTreeOverLimit(pTree,"dummyId",limit));
      pTree.updateProcessTree();
      assertFalse("tree rooted at 600 should never be over limit.",test.isProcessTreeOverLimit(pTree,"dummyId",limit));
    }
  finally {
      FileUtil.fullyDelete(procfsRootDir);
    }
  }
  @Test public void testContainerMonitor() throws Exception {
    conf.setBoolean(YarnConfiguration.NM_VMEM_CHECK_ENABLED,false);
    conf.setBoolean(YarnConfiguration.NM_PMEM_CHECK_ENABLED,false);
    containerManager.start();
    ContainerLaunchContext context=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    context.setCommands(Arrays.asList("sleep 6"));
    ContainerId cId=createContainerId(1705);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(context,createContainerToken(cId,DUMMY_RM_IDENTIFIER,this.context.getNodeId(),user,this.context.getContainerTokenSecretManager()));
    StartContainersRequest allRequests=StartContainersRequest.newInstance(Arrays.asList(scRequest));
    containerManager.startContainers(allRequests);
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.RUNNING);
    Thread.sleep(2000);
    GenericTestUtils.waitFor(new Supplier<Boolean>(){
      public Boolean get(){
        try {
          return containerManager.getContainerStatuses(GetContainerStatusesRequest.newInstance(Arrays.asList(cId))).getContainerStatuses().get(0).getHost() != null;
        }
 catch (        Exception e) {
          return false;
        }
      }
    }
,300,10000);
  }
  @Test public void testContainerKillOnMemoryOverflow() throws IOException, InterruptedException, YarnException {
    if (!ProcfsBasedProcessTree.isAvailable()) {
      return;
    }
    containerManager.start();
    File scriptFile=new File(tmpDir,"scriptFile.sh");
    PrintWriter fileWriter=new PrintWriter(scriptFile);
    File processStartFile=new File(tmpDir,"start_file.txt").getAbsoluteFile();
    fileWriter.write("\numask 0");
    fileWriter.write("\necho Hello World! > " + processStartFile);
    fileWriter.write("\necho $$ >> " + processStartFile);
    fileWriter.write("\nsleep 15");
    fileWriter.close();
    ContainerLaunchContext containerLaunchContext=recordFactory.newRecordInstance(ContainerLaunchContext.class);
    ApplicationId appId=ApplicationId.newInstance(0,0);
    ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,1);
    ContainerId cId=ContainerId.newContainerId(appAttemptId,0);
    URL resource_alpha=URL.fromPath(localFS.makeQualified(new Path(scriptFile.getAbsolutePath())));
    LocalResource rsrc_alpha=recordFactory.newRecordInstance(LocalResource.class);
    rsrc_alpha.setResource(resource_alpha);
    rsrc_alpha.setSize(-1);
    rsrc_alpha.setVisibility(LocalResourceVisibility.APPLICATION);
    rsrc_alpha.setType(LocalResourceType.FILE);
    rsrc_alpha.setTimestamp(scriptFile.lastModified());
    String destinationFile="dest_file";
    Map<String,LocalResource> localResources=new HashMap<String,LocalResource>();
    localResources.put(destinationFile,rsrc_alpha);
    containerLaunchContext.setLocalResources(localResources);
    List<String> commands=new ArrayList<String>();
    commands.add("/bin/bash");
    commands.add(scriptFile.getAbsolutePath());
    containerLaunchContext.setCommands(commands);
    Resource r=BuilderUtils.newResource(0,0);
    ContainerTokenIdentifier containerIdentifier=new ContainerTokenIdentifier(cId,context.getNodeId().toString(),user,r,System.currentTimeMillis() + 120000,123,DUMMY_RM_IDENTIFIER,Priority.newInstance(0),0);
    Token containerToken=BuilderUtils.newContainerToken(context.getNodeId(),containerManager.getContext().getContainerTokenSecretManager().createPassword(containerIdentifier),containerIdentifier);
    StartContainerRequest scRequest=StartContainerRequest.newInstance(containerLaunchContext,containerToken);
    List<StartContainerRequest> list=new ArrayList<StartContainerRequest>();
    list.add(scRequest);
    StartContainersRequest allRequests=StartContainersRequest.newInstance(list);
    containerManager.startContainers(allRequests);
    int timeoutSecs=0;
    while (!processStartFile.exists() && timeoutSecs++ < 20) {
      Thread.sleep(1000);
      LOG.info("Waiting for process start-file to be created");
    }
    Assert.assertTrue("ProcessStartFile doesn't exist!",processStartFile.exists());
    BufferedReader reader=new BufferedReader(new FileReader(processStartFile));
    Assert.assertEquals("Hello World!",reader.readLine());
    String pid=reader.readLine().trim();
    Assert.assertEquals(null,reader.readLine());
    BaseContainerManagerTest.waitForContainerState(containerManager,cId,ContainerState.COMPLETE,60);
    List<ContainerId> containerIds=new ArrayList<ContainerId>();
    containerIds.add(cId);
    GetContainerStatusesRequest gcsRequest=GetContainerStatusesRequest.newInstance(containerIds);
    ContainerStatus containerStatus=containerManager.getContainerStatuses(gcsRequest).getContainerStatuses().get(0);
    Assert.assertEquals(ContainerExitStatus.KILLED_EXCEEDED_VMEM,containerStatus.getExitStatus());
    String expectedMsgPattern="Container \\[pid=" + pid + ",containerID="+ cId+ "\\] is running "+ "[0-9]+B beyond the 'VIRTUAL' memory limit. Current usage: "+ "[0-9.]+ ?[KMGTPE]?B of [0-9.]+ ?[KMGTPE]?B physical memory used; "+ "[0-9.]+ ?[KMGTPE]?B of [0-9.]+ ?[KMGTPE]?B virtual memory used. "+ "Killing container.\nDump of the process-tree for "+ cId+ " :\n";
    Pattern pat=Pattern.compile(expectedMsgPattern);
    Assert.assertEquals("Expected message pattern is: " + expectedMsgPattern + "\n\nObserved message is: "+ containerStatus.getDiagnostics(),true,pat.matcher(containerStatus.getDiagnostics()).find());
    Assert.assertFalse("Process is still alive!",exec.signalContainer(new ContainerSignalContext.Builder().setUser(user).setPid(pid).setSignal(Signal.NULL).build()));
  }
  @Test(timeout=20000) public void testContainerMonitorMemFlags(){
    ContainersMonitor cm=null;
    long expPmem=8192 * 1024 * 1024l;
    long expVmem=(long)(expPmem * 2.1f);
    cm=new ContainersMonitorImpl(mock(ContainerExecutor.class),mock(AsyncDispatcher.class),mock(Context.class));
    cm.init(getConfForCM(false,false,8192,2.1f));
    assertEquals(expPmem,cm.getPmemAllocatedForContainers());
    assertEquals(expVmem,cm.getVmemAllocatedForContainers());
    assertEquals(false,cm.isPmemCheckEnabled());
    assertEquals(false,cm.isVmemCheckEnabled());
    cm=new ContainersMonitorImpl(mock(ContainerExecutor.class),mock(AsyncDispatcher.class),mock(Context.class));
    cm.init(getConfForCM(true,false,8192,2.1f));
    assertEquals(expPmem,cm.getPmemAllocatedForContainers());
    assertEquals(expVmem,cm.getVmemAllocatedForContainers());
    assertEquals(true,cm.isPmemCheckEnabled());
    assertEquals(false,cm.isVmemCheckEnabled());
    cm=new ContainersMonitorImpl(mock(ContainerExecutor.class),mock(AsyncDispatcher.class),mock(Context.class));
    cm.init(getConfForCM(true,true,8192,2.1f));
    assertEquals(expPmem,cm.getPmemAllocatedForContainers());
    assertEquals(expVmem,cm.getVmemAllocatedForContainers());
    assertEquals(true,cm.isPmemCheckEnabled());
    assertEquals(true,cm.isVmemCheckEnabled());
    cm=new ContainersMonitorImpl(mock(ContainerExecutor.class),mock(AsyncDispatcher.class),mock(Context.class));
    cm.init(getConfForCM(false,true,8192,2.1f));
    assertEquals(expPmem,cm.getPmemAllocatedForContainers());
    assertEquals(expVmem,cm.getVmemAllocatedForContainers());
    assertEquals(false,cm.isPmemCheckEnabled());
    assertEquals(true,cm.isVmemCheckEnabled());
  }
  private YarnConfiguration getConfForCM(  boolean pMemEnabled,  boolean vMemEnabled,  int nmPmem,  float vMemToPMemRatio){
    YarnConfiguration conf=new YarnConfiguration();
    conf.setInt(YarnConfiguration.NM_PMEM_MB,nmPmem);
    conf.setBoolean(YarnConfiguration.NM_PMEM_CHECK_ENABLED,pMemEnabled);
    conf.setBoolean(YarnConfiguration.NM_VMEM_CHECK_ENABLED,vMemEnabled);
    conf.setFloat(YarnConfiguration.NM_VMEM_PMEM_RATIO,vMemToPMemRatio);
    return conf;
  }
}
