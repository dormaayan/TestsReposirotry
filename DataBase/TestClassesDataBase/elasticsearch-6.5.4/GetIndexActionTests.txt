public class GetIndexActionTests extends ESSingleNodeTestCase {
  private TransportService transportService;
  private ClusterService clusterService;
  private IndicesService indicesService;
  private ThreadPool threadPool;
  private SettingsFilter settingsFilter;
  private final String indexName="test_index";
  private TestTransportGetIndexAction getIndexAction;
  @Before public void setUp() throws Exception {
    super.setUp();
    settingsFilter=new SettingsModule(Settings.EMPTY,emptyList(),emptyList(),emptySet()).getSettingsFilter();
    threadPool=new TestThreadPool("GetIndexActionTests");
    clusterService=getInstanceFromNode(ClusterService.class);
    indicesService=getInstanceFromNode(IndicesService.class);
    CapturingTransport capturingTransport=new CapturingTransport();
    transportService=capturingTransport.createCapturingTransportService(clusterService.getSettings(),threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,boundAddress -> clusterService.localNode(),null,emptySet());
    transportService.start();
    transportService.acceptIncomingRequests();
    getIndexAction=new GetIndexActionTests.TestTransportGetIndexAction();
  }
  @After public void tearDown() throws Exception {
    ThreadPool.terminate(threadPool,30,TimeUnit.SECONDS);
    threadPool=null;
    super.tearDown();
  }
  public void testIncludeDefaults(){
    GetIndexRequest defaultsRequest=new GetIndexRequest().indices(indexName).includeDefaults(true);
    getIndexAction.execute(null,defaultsRequest,ActionListener.wrap(defaultsResponse -> assertNotNull("index.refresh_interval should be set as we are including defaults",defaultsResponse.getSetting(indexName,"index.refresh_interval")),exception -> {
      throw new AssertionError(exception);
    }
));
  }
  public void testDoNotIncludeDefaults(){
    GetIndexRequest noDefaultsRequest=new GetIndexRequest().indices(indexName);
    getIndexAction.execute(null,noDefaultsRequest,ActionListener.wrap(noDefaultsResponse -> assertNull("index.refresh_interval should be null as it was never set",noDefaultsResponse.getSetting(indexName,"index.refresh_interval")),exception -> {
      throw new AssertionError(exception);
    }
));
  }
  protected boolean enableWarningsCheck(){
    return false;
  }
class TestTransportGetIndexAction extends TransportGetIndexAction {
    TestTransportGetIndexAction(){
      super(Settings.EMPTY,GetIndexActionTests.this.transportService,GetIndexActionTests.this.clusterService,GetIndexActionTests.this.threadPool,settingsFilter,new ActionFilters(emptySet()),new GetIndexActionTests.Resolver(Settings.EMPTY),indicesService,IndexScopedSettings.DEFAULT_SCOPED_SETTINGS);
    }
    @Override protected void doMasterOperation(    GetIndexRequest request,    String[] concreteIndices,    ClusterState state,    ActionListener<GetIndexResponse> listener){
      ClusterState stateWithIndex=ClusterStateCreationUtils.state(indexName,1,1);
      super.doMasterOperation(request,concreteIndices,stateWithIndex,listener);
    }
  }
static class Resolver extends IndexNameExpressionResolver {
    Resolver(    Settings settings){
      super(settings);
    }
    @Override public String[] concreteIndexNames(    ClusterState state,    IndicesRequest request){
      return request.indices();
    }
    @Override public Index[] concreteIndices(    ClusterState state,    IndicesRequest request){
      Index[] out=new Index[request.indices().length];
      for (int x=0; x < out.length; x++) {
        out[x]=new Index(request.indices()[x],"_na_");
      }
      return out;
    }
  }
}
