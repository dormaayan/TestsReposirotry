public class TransportWriteActionTests extends ESTestCase {
  private static ThreadPool threadPool;
  private ClusterService clusterService;
  private IndexShard indexShard;
  private Translog.Location location;
  @BeforeClass public static void beforeClass(){
    threadPool=new TestThreadPool("ShardReplicationTests");
  }
  @Before public void initCommonMocks(){
    indexShard=mock(IndexShard.class);
    location=mock(Translog.Location.class);
    clusterService=createClusterService(threadPool);
  }
  @After public void tearDown() throws Exception {
    super.tearDown();
    clusterService.close();
  }
  @AfterClass public static void afterClass(){
    ThreadPool.terminate(threadPool,30,TimeUnit.SECONDS);
    threadPool=null;
  }
  <T>void assertListenerThrows(  String msg,  PlainActionFuture<T> listener,  Class<?> klass) throws InterruptedException {
    try {
      listener.get();
      fail(msg);
    }
 catch (    ExecutionException ex) {
      assertThat(ex.getCause(),instanceOf(klass));
    }
  }
  public void testPrimaryNoRefreshCall() throws Exception {
    TestRequest request=new TestRequest();
    request.setRefreshPolicy(RefreshPolicy.NONE);
    TestAction testAction=new TestAction();
    TransportWriteAction.WritePrimaryResult<TestRequest,TestResponse> result=testAction.shardOperationOnPrimary(request,indexShard);
    CapturingActionListener<TestResponse> listener=new CapturingActionListener<>();
    result.respond(listener);
    assertNotNull(listener.response);
    assertNull(listener.failure);
    verify(indexShard,never()).refresh(any());
    verify(indexShard,never()).addRefreshListener(any(),any());
  }
  public void testReplicaNoRefreshCall() throws Exception {
    TestRequest request=new TestRequest();
    request.setRefreshPolicy(RefreshPolicy.NONE);
    TestAction testAction=new TestAction();
    TransportWriteAction.WriteReplicaResult<TestRequest> result=testAction.shardOperationOnReplica(request,indexShard);
    CapturingActionListener<TransportResponse.Empty> listener=new CapturingActionListener<>();
    result.respond(listener);
    assertNotNull(listener.response);
    assertNull(listener.failure);
    verify(indexShard,never()).refresh(any());
    verify(indexShard,never()).addRefreshListener(any(),any());
  }
  public void testPrimaryImmediateRefresh() throws Exception {
    TestRequest request=new TestRequest();
    request.setRefreshPolicy(RefreshPolicy.IMMEDIATE);
    TestAction testAction=new TestAction();
    TransportWriteAction.WritePrimaryResult<TestRequest,TestResponse> result=testAction.shardOperationOnPrimary(request,indexShard);
    CapturingActionListener<TestResponse> listener=new CapturingActionListener<>();
    result.respond(listener);
    assertNotNull(listener.response);
    assertNull(listener.failure);
    assertTrue(listener.response.forcedRefresh);
    verify(indexShard).refresh("refresh_flag_index");
    verify(indexShard,never()).addRefreshListener(any(),any());
  }
  public void testReplicaImmediateRefresh() throws Exception {
    TestRequest request=new TestRequest();
    request.setRefreshPolicy(RefreshPolicy.IMMEDIATE);
    TestAction testAction=new TestAction();
    TransportWriteAction.WriteReplicaResult<TestRequest> result=testAction.shardOperationOnReplica(request,indexShard);
    CapturingActionListener<TransportResponse.Empty> listener=new CapturingActionListener<>();
    result.respond(listener);
    assertNotNull(listener.response);
    assertNull(listener.failure);
    verify(indexShard).refresh("refresh_flag_index");
    verify(indexShard,never()).addRefreshListener(any(),any());
  }
  public void testPrimaryWaitForRefresh() throws Exception {
    TestRequest request=new TestRequest();
    request.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL);
    TestAction testAction=new TestAction();
    TransportWriteAction.WritePrimaryResult<TestRequest,TestResponse> result=testAction.shardOperationOnPrimary(request,indexShard);
    CapturingActionListener<TestResponse> listener=new CapturingActionListener<>();
    result.respond(listener);
    assertNull(listener.response);
    @SuppressWarnings({"unchecked","rawtypes"}) ArgumentCaptor<Consumer<Boolean>> refreshListener=ArgumentCaptor.forClass((Class)Consumer.class);
    verify(indexShard,never()).refresh(any());
    verify(indexShard).addRefreshListener(any(),refreshListener.capture());
    boolean forcedRefresh=randomBoolean();
    refreshListener.getValue().accept(forcedRefresh);
    assertNotNull(listener.response);
    assertNull(listener.failure);
    assertEquals(forcedRefresh,listener.response.forcedRefresh);
  }
  public void testReplicaWaitForRefresh() throws Exception {
    TestRequest request=new TestRequest();
    request.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL);
    TestAction testAction=new TestAction();
    TransportWriteAction.WriteReplicaResult<TestRequest> result=testAction.shardOperationOnReplica(request,indexShard);
    CapturingActionListener<TransportResponse.Empty> listener=new CapturingActionListener<>();
    result.respond(listener);
    assertNull(listener.response);
    @SuppressWarnings({"unchecked","rawtypes"}) ArgumentCaptor<Consumer<Boolean>> refreshListener=ArgumentCaptor.forClass((Class)Consumer.class);
    verify(indexShard,never()).refresh(any());
    verify(indexShard).addRefreshListener(any(),refreshListener.capture());
    boolean forcedRefresh=randomBoolean();
    refreshListener.getValue().accept(forcedRefresh);
    assertNotNull(listener.response);
    assertNull(listener.failure);
  }
  public void testDocumentFailureInShardOperationOnPrimary() throws Exception {
    TestRequest request=new TestRequest();
    TestAction testAction=new TestAction(true,true);
    TransportWriteAction.WritePrimaryResult<TestRequest,TestResponse> writePrimaryResult=testAction.shardOperationOnPrimary(request,indexShard);
    CapturingActionListener<TestResponse> listener=new CapturingActionListener<>();
    writePrimaryResult.respond(listener);
    assertNull(listener.response);
    assertNotNull(listener.failure);
  }
  public void testDocumentFailureInShardOperationOnReplica() throws Exception {
    TestRequest request=new TestRequest();
    TestAction testAction=new TestAction(randomBoolean(),true);
    TransportWriteAction.WriteReplicaResult<TestRequest> writeReplicaResult=testAction.shardOperationOnReplica(request,indexShard);
    CapturingActionListener<TransportResponse.Empty> listener=new CapturingActionListener<>();
    writeReplicaResult.respond(listener);
    assertNull(listener.response);
    assertNotNull(listener.failure);
  }
  public void testReplicaProxy() throws InterruptedException, ExecutionException {
    CapturingTransport transport=new CapturingTransport();
    TransportService transportService=transport.createCapturingTransportService(clusterService.getSettings(),threadPool,TransportService.NOOP_TRANSPORT_INTERCEPTOR,x -> clusterService.localNode(),null,Collections.emptySet());
    transportService.start();
    transportService.acceptIncomingRequests();
    ShardStateAction shardStateAction=new ShardStateAction(Settings.EMPTY,clusterService,transportService,null,null,threadPool);
    TestAction action=new TestAction(Settings.EMPTY,"internal:testAction",transportService,clusterService,shardStateAction,threadPool);
    final String index="test";
    final ShardId shardId=new ShardId(index,"_na_",0);
    ClusterState state=ClusterStateCreationUtils.stateWithActivePrimary(index,true,1 + randomInt(3),randomInt(2));
    logger.info("using state: {}",state);
    ClusterServiceUtils.setState(clusterService,state);
    ReplicationOperation.Replicas proxy=action.newReplicasProxy(state.metaData().index(index).primaryTerm(0));
    PlainActionFuture<ReplicaResponse> listener=new PlainActionFuture<>();
    ShardRoutingState routingState=randomFrom(ShardRoutingState.INITIALIZING,ShardRoutingState.STARTED,ShardRoutingState.RELOCATING);
    proxy.performOn(TestShardRouting.newShardRouting(shardId,"NOT THERE",routingState == ShardRoutingState.RELOCATING ? state.nodes().iterator().next().getId() : null,false,routingState),new TestRequest(),randomNonNegativeLong(),randomNonNegativeLong(),listener);
    assertTrue(listener.isDone());
    assertListenerThrows("non existent node should throw a NoNodeAvailableException",listener,NoNodeAvailableException.class);
    final IndexShardRoutingTable shardRoutings=state.routingTable().shardRoutingTable(shardId);
    final ShardRouting replica=randomFrom(shardRoutings.replicaShards().stream().filter(ShardRouting::assignedToNode).collect(Collectors.toList()));
    listener=new PlainActionFuture<>();
    proxy.performOn(replica,new TestRequest(),randomNonNegativeLong(),randomNonNegativeLong(),listener);
    assertFalse(listener.isDone());
    CapturingTransport.CapturedRequest[] captures=transport.getCapturedRequestsAndClear();
    assertThat(captures,arrayWithSize(1));
    if (randomBoolean()) {
      final TransportReplicationAction.ReplicaResponse response=new TransportReplicationAction.ReplicaResponse(randomLong(),randomLong());
      transport.handleResponse(captures[0].requestId,response);
      assertTrue(listener.isDone());
      assertThat(listener.get(),equalTo(response));
    }
 else     if (randomBoolean()) {
      transport.handleRemoteError(captures[0].requestId,new ElasticsearchException("simulated"));
      assertTrue(listener.isDone());
      assertListenerThrows("listener should reflect remote error",listener,ElasticsearchException.class);
    }
 else {
      transport.handleError(captures[0].requestId,new TransportException("simulated"));
      assertTrue(listener.isDone());
      assertListenerThrows("listener should reflect remote error",listener,TransportException.class);
    }
    AtomicReference<Object> failure=new AtomicReference<>();
    AtomicReference<Object> ignoredFailure=new AtomicReference<>();
    AtomicBoolean success=new AtomicBoolean();
    proxy.failShardIfNeeded(replica,"test",new ElasticsearchException("simulated"),() -> success.set(true),failure::set,ignoredFailure::set);
    CapturingTransport.CapturedRequest[] shardFailedRequests=transport.getCapturedRequestsAndClear();
    assertEquals(1,shardFailedRequests.length);
    CapturingTransport.CapturedRequest shardFailedRequest=shardFailedRequests[0];
    ShardStateAction.FailedShardEntry shardEntry=(ShardStateAction.FailedShardEntry)shardFailedRequest.request;
    assertEquals(shardEntry.getShardId(),replica.shardId());
    assertEquals(shardEntry.getAllocationId(),replica.allocationId().getId());
    if (randomBoolean()) {
      transport.handleResponse(shardFailedRequest.requestId,TransportResponse.Empty.INSTANCE);
      assertTrue(success.get());
      assertNull(failure.get());
      assertNull(ignoredFailure.get());
    }
 else     if (randomBoolean()) {
      transport.handleRemoteError(shardFailedRequest.requestId,new ShardStateAction.NoLongerPrimaryShardException(replica.shardId(),"shard-failed-test"));
      assertFalse(success.get());
      assertNotNull(failure.get());
      assertNull(ignoredFailure.get());
    }
 else {
      transport.handleRemoteError(shardFailedRequest.requestId,new NodeClosedException(state.nodes().getLocalNode()));
      assertFalse(success.get());
      assertNull(failure.get());
      assertNotNull(ignoredFailure.get());
    }
  }
private class TestAction extends TransportWriteAction<TestRequest,TestRequest,TestResponse> {
    private final boolean withDocumentFailureOnPrimary;
    private final boolean withDocumentFailureOnReplica;
    protected TestAction(){
      this(false,false);
    }
    protected TestAction(    boolean withDocumentFailureOnPrimary,    boolean withDocumentFailureOnReplica){
      super(Settings.EMPTY,"internal:test",new TransportService(Settings.EMPTY,mock(Transport.class),null,TransportService.NOOP_TRANSPORT_INTERCEPTOR,x -> null,null,Collections.emptySet()),null,null,null,null,new ActionFilters(new HashSet<>()),new IndexNameExpressionResolver(Settings.EMPTY),TestRequest::new,TestRequest::new,ThreadPool.Names.SAME);
      this.withDocumentFailureOnPrimary=withDocumentFailureOnPrimary;
      this.withDocumentFailureOnReplica=withDocumentFailureOnReplica;
    }
    protected TestAction(    Settings settings,    String actionName,    TransportService transportService,    ClusterService clusterService,    ShardStateAction shardStateAction,    ThreadPool threadPool){
      super(settings,actionName,transportService,clusterService,mockIndicesService(clusterService),threadPool,shardStateAction,new ActionFilters(new HashSet<>()),new IndexNameExpressionResolver(Settings.EMPTY),TestRequest::new,TestRequest::new,ThreadPool.Names.SAME);
      this.withDocumentFailureOnPrimary=false;
      this.withDocumentFailureOnReplica=false;
    }
    @Override protected TestResponse newResponseInstance(){
      return new TestResponse();
    }
    @Override protected WritePrimaryResult<TestRequest,TestResponse> shardOperationOnPrimary(    TestRequest request,    IndexShard primary) throws Exception {
      final WritePrimaryResult<TestRequest,TestResponse> primaryResult;
      if (withDocumentFailureOnPrimary) {
        primaryResult=new WritePrimaryResult<>(request,null,null,new RuntimeException("simulated"),primary,logger);
      }
 else {
        primaryResult=new WritePrimaryResult<>(request,new TestResponse(),location,null,primary,logger);
      }
      return primaryResult;
    }
    @Override protected WriteReplicaResult<TestRequest> shardOperationOnReplica(    TestRequest request,    IndexShard replica) throws Exception {
      final WriteReplicaResult<TestRequest> replicaResult;
      if (withDocumentFailureOnReplica) {
        replicaResult=new WriteReplicaResult<>(request,null,new RuntimeException("simulated"),replica,logger);
      }
 else {
        replicaResult=new WriteReplicaResult<>(request,location,null,replica,logger);
      }
      return replicaResult;
    }
  }
  final IndexService mockIndexService(  final IndexMetaData indexMetaData,  ClusterService clusterService){
    final IndexService indexService=mock(IndexService.class);
    when(indexService.getShard(anyInt())).then(invocation -> {
      int shard=(Integer)invocation.getArguments()[0];
      final ShardId shardId=new ShardId(indexMetaData.getIndex(),shard);
      if (shard > indexMetaData.getNumberOfShards()) {
        throw new ShardNotFoundException(shardId);
      }
      return mockIndexShard(shardId,clusterService);
    }
);
    return indexService;
  }
  final IndicesService mockIndicesService(  ClusterService clusterService){
    final IndicesService indicesService=mock(IndicesService.class);
    when(indicesService.indexServiceSafe(any(Index.class))).then(invocation -> {
      Index index=(Index)invocation.getArguments()[0];
      final ClusterState state=clusterService.state();
      final IndexMetaData indexSafe=state.metaData().getIndexSafe(index);
      return mockIndexService(indexSafe,clusterService);
    }
);
    when(indicesService.indexService(any(Index.class))).then(invocation -> {
      Index index=(Index)invocation.getArguments()[0];
      final ClusterState state=clusterService.state();
      if (state.metaData().hasIndex(index.getName())) {
        final IndexMetaData indexSafe=state.metaData().getIndexSafe(index);
        return mockIndexService(clusterService.state().metaData().getIndexSafe(index),clusterService);
      }
 else {
        return null;
      }
    }
);
    return indicesService;
  }
  private final AtomicInteger count=new AtomicInteger(0);
  private final AtomicBoolean isRelocated=new AtomicBoolean(false);
  private IndexShard mockIndexShard(  ShardId shardId,  ClusterService clusterService){
    final IndexShard indexShard=mock(IndexShard.class);
    doAnswer(invocation -> {
      ActionListener<Releasable> callback=(ActionListener<Releasable>)invocation.getArguments()[0];
      count.incrementAndGet();
      callback.onResponse(count::decrementAndGet);
      return null;
    }
).when(indexShard).acquirePrimaryOperationPermit(any(ActionListener.class),anyString(),anyObject());
    doAnswer(invocation -> {
      long term=(Long)invocation.getArguments()[0];
      ActionListener<Releasable> callback=(ActionListener<Releasable>)invocation.getArguments()[1];
      final long primaryTerm=indexShard.getPendingPrimaryTerm();
      if (term < primaryTerm) {
        throw new IllegalArgumentException(String.format(Locale.ROOT,"%s operation term [%d] is too old (current [%d])",shardId,term,primaryTerm));
      }
      count.incrementAndGet();
      callback.onResponse(count::decrementAndGet);
      return null;
    }
).when(indexShard).acquireReplicaOperationPermit(anyLong(),anyLong(),anyLong(),any(ActionListener.class),anyString(),anyObject());
    when(indexShard.routingEntry()).thenAnswer(invocationOnMock -> {
      final ClusterState state=clusterService.state();
      final RoutingNode node=state.getRoutingNodes().node(state.nodes().getLocalNodeId());
      final ShardRouting routing=node.getByShardId(shardId);
      if (routing == null) {
        throw new ShardNotFoundException(shardId,"shard is no longer assigned to current node");
      }
      return routing;
    }
);
    when(indexShard.isRelocatedPrimary()).thenAnswer(invocationOnMock -> isRelocated.get());
    doThrow(new AssertionError("failed shard is not supported")).when(indexShard).failShard(anyString(),any(Exception.class));
    when(indexShard.getPendingPrimaryTerm()).thenAnswer(i -> clusterService.state().metaData().getIndexSafe(shardId.getIndex()).primaryTerm(shardId.id()));
    return indexShard;
  }
private static class TestRequest extends ReplicatedWriteRequest<TestRequest> {
    TestRequest(){
      setShardId(new ShardId("test","test",1));
    }
    @Override public String toString(){
      return "TestRequest{}";
    }
  }
private static class TestResponse extends ReplicationResponse implements WriteResponse {
    boolean forcedRefresh;
    @Override public void setForcedRefresh(    boolean forcedRefresh){
      this.forcedRefresh=forcedRefresh;
    }
  }
private static class CapturingActionListener<R> implements ActionListener<R> {
    private R response;
    private Exception failure;
    @Override public void onResponse(    R response){
      this.response=response;
    }
    @Override public void onFailure(    Exception failure){
      this.failure=failure;
    }
  }
}
