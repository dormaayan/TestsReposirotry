@Test public void shouldThrowSpecificExceptionOnConcurrentTransactionAccess() throws Exception {
  TransactionRegistry registry=new TransactionHandleRegistry(mock(Clock.class),0,NullLogProvider.getInstance());
  TransitionalPeriodTransactionMessContainer kernel=mock(TransitionalPeriodTransactionMessContainer.class);
  GraphDatabaseQueryService queryService=mock(GraphDatabaseQueryService.class);
  TransitionalTxManagementKernelTransaction kernelTransaction=mock(TransitionalTxManagementKernelTransaction.class);
  when(kernel.newTransaction(any(KernelTransaction.Type.class),any(LoginContext.class),anyLong())).thenReturn(kernelTransaction);
  TransactionFacade actions=new TransactionFacade(kernel,null,queryService,registry,NullLogProvider.getInstance());
  final TransactionHandle transactionHandle=actions.newTransactionHandle(new DisgustingUriScheme(),true,LoginContext.AUTH_DISABLED,-1);
  final DoubleLatch latch=new DoubleLatch();
  final StatementDeserializer statements=mock(StatementDeserializer.class);
  when(statements.hasNext()).thenAnswer(invocation -> {
    latch.startAndWaitForAllToStartAndFinish();
    return false;
  }
);
  new Thread(() -> {
    transactionHandle.execute(statements,mock(ExecutionResultSerializer.class),mock(HttpServletRequest.class));
  }
).start();
  latch.waitForAllToStart();
  try {
    actions.findTransactionHandle(DisgustingUriScheme.parseTxId(transactionHandle.uri()));
    fail("should have thrown exception");
  }
 catch (  InvalidConcurrentTransactionAccess neo4jError) {
  }
 finally {
    latch.finish();
  }
}
