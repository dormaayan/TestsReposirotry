@Repeat(times=100) @Test public void shouldKeepHighest() throws Throwable {
  Race race=new Race();
  HighestId highestId=new HighestId();
  int threads=Runtime.getRuntime().availableProcessors();
  CountDownLatch latch=new CountDownLatch(threads);
  AtomicLongArray highestIds=new AtomicLongArray(threads);
  for (int c=0; c < threads; c++) {
    int cc=c;
    race.addContestant(new Runnable(){
      boolean run;
      ThreadLocalRandom random=ThreadLocalRandom.current();
      @Override public void run(){
        if (run) {
          return;
        }
        long highest=0;
        for (int i=0; i < 10; i++) {
          long nextLong=random.nextLong(100);
          highestId.offer(nextLong);
          highest=max(highest,nextLong);
        }
        highestIds.set(cc,highest);
        latch.countDown();
        run=true;
      }
    }
);
  }
  race.withEndCondition(() -> latch.getCount() == 0);
  race.go();
  long highest=0;
  for (int i=0; i < threads; i++) {
    highest=max(highest,highestIds.get(i));
  }
  assertEquals(highest,highestId.get());
}
