@Test public void listProcedures() throws Throwable {
  ProcedureHandle procedures=procs().procedureGet(procedureName("dbms","procedures"));
  RawIterator<Object[],ProcedureException> stream=procs().procedureCallRead(procedures.id(),new Object[0]);
  assertThat(asList(stream),containsInAnyOrder(proc("dbms.listConfig","(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?)","List the currently active config of Neo4j.","DBMS"),proc("db.constraints","() :: (description :: STRING?)","List all constraints in the database.","READ"),proc("db.indexes","() :: (description :: STRING?, indexName :: STRING?, tokenNames :: LIST? OF STRING?, properties :: " + "LIST? OF STRING?, state :: STRING?, type :: STRING?, progress :: FLOAT?, provider :: MAP?, id :: INTEGER?, " + "failureMessage :: STRING?)","List all indexes in the database.","READ"),proc("db.awaitIndex","(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID","Wait for an index to come online (for example: CALL db.awaitIndex(\":Person(name)\")).","READ"),proc("db.awaitIndexes","(timeOutSeconds = 300 :: INTEGER?) :: VOID","Wait for all indexes to come online (for example: CALL db.awaitIndexes(\"500\")).","READ"),proc("db.resampleIndex","(index :: STRING?) :: VOID","Schedule resampling of an index (for example: CALL db.resampleIndex(\":Person(name)\")).","READ"),proc("db.resampleOutdatedIndexes","() :: VOID","Schedule resampling of all outdated indexes.","READ"),proc("db.propertyKeys","() :: (propertyKey :: STRING?)","List all property keys in the database.","READ"),proc("db.labels","() :: (label :: STRING?)","List all labels in the database.","READ"),proc("db.schema","() :: (nodes :: LIST? OF NODE?, relationships :: LIST? " + "OF " + "RELATIONSHIP?)","Show the schema of the data.","READ"),proc("db.schema.visualization","() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","Visualize the schema of the data. Replaces db.schema.","READ"),proc("db.schema.nodeTypeProperties","() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, " + "propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)","Show the derived property schema of the nodes in tabular form.","READ"),proc("db.schema.relTypeProperties","() :: (relType :: STRING?, " + "propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)","Show the derived property schema of the relationships in tabular form.","READ"),proc("db.relationshipTypes","() :: (relationshipType :: " + "STRING?)","List all relationship types in the database.","READ"),proc("dbms.procedures","() :: (name :: STRING?, signature :: " + "STRING?, description :: STRING?, mode :: STRING?)","List all procedures in the DBMS.","DBMS"),proc("dbms.functions","() :: (name :: STRING?, signature :: " + "STRING?, description :: STRING?)","List all user functions in the DBMS.","DBMS"),proc("dbms.components","() :: (name :: STRING?, versions :: LIST? OF" + " STRING?, edition :: STRING?)","List DBMS components and their versions.","DBMS"),proc("dbms.queryJmx","(query :: STRING?) :: (name :: STRING?, " + "description :: STRING?, attributes :: MAP?)","Query JMX management data by domain and name." + " For instance, \"org.neo4j:*\"","DBMS"),proc("db.createLabel","(newLabel :: STRING?) :: VOID","Create a label","WRITE"),proc("db.createProperty","(newProperty :: STRING?) :: VOID","Create a Property","WRITE"),proc("db.createRelationshipType","(newRelationshipType :: STRING?) :: VOID","Create a RelationshipType","WRITE"),proc("db.index.explicit.searchNodes","(indexName :: STRING?, query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)","Search nodes in explicit index. Replaces `START n=node:nodes('key:foo*')`","READ"),proc("db.index.explicit.seekNodes","(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (node :: NODE?)","Get node from explicit index. Replaces `START n=node:nodes(key = 'A')`","READ"),proc("db.index.explicit.searchRelationships","(indexName :: STRING?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index. Replaces `START r=relationship:relIndex('key:foo*')`","READ"),proc("db.index.explicit.auto.searchNodes","(query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)","Search nodes in explicit automatic index. Replaces `START n=node:node_auto_index('key:foo*')`","READ"),proc("db.index.explicit.auto.seekNodes","(key :: STRING?, value :: ANY?) :: (node :: NODE?)","Get node from explicit automatic index. Replaces `START n=node:node_auto_index(key = 'A')`","READ"),proc("db.index.explicit.auto.searchRelationships","(query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit automatic index. Replaces `START r=relationship:relationship_auto_index('key:foo*')`","READ"),proc("db.index.explicit.auto.seekRelationships","(key :: STRING?, value :: ANY?) :: " + "(relationship :: RELATIONSHIP?)","Get relationship from explicit automatic index. Replaces `START r=relationship:relationship_auto_index(key = 'A')`","READ"),proc("db.index.explicit.addNode","(indexName :: STRING?, node :: NODE?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)","Add a node to an explicit index based on a specified key and value","WRITE"),proc("db.index.explicit.addRelationship","(indexName :: STRING?, relationship :: RELATIONSHIP?, key :: STRING?, value :: ANY?) :: " + "(success :: BOOLEAN?)","Add a relationship to an explicit index based on a specified key and value","WRITE"),proc("db.index.explicit.removeNode","(indexName :: STRING?, node :: NODE?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) " + ":: (success :: BOOLEAN?)","Remove a node from an explicit index with an optional key","WRITE"),proc("db.index.explicit.removeRelationship","(indexName :: STRING?, relationship :: RELATIONSHIP?, " + "key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)","Remove a relationship from an explicit index with an optional key","WRITE"),proc("db.index.explicit.drop","(indexName :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","Remove an explicit index - YIELD type,name,config","WRITE"),proc("db.index.explicit.forNodes","(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","Get or create a node explicit index - YIELD type,name,config","WRITE"),proc("db.index.explicit.forRelationships","(indexName :: STRING?, config = {} :: MAP?) :: " + "(type :: STRING?, name :: STRING?, config :: MAP?)","Get or create a relationship explicit index - YIELD type,name,config","WRITE"),proc("db.index.explicit.existsForNodes","(indexName :: STRING?) :: (success :: BOOLEAN?)","Check if a node explicit index exists","READ"),proc("db.index.explicit.existsForRelationships","(indexName :: STRING?) :: (success :: BOOLEAN?)","Check if a relationship explicit index exists","READ"),proc("db.index.explicit.list","() :: (type :: STRING?, name :: STRING?, config :: MAP?)","List all explicit indexes - YIELD type,name,config","READ"),proc("db.index.explicit.seekRelationships","(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?)","Get relationship from explicit index. Replaces `START r=relationship:relIndex(key = 'A')`","READ"),proc("db.index.explicit.searchRelationshipsBetween","(indexName :: STRING?, in :: NODE?, out :: NODE?, query :: ANY?) :: " + "(relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, starting at the node 'in' and ending at 'out'.","READ"),proc("db.index.explicit.searchRelationshipsIn","(indexName :: STRING?, in :: NODE?, query :: ANY?) :: " + "(relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, starting at the node 'in'.","READ"),proc("db.index.explicit.searchRelationshipsOut","(indexName :: STRING?, out :: NODE?, query :: ANY?) :: " + "(relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, ending at the node 'out'.","READ"),proc("dbms.clearQueryCaches","() :: (value :: STRING?)","Clears all query caches.","DBMS"),proc("db.createIndex","(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?)","Create a schema index with specified index provider (for example: CALL db.createIndex(\":Person(name)\", \"lucene+native-2.0\")) - " + "YIELD index, providerName, status","SCHEMA"),proc("db.createUniquePropertyConstraint","(index :: STRING?, providerName :: STRING?) :: " + "(index :: STRING?, providerName :: STRING?, status :: STRING?)","Create a unique property constraint with index backed by specified index provider " + "(for example: CALL db.createUniquePropertyConstraint(\":Person(name)\", \"lucene+native-2.0\")) - " + "YIELD index, providerName, status","SCHEMA"),proc("db.index.fulltext.awaitEventuallyConsistentIndexRefresh","() :: VOID","Wait for the updates from recently committed transactions to be applied to any eventually-consistent fulltext indexes.","READ"),proc("db.index.fulltext.createNodeIndex","(indexName :: STRING?, labels :: LIST? OF STRING?, propertyNames :: LIST? OF STRING?, " + "config = {} :: MAP?) :: VOID",startsWith("Create a node fulltext index for the given labels and properties."),"SCHEMA"),proc("db.index.fulltext.createRelationshipIndex","(indexName :: STRING?, relationshipTypes :: LIST? OF STRING?, propertyNames :: LIST? OF STRING?, config = {} :: MAP?) :: VOID",startsWith("Create a relationship fulltext index for the given relationship types and properties."),"SCHEMA"),proc("db.index.fulltext.drop","(indexName :: STRING?) :: VOID","Drop the specified index.","SCHEMA"),proc("db.index.fulltext.listAvailableAnalyzers","() :: (analyzer :: STRING?)","List the available analyzers that the fulltext indexes can be configured with.","READ"),proc("db.index.fulltext.queryNodes","(indexName :: STRING?, queryString :: STRING?) :: (node :: NODE?, score :: FLOAT?)","Query the given fulltext index. Returns the matching nodes and their lucene query score, ordered by score.","READ"),proc("db.index.fulltext.queryRelationships","(indexName :: STRING?, queryString :: STRING?) :: (relationship :: RELATIONSHIP?, " + "score :: FLOAT?)","Query the given fulltext index. Returns the matching relationships and their lucene query score, ordered by " + "score.","READ"),proc("db.stats.retrieve","(section :: STRING?) :: (section :: STRING?, data :: MAP?)","Retrieve statistical data about the current database.","READ"),proc("db.stats.retrieveAllAnonymized","(graphToken :: STRING?) :: (section :: STRING?, data :: MAP?)","Retrieve all available statistical data about the current database, in an anonymized form.","READ")));
  commit();
}
