/** 
 * Confirm that running on a ThreadPoolScheduler allows multiple threads but is still ordered.
 */
@Test public void testObserveOnWithThreadPoolScheduler(){
  final AtomicInteger count=new AtomicInteger();
  final int _multiple=99;
  Observable.range(1,100000).map(new Function<Integer,Integer>(){
    @Override public Integer apply(    Integer t1){
      return t1 * _multiple;
    }
  }
).observeOn(Schedulers.computation()).blockingForEach(new Consumer<Integer>(){
    @Override public void accept(    Integer t1){
      assertEquals(count.incrementAndGet() * _multiple,t1.intValue());
      String name=Thread.currentThread().getName();
      assertFalse("Wrong thread name: " + name,name.startsWith("Rx"));
    }
  }
);
}
