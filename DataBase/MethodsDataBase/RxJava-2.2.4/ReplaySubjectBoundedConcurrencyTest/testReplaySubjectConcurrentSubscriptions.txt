@Test public void testReplaySubjectConcurrentSubscriptions() throws InterruptedException {
  final ReplaySubject<Long> replay=ReplaySubject.createUnbounded();
  Thread source=new Thread(new Runnable(){
    @Override public void run(){
      Observable.unsafeCreate(new ObservableSource<Long>(){
        @Override public void subscribe(        Observer<? super Long> o){
          o.onSubscribe(Disposables.empty());
          System.out.println("********* Start Source Data ***********");
          for (long l=1; l <= 10000; l++) {
            o.onNext(l);
          }
          System.out.println("********* Finished Source Data ***********");
          o.onComplete();
        }
      }
).subscribe(replay);
    }
  }
);
  final List<List<Long>> listOfListsOfValues=Collections.synchronizedList(new ArrayList<List<Long>>());
  final List<Thread> threads=Collections.synchronizedList(new ArrayList<Thread>());
  for (int i=1; i <= 200; i++) {
    final int count=i;
    if (count == 20) {
      source.start();
    }
    if (count == 100) {
      source.join();
    }
    Thread t=new Thread(new Runnable(){
      @Override public void run(){
        List<Long> values=replay.toList().blockingGet();
        listOfListsOfValues.add(values);
        System.out.println("Finished thread: " + count);
      }
    }
);
    t.start();
    System.out.println("Started thread: " + i);
    threads.add(t);
  }
  for (  Thread t : threads) {
    t.join();
  }
  List<Long> sums=new ArrayList<Long>();
  for (  List<Long> values : listOfListsOfValues) {
    long v=0;
    for (    long l : values) {
      v+=l;
    }
    sums.add(v);
  }
  long expected=sums.get(0);
  boolean success=true;
  for (  long l : sums) {
    if (l != expected) {
      success=false;
      System.out.println("FAILURE => Expected " + expected + " but got: "+ l);
    }
  }
  if (success) {
    System.out.println("Success! " + sums.size() + " each had the same sum of "+ expected);
  }
 else {
    throw new RuntimeException("Concurrency Bug");
  }
}
