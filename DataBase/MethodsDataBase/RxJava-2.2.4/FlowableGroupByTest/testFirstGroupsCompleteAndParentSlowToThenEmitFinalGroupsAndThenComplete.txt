@Test public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete() throws InterruptedException {
  final CountDownLatch first=new CountDownLatch(2);
  final ArrayList<String> results=new ArrayList<String>();
  Flowable.unsafeCreate(new Publisher<Integer>(){
    @Override public void subscribe(    Subscriber<? super Integer> sub){
      sub.onSubscribe(new BooleanSubscription());
      sub.onNext(1);
      sub.onNext(2);
      sub.onNext(1);
      sub.onNext(2);
      try {
        first.await();
      }
 catch (      InterruptedException e) {
        sub.onError(e);
        return;
      }
      sub.onNext(3);
      sub.onNext(3);
      sub.onComplete();
    }
  }
).groupBy(new Function<Integer,Integer>(){
    @Override public Integer apply(    Integer t){
      return t;
    }
  }
).flatMap(new Function<GroupedFlowable<Integer,Integer>,Flowable<String>>(){
    @Override public Flowable<String> apply(    final GroupedFlowable<Integer,Integer> group){
      if (group.getKey() < 3) {
        return group.map(new Function<Integer,String>(){
          @Override public String apply(          Integer t1){
            return "first groups: " + t1;
          }
        }
).take(2).doOnComplete(new Action(){
          @Override public void run(){
            first.countDown();
          }
        }
);
      }
 else {
        return group.map(new Function<Integer,String>(){
          @Override public String apply(          Integer t1){
            return "last group: " + t1;
          }
        }
);
      }
    }
  }
).blockingForEach(new Consumer<String>(){
    @Override public void accept(    String s){
      results.add(s);
    }
  }
);
  System.out.println("Results: " + results);
  assertEquals(6,results.size());
}
