@Test(timeout=20000) public void testInvalidNodeLabelsFromProvider() throws InterruptedException, IOException {
  final ResourceTrackerForLabels resourceTracker=new ResourceTrackerForLabels();
  nm=new NodeManager(){
    @Override protected NodeLabelsProvider createNodeLabelsProvider(    Configuration conf) throws IOException {
      return dummyLabelsProviderRef;
    }
    @Override protected NodeStatusUpdater createNodeStatusUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker){
      return new NodeStatusUpdaterImpl(context,dispatcher,healthChecker,metrics){
        @Override protected ResourceTracker getRMClient(){
          return resourceTracker;
        }
        @Override protected void stopRMProxy(){
          return;
        }
      }
;
    }
  }
;
  YarnConfiguration conf=createNMConfigForDistributeNodeLabels();
  conf.set(YarnConfiguration.NM_LOCALIZER_ADDRESS,"0.0.0.0:" + ServerSocketUtil.getPort(8040,10));
  nm.init(conf);
  resourceTracker.resetNMHeartbeatReceiveFlag();
  nm.start();
  dummyLabelsProviderRef.setDescriptors(toNodeLabelSet("P"));
  resourceTracker.waitTillHeartbeat();
  resourceTracker.resetNMHeartbeatReceiveFlag();
  dummyLabelsProviderRef.setDescriptors(toNodeLabelSet("_.P"));
  sendOutofBandHeartBeat();
  resourceTracker.waitTillHeartbeat();
  assertNull("On Invalid Labels we need to retain earlier labels, HB " + "needs to send null",resourceTracker.labels);
  resourceTracker.resetNMHeartbeatReceiveFlag();
  sendOutofBandHeartBeat();
  resourceTracker.waitTillHeartbeat();
  assertNull("NodeStatusUpdater need not send repeatedly empty labels on " + "invalid labels from provider ",resourceTracker.labels);
  resourceTracker.resetNMHeartbeatReceiveFlag();
}
