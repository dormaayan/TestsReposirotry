@Test public void testSlotAllocation() throws Exception {
  TestingFatalErrorHandler testingFatalErrorHandler=new TestingFatalErrorHandler();
  TestingHighAvailabilityServices testingHAServices=new TestingHighAvailabilityServices();
  final Configuration configuration=new Configuration();
  final ScheduledExecutorService scheduledExecutorService=new ScheduledThreadPoolExecutor(1);
  final ResourceID taskManagerResourceId=new ResourceID("foobar");
  final UUID rmLeaderId=UUID.randomUUID();
  final TestingLeaderElectionService rmLeaderElectionService=new TestingLeaderElectionService();
  final SettableLeaderRetrievalService rmLeaderRetrievalService=new SettableLeaderRetrievalService(null,null);
  final String rmAddress="rm";
  final String jmAddress="jm";
  final JobMasterId jobMasterId=JobMasterId.generate();
  final ResourceID rmResourceId=new ResourceID(rmAddress);
  final ResourceID jmResourceId=new ResourceID(jmAddress);
  final JobID jobId=new JobID();
  final ResourceProfile resourceProfile=new ResourceProfile(1.0,1);
  testingHAServices.setResourceManagerLeaderElectionService(rmLeaderElectionService);
  testingHAServices.setResourceManagerLeaderRetriever(rmLeaderRetrievalService);
  testingHAServices.setJobMasterLeaderRetriever(jobId,new SettableLeaderRetrievalService(jmAddress,jobMasterId.toUUID()));
  TestingRpcService rpcService=new TestingRpcService();
  ResourceManagerConfiguration resourceManagerConfiguration=new ResourceManagerConfiguration(Time.milliseconds(500L),Time.milliseconds(500L));
  JobLeaderIdService jobLeaderIdService=new JobLeaderIdService(testingHAServices,rpcService.getScheduledExecutor(),Time.minutes(5L));
  MetricRegistry metricRegistry=NoOpMetricRegistry.INSTANCE;
  HeartbeatServices heartbeatServices=new HeartbeatServices(1000L,1000L);
  final TaskManagerConfiguration taskManagerConfiguration=TaskManagerConfiguration.fromConfiguration(configuration);
  final TaskManagerLocation taskManagerLocation=new TaskManagerLocation(taskManagerResourceId,InetAddress.getLocalHost(),1234);
  final List<ResourceProfile> resourceProfiles=Arrays.asList(resourceProfile);
  final TaskSlotTable taskSlotTable=new TaskSlotTable(resourceProfiles,new TimerService<AllocationID>(scheduledExecutorService,100L));
  final SlotManager slotManager=new SlotManager(rpcService.getScheduledExecutor(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime(),TestingUtils.infiniteTime());
  final File[] taskExecutorLocalStateRootDirs=new File[]{new File(System.getProperty("java.io.tmpdir"),"localRecovery")};
  final TaskExecutorLocalStateStoresManager taskStateManager=new TaskExecutorLocalStateStoresManager(false,taskExecutorLocalStateRootDirs,rpcService.getExecutor());
  ResourceManager<ResourceID> resourceManager=new StandaloneResourceManager(rpcService,FlinkResourceManager.RESOURCE_MANAGER_NAME,rmResourceId,resourceManagerConfiguration,testingHAServices,heartbeatServices,slotManager,metricRegistry,jobLeaderIdService,new ClusterInformation("localhost",1234),testingFatalErrorHandler,UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup());
  final TaskManagerServices taskManagerServices=new TaskManagerServicesBuilder().setTaskManagerLocation(taskManagerLocation).setTaskSlotTable(taskSlotTable).setTaskStateManager(taskStateManager).build();
  TaskExecutor taskExecutor=new TaskExecutor(rpcService,taskManagerConfiguration,testingHAServices,taskManagerServices,heartbeatServices,UnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),new BlobCacheService(configuration,new VoidBlobStore(),null),testingFatalErrorHandler);
  JobMasterGateway jmGateway=mock(JobMasterGateway.class);
  when(jmGateway.registerTaskManager(any(String.class),any(TaskManagerLocation.class),any(Time.class))).thenReturn(CompletableFuture.completedFuture(new JMTMRegistrationSuccess(taskManagerResourceId)));
  when(jmGateway.getHostname()).thenReturn(jmAddress);
  when(jmGateway.offerSlots(eq(taskManagerResourceId),any(Collection.class),any(Time.class))).thenReturn(mock(CompletableFuture.class,RETURNS_MOCKS));
  when(jmGateway.getFencingToken()).thenReturn(jobMasterId);
  rpcService.registerGateway(rmAddress,resourceManager.getSelfGateway(ResourceManagerGateway.class));
  rpcService.registerGateway(jmAddress,jmGateway);
  rpcService.registerGateway(taskExecutor.getAddress(),taskExecutor.getSelfGateway(TaskExecutorGateway.class));
  final AllocationID allocationId=new AllocationID();
  final SlotRequest slotRequest=new SlotRequest(jobId,allocationId,resourceProfile,jmAddress);
  final SlotOffer slotOffer=new SlotOffer(allocationId,0,resourceProfile);
  try {
    resourceManager.start();
    taskExecutor.start();
    final ResourceManagerGateway rmGateway=resourceManager.getSelfGateway(ResourceManagerGateway.class);
    CompletableFuture<UUID> isLeaderFuture=rmLeaderElectionService.isLeader(rmLeaderId);
    assertEquals(rmLeaderId,isLeaderFuture.get());
    rmLeaderRetrievalService.notifyListener(rmAddress,rmLeaderId);
    CompletableFuture<RegistrationResponse> registrationResponseFuture=rmGateway.registerJobManager(jobMasterId,jmResourceId,jmAddress,jobId,timeout);
    RegistrationResponse registrationResponse=registrationResponseFuture.get();
    assertTrue(registrationResponse instanceof JobMasterRegistrationSuccess);
    CompletableFuture<Acknowledge> slotAck=rmGateway.requestSlot(jobMasterId,slotRequest,timeout);
    slotAck.get();
    verify(jmGateway,Mockito.timeout(timeout.toMilliseconds())).offerSlots(eq(taskManagerResourceId),(Collection<SlotOffer>)argThat(Matchers.contains(slotOffer)),any(Time.class));
  }
  finally {
    if (testingFatalErrorHandler.hasExceptionOccurred()) {
      testingFatalErrorHandler.rethrowError();
    }
    RpcUtils.terminateRpcService(rpcService,timeout);
  }
}
