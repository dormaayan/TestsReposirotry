@Test public void testTumblingTimeWindow(){
  final int numElementsPerKey=numElementsPerKey();
  final int windowSize=windowSize();
  final int numKeys=numKeys();
  try {
    StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
    env.setParallelism(PARALLELISM);
    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
    env.enableCheckpointing(100);
    env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1,0));
    env.getConfig().disableSysoutLogging();
    env.setStateBackend(this.stateBackend);
    env.getConfig().setUseSnapshotCompression(true);
    env.addSource(new FailingSource(new KeyedEventTimeGenerator(numKeys,windowSize),numElementsPerKey)).rebalance().keyBy(0).timeWindow(Time.of(windowSize,MILLISECONDS)).apply(new RichWindowFunction<Tuple2<Long,IntType>,Tuple4<Long,Long,Long,IntType>,Tuple,TimeWindow>(){
      private boolean open=false;
      @Override public void open(      Configuration parameters){
        assertEquals(PARALLELISM,getRuntimeContext().getNumberOfParallelSubtasks());
        open=true;
      }
      @Override public void apply(      Tuple tuple,      TimeWindow window,      Iterable<Tuple2<Long,IntType>> values,      Collector<Tuple4<Long,Long,Long,IntType>> out){
        assertTrue(open);
        int sum=0;
        long key=-1;
        for (        Tuple2<Long,IntType> value : values) {
          sum+=value.f1.value;
          key=value.f0;
        }
        final Tuple4<Long,Long,Long,IntType> result=new Tuple4<>(key,window.getStart(),window.getEnd(),new IntType(sum));
        out.collect(result);
      }
    }
).addSink(new ValidatingSink<>(new SinkValidatorUpdateFun(numElementsPerKey),new SinkValidatorCheckFun(numKeys,numElementsPerKey,windowSize))).setParallelism(1);
    env.execute("Tumbling Window Test");
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}
