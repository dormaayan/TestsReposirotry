/** 
 * Checks that a plan with consecutive UNIONs followed by PARTITION_RANGE is correctly translated. The program can be illustrated as follows: Src1 -\ >-> Union12--< Src2 -/              \ >-> Union123 -> PartitionByRange -> Output Src3 ----------------/ In the resulting plan, the range partitioning must be pushed to the inputs of the unions (Src1, Src2, Src3).
 */
@Test public void testConsecutiveUnionsWithRangePartitioning() throws Exception {
  ExecutionEnvironment env=ExecutionEnvironment.getExecutionEnvironment();
  env.setParallelism(DEFAULT_PARALLELISM);
  DataSet<Tuple2<Long,Long>> src1=env.fromElements(new Tuple2<>(0L,0L));
  DataSet<Tuple2<Long,Long>> src2=env.fromElements(new Tuple2<>(0L,0L));
  DataSet<Tuple2<Long,Long>> src3=env.fromElements(new Tuple2<>(0L,0L));
  DataSet<Tuple2<Long,Long>> union12=src1.union(src2);
  DataSet<Tuple2<Long,Long>> union123=union12.union(src3);
  union123.partitionByRange(1).output(new DiscardingOutputFormat<Tuple2<Long,Long>>()).name("out");
  OptimizedPlan optimizedPlan=compileNoStats(env.createProgramPlan());
  OptimizerPlanNodeResolver resolver=getOptimizerPlanNodeResolver(optimizedPlan);
  SingleInputPlanNode sink=resolver.getNode("out");
  assertEquals("Sink input should be range partitioned.",PartitioningProperty.RANGE_PARTITIONED,sink.getInput().getGlobalProperties().getPartitioning());
  assertEquals("Sink input should be range partitioned on 1",new Ordering(1,null,Order.ASCENDING),sink.getInput().getGlobalProperties().getPartitioningOrdering());
  SingleInputPlanNode partitioner=(SingleInputPlanNode)sink.getInput().getSource();
  assertTrue(partitioner.getDriverStrategy() == DriverStrategy.UNARY_NO_OP);
  assertEquals("Partitioner input should be range partitioned.",PartitioningProperty.RANGE_PARTITIONED,partitioner.getInput().getGlobalProperties().getPartitioning());
  assertEquals("Partitioner input should be range partitioned on 1",new Ordering(1,null,Order.ASCENDING),partitioner.getInput().getGlobalProperties().getPartitioningOrdering());
  assertEquals("Partitioner input channel should be forwarding",ShipStrategyType.FORWARD,partitioner.getInput().getShipStrategy());
  NAryUnionPlanNode union=(NAryUnionPlanNode)partitioner.getInput().getSource();
  for (  Channel c : union.getInputs()) {
    assertEquals("Union input should be range partitioned",PartitioningProperty.RANGE_PARTITIONED,c.getGlobalProperties().getPartitioning());
    assertEquals("Union input channel should be forwarded",ShipStrategyType.FORWARD,c.getShipStrategy());
    SingleInputPlanNode partitionMap=(SingleInputPlanNode)c.getSource();
    assertEquals(DriverStrategy.MAP,partitionMap.getDriverStrategy());
    assertEquals(ShipStrategyType.PARTITION_CUSTOM,partitionMap.getInput().getShipStrategy());
  }
}
