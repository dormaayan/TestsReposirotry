@Test public void testKeyedWithBroadcastTranslation() throws Exception {
  final MapStateDescriptor<Long,String> utterDescriptor=new MapStateDescriptor<>("broadcast-state",BasicTypeInfo.LONG_TYPE_INFO,BasicTypeInfo.STRING_TYPE_INFO);
  final Map<Long,String> expected=new HashMap<>();
  expected.put(0L,"test:0");
  expected.put(1L,"test:1");
  expected.put(2L,"test:2");
  expected.put(3L,"test:3");
  expected.put(4L,"test:4");
  expected.put(5L,"test:5");
  final StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();
  env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
  final DataStream<Long> srcOne=env.generateSequence(0L,5L).assignTimestampsAndWatermarks(new CustomWmEmitter<Long>(){
    private static final long serialVersionUID=-8500904795760316195L;
    @Override public long extractTimestamp(    Long element,    long previousElementTimestamp){
      return element;
    }
  }
).keyBy((KeySelector<Long,Long>)value -> value);
  final DataStream<String> srcTwo=env.fromCollection(expected.values()).assignTimestampsAndWatermarks(new CustomWmEmitter<String>(){
    private static final long serialVersionUID=-2148318224248467213L;
    @Override public long extractTimestamp(    String element,    long previousElementTimestamp){
      return Long.parseLong(element.split(":")[1]);
    }
  }
);
  final BroadcastStream<String> broadcast=srcTwo.broadcast(utterDescriptor);
  final DataStream<String> output=srcOne.connect(broadcast).process(new TestKeyedBroadcastProcessFunction(100000L,expected));
  output.addSink(new TestSink(expected.size())).setParallelism(1);
  env.execute();
}
