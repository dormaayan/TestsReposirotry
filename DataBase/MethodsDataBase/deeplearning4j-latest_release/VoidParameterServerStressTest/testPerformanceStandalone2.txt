/** 
 * This test measures performance of non-blocking messages processing, SkipGramRequestMessage in this case
 */
@Test @Ignore public void testPerformanceStandalone2(){
  VoidConfiguration voidConfiguration=VoidConfiguration.builder().networkMask("192.168.0.0/16").numberOfShards(1).build();
  voidConfiguration.setShardAddresses("192.168.1.35");
  VoidParameterServer parameterServer=new VoidParameterServer();
  parameterServer.init(voidConfiguration);
  parameterServer.initializeSeqVec(100,NUM_WORDS,123,10,true,false);
  final List<Long> times=new CopyOnWriteArrayList<>();
  Thread[] threads=new Thread[8];
  for (int t=0; t < threads.length; t++) {
    final int e=t;
    threads[t]=new Thread(() -> {
      List<Long> results=new ArrayList<>();
      int chunk=NUM_WORDS / threads.length;
      int start=e * chunk;
      int end=(e + 1) * chunk;
      for (int i=0; i < 100000; i++) {
        SkipGramRequestMessage sgrm=getSGRM();
        long time1=System.nanoTime();
        parameterServer.execDistributed(sgrm);
        long time2=System.nanoTime();
        results.add(time2 - time1);
        if ((i + 1) % 1000 == 0)         log.info("Thread {} cnt {}",e,i + 1);
      }
      times.addAll(results);
    }
);
    threads[t].setDaemon(true);
    threads[t].start();
  }
  for (int t=0; t < threads.length; t++) {
    try {
      threads[t].join();
    }
 catch (    Exception e) {
    }
  }
  List<Long> newTimes=new ArrayList<>(times);
  Collections.sort(newTimes);
  log.info("p50: {} us",newTimes.get(newTimes.size() / 2) / 1000);
  parameterServer.shutdown();
}
