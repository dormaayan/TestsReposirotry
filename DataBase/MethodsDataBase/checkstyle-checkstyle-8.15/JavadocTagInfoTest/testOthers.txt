@Test public void testOthers() throws ReflectiveOperationException {
  final JavadocTagInfo[] tags={JavadocTagInfo.CODE,JavadocTagInfo.DOC_ROOT,JavadocTagInfo.LINK,JavadocTagInfo.LINKPLAIN,JavadocTagInfo.LITERAL,JavadocTagInfo.SEE,JavadocTagInfo.SINCE,JavadocTagInfo.VALUE};
  for (  JavadocTagInfo tagInfo : tags) {
    final DetailAST astParent=new DetailAST();
    astParent.setType(TokenTypes.LITERAL_CATCH);
    final DetailAST ast=new DetailAST();
    final Method setParent=ast.getClass().getDeclaredMethod("setParent",DetailAST.class);
    setParent.setAccessible(true);
    setParent.invoke(ast,astParent);
    final int[] validTypes={TokenTypes.PACKAGE_DEF,TokenTypes.CLASS_DEF,TokenTypes.INTERFACE_DEF,TokenTypes.ENUM_DEF,TokenTypes.ANNOTATION_DEF,TokenTypes.METHOD_DEF,TokenTypes.CTOR_DEF,TokenTypes.VARIABLE_DEF};
    for (    int type : validTypes) {
      ast.setType(type);
      assertTrue("Invalid ast type for current tag: " + ast.getType(),tagInfo.isValidOn(ast));
    }
    astParent.setType(TokenTypes.SLIST);
    ast.setType(TokenTypes.VARIABLE_DEF);
    assertFalse("Should return false when ast type is invalid for current tag",tagInfo.isValidOn(ast));
    ast.setType(TokenTypes.PARAMETER_DEF);
    assertFalse("Should return false when ast type is invalid for current tag",tagInfo.isValidOn(ast));
  }
}
