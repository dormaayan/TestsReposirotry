@Test public void testRejectedExecutionSemaphoreWithFallbackViaObserve() throws Exception {
  final TestCircuitBreaker circuitBreaker=new TestCircuitBreaker();
  final ArrayBlockingQueue<Observable<Boolean>> results=new ArrayBlockingQueue<Observable<Boolean>>(2);
  final AtomicBoolean exceptionReceived=new AtomicBoolean();
  final TestSemaphoreCommandWithFallback command1=new TestSemaphoreCommandWithFallback(circuitBreaker,1,200,false);
  Runnable r1=new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(),new Runnable(){
    @Override public void run(){
      try {
        results.add(command1.observe());
      }
 catch (      Exception e) {
        e.printStackTrace();
        exceptionReceived.set(true);
      }
    }
  }
);
  final TestSemaphoreCommandWithFallback command2=new TestSemaphoreCommandWithFallback(circuitBreaker,1,200,false);
  Runnable r2=new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(),new Runnable(){
    @Override public void run(){
      try {
        results.add(command2.observe());
      }
 catch (      Exception e) {
        e.printStackTrace();
        exceptionReceived.set(true);
      }
    }
  }
);
  Thread t1=new Thread(r1);
  Thread t2=new Thread(r2);
  t1.start();
  Thread.sleep(50);
  t2.start();
  t1.join();
  t2.join();
  if (exceptionReceived.get()) {
    fail("We should have received a fallback response");
  }
  final List<Boolean> blockingList=Observable.merge(results).toList().toBlocking().single();
  assertEquals(2,blockingList.size());
  assertTrue(blockingList.contains(Boolean.TRUE));
  assertTrue(blockingList.contains(Boolean.FALSE));
  assertCommandExecutionEvents(command1,HystrixEventType.SUCCESS);
  assertCommandExecutionEvents(command2,HystrixEventType.SEMAPHORE_REJECTED,HystrixEventType.FALLBACK_SUCCESS);
  assertEquals(0,circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
  assertSaneHystrixRequestLog(2);
}
