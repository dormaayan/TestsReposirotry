/** 
 * Test a successful command execution.
 */
@Test public void testCallbackThreadForSemaphoreIsolation() throws Exception {
  final AtomicReference<Thread> commandThread=new AtomicReference<Thread>();
  final AtomicReference<Thread> subscribeThread=new AtomicReference<Thread>();
  TestHystrixCommand<Boolean> command=new TestHystrixCommand<Boolean>(TestHystrixCommand.testPropsBuilder().setCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter().withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE))){
    @Override protected Boolean run(){
      commandThread.set(Thread.currentThread());
      return true;
    }
  }
;
  final CountDownLatch latch=new CountDownLatch(1);
  command.toObservable().subscribe(new Observer<Boolean>(){
    @Override public void onCompleted(){
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      latch.countDown();
      e.printStackTrace();
    }
    @Override public void onNext(    Boolean args){
      subscribeThread.set(Thread.currentThread());
    }
  }
);
  if (!latch.await(2000,TimeUnit.MILLISECONDS)) {
    fail("timed out");
  }
  assertNotNull(commandThread.get());
  assertNotNull(subscribeThread.get());
  System.out.println("Command Thread: " + commandThread.get());
  System.out.println("Subscribe Thread: " + subscribeThread.get());
  String mainThreadName=Thread.currentThread().getName();
  assertTrue(commandThread.get().getName().equals(mainThreadName));
  assertTrue(subscribeThread.get().getName().equals(mainThreadName));
}
