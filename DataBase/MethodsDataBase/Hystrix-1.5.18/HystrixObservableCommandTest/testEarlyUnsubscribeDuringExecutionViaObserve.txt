@Test public void testEarlyUnsubscribeDuringExecutionViaObserve(){
class AsyncCommand extends HystrixObservableCommand<Boolean> {
    public AsyncCommand(){
      super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ASYNC")));
    }
    @Override protected Observable<Boolean> construct(){
      return Observable.defer(new Func0<Observable<Boolean>>(){
        @Override public Observable<Boolean> call(){
          try {
            Thread.sleep(100);
            return Observable.just(true);
          }
 catch (          InterruptedException ex) {
            return Observable.error(ex);
          }
        }
      }
).subscribeOn(Schedulers.io());
    }
  }
  HystrixObservableCommand<Boolean> cmd=new AsyncCommand();
  final CountDownLatch latch=new CountDownLatch(1);
  Observable<Boolean> o=cmd.observe();
  Subscription s=o.doOnUnsubscribe(new Action0(){
    @Override public void call(){
      System.out.println("OnUnsubscribe");
      latch.countDown();
    }
  }
).subscribe(new Subscriber<Boolean>(){
    @Override public void onCompleted(){
      System.out.println("OnCompleted");
      latch.countDown();
    }
    @Override public void onError(    Throwable e){
      System.out.println("OnError : " + e);
    }
    @Override public void onNext(    Boolean b){
      System.out.println("OnNext : " + b);
    }
  }
);
  try {
    s.unsubscribe();
    assertTrue(latch.await(200,TimeUnit.MILLISECONDS));
    assertEquals("Number of execution semaphores in use",0,cmd.getExecutionSemaphore().getNumberOfPermitsUsed());
    assertEquals("Number of fallback semaphores in use",0,cmd.getFallbackSemaphore().getNumberOfPermitsUsed());
    assertFalse(cmd.isExecutionComplete());
    assertFalse(cmd.isExecutedInThread());
    System.out.println("EventCounts : " + cmd.getEventCounts());
    System.out.println("Execution Time : " + cmd.getExecutionTimeInMilliseconds());
    System.out.println("Is Successful : " + cmd.isSuccessfulExecution());
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}
