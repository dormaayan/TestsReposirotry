@Test public void shouldNotSuppressIntermediateEventsWithZeroEmitAfter(){
  final String testId="-shouldNotSuppressIntermediateEventsWithZeroEmitAfter";
  final String appId=getClass().getSimpleName().toLowerCase(Locale.getDefault()) + testId;
  final String input="input" + testId;
  final String outputSuppressed="output-suppressed" + testId;
  final String outputRaw="output-raw" + testId;
  cleanStateBeforeTest(CLUSTER,input,outputSuppressed,outputRaw);
  final StreamsBuilder builder=new StreamsBuilder();
  final KTable<String,Long> valueCounts=buildCountsTable(input,builder);
  valueCounts.suppress(untilTimeLimit(Duration.ZERO,unbounded())).toStream().to(outputSuppressed,Produced.with(STRING_SERDE,Serdes.Long()));
  valueCounts.toStream().to(outputRaw,Produced.with(STRING_SERDE,Serdes.Long()));
  final Properties streamsConfig=getStreamsConfig(appId);
  final KafkaStreams driver=IntegrationTestUtils.getStartedStreams(streamsConfig,builder,true);
  try {
    produceSynchronously(input,asList(new KeyValueTimestamp<>("k1","v1",scaledTime(0L)),new KeyValueTimestamp<>("k1","v2",scaledTime(1L)),new KeyValueTimestamp<>("k2","v1",scaledTime(2L)),new KeyValueTimestamp<>("x","x",scaledTime(4L))));
    verifyOutput(outputRaw,asList(new KeyValueTimestamp<>("v1",1L,scaledTime(0L)),new KeyValueTimestamp<>("v1",0L,scaledTime(1L)),new KeyValueTimestamp<>("v2",1L,scaledTime(1L)),new KeyValueTimestamp<>("v1",1L,scaledTime(2L)),new KeyValueTimestamp<>("x",1L,scaledTime(4L))));
    verifyOutput(outputSuppressed,asList(new KeyValueTimestamp<>("v1",1L,scaledTime(0L)),new KeyValueTimestamp<>("v1",0L,scaledTime(1L)),new KeyValueTimestamp<>("v2",1L,scaledTime(1L)),new KeyValueTimestamp<>("v1",1L,scaledTime(2L)),new KeyValueTimestamp<>("x",1L,scaledTime(4L))));
  }
  finally {
    driver.close();
    cleanStateAfterTest(CLUSTER,driver);
  }
}
